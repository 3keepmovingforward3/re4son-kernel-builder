diff --git a/.gitignore b/.gitignore
index fd3a35592543..731575c99dad 100644
--- a/.gitignore
+++ b/.gitignore
@@ -112,3 +112,9 @@ all.config
 
 # Kdevelop4
 *.kdev4
+
+#
+# Include standard entire 4D-Hat driver directory
+#
+!drivers/video/4d-hats/compress-v6.o
+!drivers/video/4d-hats/compress-v7.o
diff --git a/arch/arm/boot/dts/overlays/Makefile b/arch/arm/boot/dts/overlays/Makefile
index b13e34086ce5..02ba8d1ec4af 100644
--- a/arch/arm/boot/dts/overlays/Makefile
+++ b/arch/arm/boot/dts/overlays/Makefile
@@ -69,6 +69,7 @@ piscreen2r.dtbo \
 	pisound.dtbo \
 	pitft22.dtbo \
 	pitft28-capacitive.dtbo \
+	pitft28c.dtbo \
 	pitft28-resistive.dtbo \
 	pitft35-resistive.dtbo \
 	pps-gpio.dtbo \
diff --git a/arch/arm/boot/dts/overlays/pitft28c-overlay.dts b/arch/arm/boot/dts/overlays/pitft28c-overlay.dts
new file mode 100755
index 000000000000..f540c8cb7ef7
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/pitft28c-overlay.dts
@@ -0,0 +1,85 @@
+/*
+ * Device Tree overlay for pitft by Adafruit
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+        compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+        fragment@0 {
+                target = <&spi0>;
+                __overlay__ {
+                        status = "okay";
+
+                        spidev@0{
+                                status = "disabled";
+                        };
+
+                        spidev@1{
+                                status = "disabled";
+                        };
+                };
+        };
+
+        fragment@1 {
+                target = <&gpio>;
+                __overlay__ {
+                        pitft_pins: pitft_pins {
+                                brcm,pins = <24 25>;
+                                brcm,function = <0 1>; /* in out */
+                                brcm,pull = <2 0>; /* pullup none */
+                        };
+                };
+        };
+
+        fragment@2 {
+                target = <&spi0>;
+                __overlay__ {
+                        /* needed to avoid dtc warning */
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+
+                        pitft: pitft@0{
+                                compatible = "ilitek,ili9340";
+                                reg = <0>;
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&pitft_pins>;
+
+                                spi-max-frequency = <32000000>;
+                                rotate = <90>;
+                                fps = <25>;
+                                bgr;
+                                buswidth = <8>;
+                                dc-gpios = <&gpio 25 0>;
+                                debug = <0>;
+                        };
+
+                };
+        };
+
+        fragment@3 {
+                target = <&i2c1>;
+                __overlay__ {
+                        /* needed to avoid dtc warning */
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        pitft_ctp {
+                                compatible = "focaltech,ft6x06";
+                                reg = <0x38>;
+                                irq-gpio = <&gpio 24 2>;
+                                interrupts = <24 2>;
+                                interrupt-parent = <&gpio>;
+                        };
+                };
+        };
+
+        __overrides__ {
+                speed =   <&pitft>,"spi-max-frequency:0";
+                rotate =  <&pitft>,"rotate:0";
+                fps =     <&pitft>,"fps:0";
+                debug =   <&pitft>,"debug:0";
+        };
+};
diff --git a/arch/arm/boot/dts/overlays/pitft28r-overlay.dts b/arch/arm/boot/dts/overlays/pitft28r-overlay.dts
new file mode 100644
index 000000000000..3e2ebe760fe4
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/pitft28r-overlay.dts
@@ -0,0 +1,120 @@
+/*
+ * Device Tree overlay for pitft by Adafruit
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+        compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+        fragment@0 {
+                target = <&spi0>;
+                __overlay__ {
+                        status = "okay";
+
+                        spidev@0{
+                                status = "disabled";
+                        };
+
+                        spidev@1{
+                                status = "disabled";
+                        };
+                };
+        };
+
+        fragment@1 {
+                target = <&gpio>;
+                __overlay__ {
+                        pitft_pins: pitft_pins {
+                                brcm,pins = <24 25>;
+                                brcm,function = <0 1>; /* in out */
+                                brcm,pull = <2 0>; /* pullup none */
+                        };
+                };
+        };
+
+        fragment@2 {
+                target = <&spi0>;
+                __overlay__ {
+                        /* needed to avoid dtc warning */
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+
+                        pitft: pitft@0{
+                                compatible = "ilitek,ili9340";
+                                reg = <0>;
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&pitft_pins>;
+
+                                spi-max-frequency = <32000000>;
+                                rotate = <90>;
+                                fps = <25>;
+                                bgr;
+                                buswidth = <8>;
+                                dc-gpios = <&gpio 25 0>;
+                                debug = <0>;
+                        };
+
+                        pitft_ts@1 {
+                                #address-cells = <1>;
+                                #size-cells = <0>;
+                                compatible = "st,stmpe610";
+                                reg = <1>;
+
+                                spi-max-frequency = <500000>;
+                                irq-gpio = <&gpio 24 0x2>; /* IRQF_TRIGGER_FALLING */
+                                interrupts = <24 2>; /* high-to-low edge triggered */
+                                interrupt-parent = <&gpio>;
+                                interrupt-controller;
+
+                                stmpe_touchscreen {
+                                        compatible = "st,stmpe-ts";
+                                        st,sample-time = <4>;
+                                        st,mod-12b = <1>;
+                                        st,ref-sel = <0>;
+                                        st,adc-freq = <2>;
+                                        st,ave-ctrl = <3>;
+                                        st,touch-det-delay = <4>;
+                                        st,settling = <2>;
+                                        st,fraction-z = <7>;
+                                        st,i-drive = <0>;
+                                        st,rotation = <90>;
+                                        st,min-x = <250>;
+                                        st,min-y = <200>;
+                                        st,max-x = <3800>;
+                                        st,max-y = <3750>;
+                                };
+
+                                stmpe_gpio: stmpe_gpio {
+                                        #gpio-cells = <2>;
+                                        compatible = "st,stmpe-gpio";
+                                        /*
+                                         * only GPIO2 is wired/available
+                                         * and it is wired to the backlight
+                                         */
+                                        st,norequest-mask = <0x7b>;
+                                };
+                        };
+                };
+        };
+
+        fragment@3 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "gpio-backlight";
+                                gpios = <&stmpe_gpio 2 0>;
+                                default-on;
+                        };
+                };
+        };
+
+        __overrides__ {
+                speed =   <&pitft>,"spi-max-frequency:0";
+                rotate =  <&pitft>,"rotate:0";
+                fps =     <&pitft>,"fps:0";
+                debug =   <&pitft>,"debug:0";
+        };
+};
diff --git a/arch/arm/boot/dts/overlays/pitft35r-overlay.dts b/arch/arm/boot/dts/overlays/pitft35r-overlay.dts
new file mode 100755
index 000000000000..87183f5b66b1
--- /dev/null
+++ b/arch/arm/boot/dts/overlays/pitft35r-overlay.dts
@@ -0,0 +1,115 @@
+/*
+ * Device Tree overlay for pitft by Adafruit
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+        compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+        fragment@0 {
+                target = <&spi0>;
+                __overlay__ {
+                        status = "okay";
+
+                        spidev@0{
+                                status = "disabled";
+                        };
+
+                        spidev@1{
+                                status = "disabled";
+                        };
+                };
+        };
+
+        fragment@1 {
+                target = <&gpio>;
+                __overlay__ {
+                        pitft_pins: pitft_pins {
+                                brcm,pins = <24 25>;
+                                brcm,function = <0 1>; /* in out */
+                                brcm,pull = <2 0>; /* pullup none */
+                        };
+                };
+        };
+
+        fragment@2 {
+                target = <&spi0>;
+                __overlay__ {
+                        /* needed to avoid dtc warning */
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+
+                        pitft: pitft@0{
+                                compatible = "himax,hx8357d";
+                                reg = <0>;
+                                pinctrl-names = "default";
+                                pinctrl-0 = <&pitft_pins>;
+
+                                spi-max-frequency = <32000000>;
+                                rotate = <90>;
+                                fps = <25>;
+                                bgr;
+                                buswidth = <8>;
+                                dc-gpios = <&gpio 25 0>;
+                                debug = <0>;
+                        };
+
+                        pitft_ts@1 {
+                                #address-cells = <1>;
+                                #size-cells = <0>;
+                                compatible = "st,stmpe610";
+                                reg = <1>;
+
+                                spi-max-frequency = <500000>;
+                                irq-gpio = <&gpio 24 0x2>; /* IRQF_TRIGGER_FALLING */
+                                interrupts = <24 2>; /* high-to-low edge triggered */
+                                interrupt-parent = <&gpio>;
+                                interrupt-controller;
+
+                                stmpe_touchscreen {
+                                        compatible = "st,stmpe-ts";
+                                        st,sample-time = <4>;
+                                        st,mod-12b = <1>;
+                                        st,ref-sel = <0>;
+                                        st,adc-freq = <2>;
+                                        st,ave-ctrl = <3>;
+                                        st,touch-det-delay = <4>;
+                                        st,settling = <2>;
+                                        st,fraction-z = <7>;
+                                        st,i-drive = <0>;
+                                };
+
+                                stmpe_gpio: stmpe_gpio {
+                                        #gpio-cells = <2>;
+                                        compatible = "st,stmpe-gpio";
+                                        /*
+                                         * only GPIO2 is wired/available
+                                         * and it is wired to the backlight
+                                         */
+                                        st,norequest-mask = <0x7b>;
+                                };
+                        };
+                };
+        };
+
+        fragment@3 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "gpio-backlight";
+                                gpios = <&stmpe_gpio 2 0>;
+                                default-on;
+                        };
+                };
+        };
+
+        __overrides__ {
+                speed =   <&pitft>,"spi-max-frequency:0";
+                rotate =  <&pitft>,"rotate:0";
+                fps =     <&pitft>,"fps:0";
+                debug =   <&pitft>,"debug:0";
+        };
+};
diff --git a/arch/arm/configs/re4son_pi1_defconfig b/arch/arm/configs/re4son_pi1_defconfig
index 8cd4dcc374cd..407295e4c59e 100644
--- a/arch/arm/configs/re4son_pi1_defconfig
+++ b/arch/arm/configs/re4son_pi1_defconfig
@@ -842,6 +842,12 @@ CONFIG_FB_RPISENSE=m
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_BACKLIGHT_RPI=m
 CONFIG_BACKLIGHT_GPIO=m
+CONFIG_4DHATS=y
+CONFIG_FB_HATS=m
+CONFIG_4DPI_SPI_DMA=m
+# CONFIG_4DPI_ADS7846 is not set
+CONFIG_4DPI_AR1020I2C=m
+CONFIG_4DPI_PWMBL=m
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
diff --git a/arch/arm/configs/re4son_pi2_defconfig b/arch/arm/configs/re4son_pi2_defconfig
index 465741d87296..f0939a99fa58 100644
--- a/arch/arm/configs/re4son_pi2_defconfig
+++ b/arch/arm/configs/re4son_pi2_defconfig
@@ -848,6 +848,12 @@ CONFIG_FB_RPISENSE=m
 # CONFIG_BACKLIGHT_GENERIC is not set
 CONFIG_BACKLIGHT_RPI=m
 CONFIG_BACKLIGHT_GPIO=m
+CONFIG_4DHATS=y
+CONFIG_FB_HATS=m
+CONFIG_4DPI_SPI_DMA=m
+# CONFIG_4DPI_ADS7846 is not set
+CONFIG_4DPI_AR1020I2C=m
+CONFIG_4DPI_PWMBL=m
 CONFIG_FRAMEBUFFER_CONSOLE=y
 CONFIG_LOGO=y
 # CONFIG_LOGO_LINUX_MONO is not set
diff --git a/drivers/input/touchscreen/Kconfig b/drivers/input/touchscreen/Kconfig
index 59357160753f..b89c2858c6d7 100644
--- a/drivers/input/touchscreen/Kconfig
+++ b/drivers/input/touchscreen/Kconfig
@@ -313,6 +313,13 @@ config TOUCHSCREEN_EGALAX_SERIAL
 	  To compile this driver as a module, choose M here: the
 	  module will be called egalax_ts_serial.
 
+config TOUCHSCREEN_FT6X06
+    tristate "FT6x06 I2C toucscreen"
+    depends on I2C
+    help
+      Say Y here to enable support for the I2C connected FT6x06 family
+      of capacitive touchscreen drivers.
+
 config TOUCHSCREEN_FUJITSU
 	tristate "Fujitsu serial touchscreen"
 	select SERIO
diff --git a/drivers/input/touchscreen/Makefile b/drivers/input/touchscreen/Makefile
index 13ab8c05fc0b..162ef93583c6 100644
--- a/drivers/input/touchscreen/Makefile
+++ b/drivers/input/touchscreen/Makefile
@@ -38,6 +38,7 @@ obj-$(CONFIG_TOUCHSCREEN_ELAN)	+= elants_i2c.o
 obj-$(CONFIG_TOUCHSCREEN_ELO)		+= elo.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX)	+= egalax_ts.o
 obj-$(CONFIG_TOUCHSCREEN_EGALAX_SERIAL)	+= egalax_ts_serial.o
+obj-$(CONFIG_TOUCHSCREEN_FT6X06)	+= ft6x06_ts.o
 obj-$(CONFIG_TOUCHSCREEN_FUJITSU)	+= fujitsu_ts.o
 obj-$(CONFIG_TOUCHSCREEN_GOODIX)	+= goodix.o
 obj-$(CONFIG_TOUCHSCREEN_ILI210X)	+= ili210x.o
diff --git a/drivers/input/touchscreen/ft6x06_ts.c b/drivers/input/touchscreen/ft6x06_ts.c
new file mode 100644
index 000000000000..b9721bd2a2b9
--- /dev/null
+++ b/drivers/input/touchscreen/ft6x06_ts.c
@@ -0,0 +1,500 @@
+/* drivers/input/touchscreen/ft6x06_ts.c
+ *
+ * FocalTech ft6x06 TouchScreen driver.
+ *
+ * Copyright (c) 2010  Focal tech Ltd.
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kernel.h>
+#include <linux/semaphore.h>
+#include <linux/mutex.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/syscalls.h>
+#include <linux/unistd.h>
+#include <linux/uaccess.h>
+#include <linux/fs.h>
+#include <linux/string.h>
+#include <linux/timer.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#include <linux/input/ft6x06_ts.h>
+
+struct ts_event {
+	u16 x;
+	u16 y;
+	u8 event; /* 0 -- down; 1-- contact; 2 -- contact */
+	u8 id;
+	u16 pressure;
+};
+
+/* ts_event values */
+#define FTS_POINT_UP		0x01
+#define FTS_POINT_DOWN		0x00
+#define FTS_POINT_CONTACT	0x02
+
+
+struct ft6x06_ts_data {
+	unsigned int irq;
+	unsigned int x_max;
+	unsigned int y_max;
+	struct i2c_client *client;
+	struct input_dev *input_dev;
+	struct ts_event events[CFG_MAX_TOUCH_POINTS];
+	int touch_points;
+	struct ft6x06_platform_data *pdata;
+};
+
+/*
+ * This struct is a touchpoint as stored in hardware.  Note that the id,
+ * as well as the event, are stored in the upper nybble of the hi byte.
+ */
+struct ft6x06_touchpoint {
+	union {
+		u8 xhi;
+		u8 event;
+	};
+	u8 xlo;
+	union {
+		u8 yhi;
+		u8 id;
+	};
+	u8 ylo;
+	u8 unk0;
+	u8 unk1;
+} __attribute__((__packed__));
+
+/* This packet represents the register map as read from offset 0 */
+struct ft6x06_packet {
+	u8 unk0;
+	u8 unk1;
+	u8 touches;
+	struct ft6x06_touchpoint points[CFG_MAX_TOUCH_POINTS];
+} __attribute__((__packed__));
+
+
+static int ft6x06_read(struct i2c_client *client, u8 reg, u8 len, void *data)
+{
+	return i2c_smbus_read_i2c_block_data(client, reg, len, data);
+}
+
+static int ft6x06_read_touchdata(struct ft6x06_ts_data *data)
+{
+	struct ts_event *event = data->events;
+	struct ft6x06_packet buf;
+	int ret;
+	int i;
+
+	ret = ft6x06_read(data->client, 0, sizeof(buf), &buf);
+	if (ret < 0) {
+		dev_err(&data->client->dev, "%s read touchdata failed.\n",
+			__func__);
+		return ret;
+	}
+
+	dev_dbg(&data->input_dev->dev, "detected %d touch events\n",
+			buf.touches);
+
+	data->touch_points = buf.touches;
+	if (data->touch_points > CFG_MAX_TOUCH_POINTS) {
+		dev_err(&data->input_dev->dev,
+			"touchscreen reports %d points, %d are supported\n",
+			data->touch_points, CFG_MAX_TOUCH_POINTS);
+		data->touch_points = CFG_MAX_TOUCH_POINTS;
+	}
+
+	for (i = 0; i < CFG_MAX_TOUCH_POINTS; i++) {
+		event[i].x  = ((buf.points[i].xhi & 0xf) << 8);
+		event[i].x |= buf.points[i].xlo;
+		event[i].y  = ((buf.points[i].yhi & 0xf) << 8);
+		event[i].y |= buf.points[i].ylo;
+		event[i].event = buf.points[i].event >> 6;
+		event[i].id = buf.points[i].id >> 4;
+		event[i].pressure = FT_PRESS;
+	}
+
+	return 0;
+}
+
+static void ft6x06_report_values(struct ft6x06_ts_data *data)
+{
+	struct ts_event *event = data->events;
+	int i = 0;
+
+	for (i = 0; i < data->touch_points; i++) {
+		input_report_abs(data->input_dev, ABS_MT_POSITION_X,
+				 event[i].x);
+		input_report_abs(data->input_dev, ABS_MT_POSITION_Y,
+				 event[i].y);
+		input_report_abs(data->input_dev, ABS_MT_PRESSURE,
+				 event[i].pressure);
+		input_report_abs(data->input_dev, ABS_MT_TRACKING_ID,
+				 event[i].id);
+		if (event[i].event == FTS_POINT_DOWN
+		 || event[i].event == FTS_POINT_CONTACT)
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR,
+					 event[i].pressure);
+		else
+			input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR,
+					 0);
+		input_mt_sync(data->input_dev);
+	}
+
+	/* Legacy touchscreen emulation */
+	if (data->touch_points > 0) {
+		input_report_abs(data->input_dev, ABS_X, event[0].x);
+		input_report_abs(data->input_dev, ABS_Y, event[0].y);
+		input_report_abs(data->input_dev, ABS_PRESSURE, event[0].pressure);
+		input_report_key(data->input_dev, BTN_TOUCH, 1);
+		input_sync(data->input_dev);
+	}
+
+	else if (data->touch_points == 0) {
+		input_report_abs(data->input_dev, ABS_MT_TOUCH_MAJOR, 0);
+		input_report_abs(data->input_dev, ABS_PRESSURE, 0);
+		input_report_key(data->input_dev, BTN_TOUCH, 0);
+		input_sync(data->input_dev);
+	}
+}
+
+static irqreturn_t ft6x06_ts_interrupt(int irq, void *dev_id)
+{
+	struct ft6x06_ts_data *ft6x06_ts = dev_id;
+	int ret = 0;
+
+	ret = ft6x06_read_touchdata(ft6x06_ts);
+	if (ret == 0)
+		ft6x06_report_values(ft6x06_ts);
+
+	return IRQ_HANDLED;
+}
+
+
+
+#ifdef CONFIG_OF
+
+static int request_one_gpio(struct device *dev,
+	const char *name, int index, int *gpiop)
+{
+	struct device_node *node = dev->of_node;
+	int gpio, flags, ret = 0;
+	enum of_gpio_flags of_flags;
+	if (of_find_property(node, name, NULL)) {
+	  gpio = of_get_named_gpio_flags(node, name, index, &of_flags);
+
+	  if (gpio == -ENOENT)
+	    return 0;
+	  if (gpio == -EPROBE_DEFER)
+	    return gpio;
+	  if (gpio < 0) {
+	    dev_err(dev, "failed to get '%s' from DT\n", name);
+	    return gpio;
+	  }
+	  /* active low translates to initially low */
+	  flags = (of_flags & OF_GPIO_ACTIVE_LOW) ? GPIOF_OUT_INIT_LOW : GPIOF_OUT_INIT_HIGH;
+	  ret = devm_gpio_request_one(dev, gpio, flags,
+	  dev->driver->name);
+	  if (ret) {
+	    dev_err(dev, "gpio_request_one('%s'=%d) failed with %d\n", name, gpio, ret);
+	    return ret;
+	  }
+	  if (gpiop)
+		*gpiop = gpio;
+	}
+	return ret;
+}
+
+
+static int ft6x06_parse_dt(struct device *dev,
+			struct ft6x06_platform_data *pdata)
+{
+	struct device_node *np = dev->of_node;
+
+/*
+	pdata->reset_gpio = request_one_gpio(dev, "reset-gpio",
+		0, &pdata->reset_gpio);
+*/
+	/* reset, irq gpio info */
+	pdata->reset_gpio = of_get_named_gpio_flags(np, "reset-gpio",
+				0, &pdata->reset_gpio);
+
+//	printk(KERN_ALERT "RST GPIO = %d\n", pdata->reset_gpio);
+
+//	if (pdata->reset_gpio < 0)
+//		return pdata->reset_gpio;
+
+	pdata->irq_gpio = of_get_named_gpio_flags(np, "irq-gpio",
+				0, &pdata->irq_gpio);
+
+/*
+	pdata->irq_gpio = request_one_gpio(dev, "irq-gpio",
+		0, &pdata->irq_gpio);
+*/
+
+	if (pdata->irq_gpio < 0)
+		return pdata->irq_gpio;
+
+
+	return 0;
+}
+#else
+static int ft6x06_parse_dt(struct device *dev,
+			struct ft6x06_ts_platform_data *pdata)
+{
+	return -ENODEV;
+}
+#endif
+
+static int ft6x06_ts_probe(struct i2c_client *client,
+			   const struct i2c_device_id *id)
+{
+	struct ft6x06_platform_data *pdata;
+	struct ft6x06_ts_data *ft6x06_ts;
+	struct input_dev *input_dev;
+	int err = 0;
+
+	if (client->dev.of_node) {
+		pdata = devm_kzalloc(&client->dev,
+			sizeof(struct ft6x06_platform_data), GFP_KERNEL);
+		if (!pdata) {
+			dev_err(&client->dev, "Failed to allocate memory\n");
+			return -ENOMEM;
+		}
+		err = ft6x06_parse_dt(&client->dev, pdata);
+		if (err)
+			return err;
+	} else {
+		pdata = (struct ft6x06_platform_data *)client->dev.platform_data;
+	}
+
+	if (!pdata) {
+		dev_err(&client->dev, "Invalid pdata\n");
+		return -EINVAL;
+	}
+
+	if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+		err = -ENODEV;
+		goto exit_check_functionality_failed;
+	}
+
+	ft6x06_ts = kzalloc(sizeof(struct ft6x06_ts_data), GFP_KERNEL);
+
+	if (!ft6x06_ts) {
+		err = -ENOMEM;
+		goto exit_alloc_data_failed;
+	}
+
+	i2c_set_clientdata(client, ft6x06_ts);
+	ft6x06_ts->client = client;
+	ft6x06_ts->pdata = pdata;
+	ft6x06_ts->x_max = 4095;
+	ft6x06_ts->y_max = 4095;
+
+#ifdef CONFIG_PM
+	if (gpio_is_valid(pdata->reset_gpio)) {
+		err = devm_gpio_request(&client->dev, pdata->reset_gpio,
+					"ft6x06 reset");
+		if (err < 0) {
+			dev_err(&client->dev, "%s: failed to set gpio reset.\n",
+				__func__);
+			goto exit_request_reset;
+		}
+	}
+#endif
+
+/* ???
+	err = devm_gpio_request_one(&client->dev, pdata->irq_gpio,
+				GPIOF_DIR_IN, "ft6x06 irq");
+	if (err) {
+		dev_err(&client->dev, "failed to request IRQ GPIO: %d\n", err);
+		goto exit_request_reset;
+	}
+*/
+	ft6x06_ts->irq = gpio_to_irq(pdata->irq_gpio);
+
+	err = devm_request_threaded_irq(&client->dev, ft6x06_ts->irq,
+					NULL, ft6x06_ts_interrupt,
+					IRQF_ONESHOT | IRQF_TRIGGER_FALLING,
+					client->dev.driver->name, ft6x06_ts);
+	if (err < 0) {
+		dev_err(&client->dev, "%s: request irq failed\n", __func__);
+		goto exit_irq_request_failed;
+	}
+
+	input_dev = input_allocate_device();
+	if (!input_dev) {
+		err = -ENOMEM;
+		dev_err(&client->dev, "failed to allocate input device\n");
+		goto exit_input_dev_alloc_failed;
+	}
+
+	ft6x06_ts->input_dev = input_dev;
+
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	set_bit(ABS_MT_TOUCH_MAJOR, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_X, input_dev->absbit);
+	set_bit(ABS_MT_POSITION_Y, input_dev->absbit);
+	set_bit(ABS_MT_PRESSURE, input_dev->absbit);
+
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_X, 0, ft6x06_ts->x_max, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_POSITION_Y, 0, ft6x06_ts->y_max, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_TOUCH_MAJOR, 0, PRESS_MAX, 0, 0);
+	input_set_abs_params(input_dev, ABS_MT_PRESSURE, 0, PRESS_MAX, 0, 0);
+	input_set_abs_params(input_dev,
+			     ABS_MT_TRACKING_ID, 0, CFG_MAX_TOUCH_POINTS, 0, 0);
+	input_set_abs_params(input_dev, ABS_X, 0, ft6x06_ts->x_max, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, ft6x06_ts->y_max, 0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE, 0, PRESS_MAX, 0, 0);
+
+	set_bit(EV_KEY, input_dev->evbit);
+	set_bit(EV_ABS, input_dev->evbit);
+
+	input_dev->name = FT6X06_NAME;
+	err = input_register_device(input_dev);
+	if (err) {
+		dev_err(&client->dev,
+			"ft6x06_ts_probe: failed to register input device: %s\n",
+			dev_name(&client->dev));
+		goto exit_input_register_device_failed;
+	}
+
+	/* allow touch panel controller to boot, before querying it */
+	msleep(150);
+
+#ifdef DEBUG
+	{
+		u8 val;
+		ft6x06_read(client, FT6x06_REG_FW_VER, 1, &val);
+		dev_dbg(&client->dev, "[FTS] Firmware version = 0x%x\n", val);
+
+		ft6x06_read(client, FT6x06_REG_POINT_RATE, 1, &val);
+		dev_dbg(&client->dev, "[FTS] report rate is %dHz.\n",
+			val * 10);
+
+		ft6x06_read(client, FT6x06_REG_THGROUP, 1, &val);
+		dev_dbg(&client->dev, "[FTS] touch threshold is %d.\n",
+			val * 4);
+#endif
+
+	return 0;
+
+exit_input_register_device_failed:
+	input_free_device(input_dev);
+
+exit_input_dev_alloc_failed:
+exit_request_reset:
+exit_irq_request_failed:
+	i2c_set_clientdata(client, NULL);
+	kfree(ft6x06_ts);
+
+exit_alloc_data_failed:
+exit_check_functionality_failed:
+	return err;
+}
+
+#ifdef CONFIG_PM
+static int ft6x06_ts_suspend(struct device *dev, pm_message_t mesg)
+{
+	struct ft6x06_ts_data *ts = dev_get_drvdata(dev);
+	dev_dbg(&ts->client->dev, "[FTS]ft6x06 suspend\n");
+	disable_irq(ts->pdata->irq_gpio);
+	return 0;
+}
+
+static int ft6x06_ts_resume(struct device *dev)
+{
+	struct ft6x06_ts_data *ts = dev_get_drvdata(dev);
+	dev_dbg(&ts->client->dev, "[FTS]ft6x06 resume.\n");
+	if (gpio_is_valid(ts->pdata->reset_gpio)) {
+		gpio_set_value(ts->pdata->reset_gpio, 0);
+		msleep(20);
+		gpio_set_value(ts->pdata->reset_gpio, 1);
+	}
+	enable_irq(ts->pdata->irq_gpio);
+	return 0;
+}
+#else
+#define ft6x06_ts_suspend	NULL
+#define ft6x06_ts_resume		NULL
+#endif
+
+static int ft6x06_ts_remove(struct i2c_client *client)
+{
+	struct ft6x06_ts_data *ft6x06_ts;
+	ft6x06_ts = i2c_get_clientdata(client);
+	input_unregister_device(ft6x06_ts->input_dev);
+	kfree(ft6x06_ts);
+	i2c_set_clientdata(client, NULL);
+	return 0;
+}
+
+static const struct i2c_device_id ft6x06_ts_id[] = {
+	{FT6X06_NAME, 0},
+	{}
+};
+
+MODULE_DEVICE_TABLE(i2c, ft6x06_ts_id);
+
+#ifdef CONFIG_OF
+static struct of_device_id ft6x06_match_table[] = {
+	{ .compatible = "focaltech,ft6x06",},
+	{ },
+};
+#else
+#define ft6x06_match_table NULL
+#endif
+
+static struct i2c_driver ft6x06_ts_driver = {
+	.probe = ft6x06_ts_probe,
+	.remove = ft6x06_ts_remove,
+	.id_table = ft6x06_ts_id,
+	.driver = {
+		.name = FT6X06_NAME,
+		.owner = THIS_MODULE,
+		.of_match_table=ft6x06_match_table,
+		.suspend = ft6x06_ts_suspend,
+		.resume = ft6x06_ts_resume,
+	},
+};
+
+static int __init ft6x06_ts_init(void)
+{
+	int ret;
+	ret = i2c_add_driver(&ft6x06_ts_driver);
+	if (ret)
+		pr_err("Adding ft6x06 driver failed (errno = %d)\n", ret);
+
+	return ret;
+}
+
+static void __exit ft6x06_ts_exit(void)
+{
+	i2c_del_driver(&ft6x06_ts_driver);
+}
+
+module_init(ft6x06_ts_init);
+module_exit(ft6x06_ts_exit);
+
+MODULE_AUTHOR("Sean Cross <xobs@kosagi.com>");
+MODULE_DESCRIPTION("FocalTech ft6x06 TouchScreen driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/input/touchscreen/stmpe-ts.c b/drivers/input/touchscreen/stmpe-ts.c
index e414d43e5159..409b81fd70e5 100644
--- a/drivers/input/touchscreen/stmpe-ts.c
+++ b/drivers/input/touchscreen/stmpe-ts.c
@@ -48,6 +48,7 @@
 #define STMPE_FIFO_STA_RESET		(1<<0)
 
 #define STMPE_IRQ_TOUCH_DET		0
+#define STMPE_IRQ_FIFO_TH		1
 
 #define SAMPLE_TIME(x)			((x & 0xf) << 4)
 #define MOD_12B(x)			((x & 0x1) << 3)
@@ -79,6 +80,9 @@ struct stmpe_touch {
 	u8 i_drive;
 };
 
+static unsigned debug;
+module_param(debug, uint, 0);
+
 static int __stmpe_reset_fifo(struct stmpe *stmpe)
 {
 	int ret;
@@ -100,6 +104,9 @@ static void stmpe_work(struct work_struct *work)
 	struct stmpe_touch *ts =
 	    container_of(work, struct stmpe_touch, work.work);
 
+	if (debug > 1)
+		printk("%s()\n", __func__);
+
 	int_sta = stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA);
 
 	/*
@@ -115,12 +122,36 @@ static void stmpe_work(struct work_struct *work)
 		udelay(100);
 	}
 
+	if (debug > 1)
+		printk("    timeout=%u, INT_STA=0x%02X\n", timeout, int_sta);
+
 	/* reset the FIFO before we report release event */
 	__stmpe_reset_fifo(ts->stmpe);
 
 	input_report_abs(ts->idev, ABS_PRESSURE, 0);
 	input_report_key(ts->idev, BTN_TOUCH, 0);
 	input_sync(ts->idev);
+
+	/*
+	 * Sometimes the FIFO_TH interrupt flag is not cleared.
+	 * This prevents the controller from generating a new interrupt.
+	 * Clear the flag and re-enable the touchscreen controller to be
+	 * sure it's in working order again.
+	 * If a touch IRQ happens while in this function, FIFO_TH will be set,
+	 * but it doesn't indicate a hang. We reset anyway since the
+	 * consequence is loosing just one data point.
+	 */
+	if (int_sta & (1 << STMPE_IRQ_FIFO_TH)) {
+		stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
+				STMPE_TSC_CTRL_TSC_EN, 0);
+		stmpe_reg_write(ts->stmpe, STMPE_REG_INT_STA, (1 << STMPE_IRQ_FIFO_TH));
+		__stmpe_reset_fifo(ts->stmpe);
+		stmpe_set_bits(ts->stmpe, STMPE_REG_TSC_CTRL,
+			STMPE_TSC_CTRL_TSC_EN, STMPE_TSC_CTRL_TSC_EN);
+		if (debug)
+			printk("    cleared interrupt flag FIFO_TH, INT_STA: 0x%02X -> 0x%02X\n",
+				int_sta, stmpe_reg_read(ts->stmpe, STMPE_REG_INT_STA));
+	}
 }
 
 static irqreturn_t stmpe_ts_handler(int irq, void *data)
@@ -129,6 +160,9 @@ static irqreturn_t stmpe_ts_handler(int irq, void *data)
 	int x, y, z;
 	struct stmpe_touch *ts = data;
 
+	if (debug > 1)
+		printk("%s()\n", __func__);
+
 	/*
 	 * Cancel scheduled polling for release if we have new value
 	 * available. Wait if the polling is already running.
@@ -150,11 +184,19 @@ static irqreturn_t stmpe_ts_handler(int irq, void *data)
 	y = ((data_set[1] & 0xf) << 8) | data_set[2];
 	z = data_set[3];
 
-	input_report_abs(ts->idev, ABS_X, x);
-	input_report_abs(ts->idev, ABS_Y, y);
-	input_report_abs(ts->idev, ABS_PRESSURE, z);
-	input_report_key(ts->idev, BTN_TOUCH, 1);
-	input_sync(ts->idev);
+	/*
+	 * Skip empty datasets
+	 * If stmpe_ts_handler() interrupts stmpe_work(), and stmpe_work
+	 * hasn't reset the FIFO yet, the FIFO will be empty here.
+	 * This is because stmpe_ts_handler waits for stmpe_work to finish
+	 */
+	if (x && y && z) {
+	       input_report_abs(ts->idev, ABS_X, x);
+	       input_report_abs(ts->idev, ABS_Y, y);
+	       input_report_abs(ts->idev, ABS_PRESSURE, 0xff - z);
+	       input_report_key(ts->idev, BTN_TOUCH, 1);
+	       input_sync(ts->idev);
+	}
 
        /* flush the FIFO after we have read out our values. */
 	__stmpe_reset_fifo(ts->stmpe);
@@ -346,6 +388,8 @@ static int stmpe_input_probe(struct platform_device *pdev)
 	input_set_abs_params(idev, ABS_X, 0, XY_MASK, 0, 0);
 	input_set_abs_params(idev, ABS_Y, 0, XY_MASK, 0, 0);
 	input_set_abs_params(idev, ABS_PRESSURE, 0x0, 0xff, 0, 0);
+	set_bit(ABS_PRESSURE, idev->absbit);
+	set_bit(BTN_TOUCH, idev->keybit);
 
 	error = input_register_device(idev);
 	if (error) {
diff --git a/drivers/power/supply/Kconfig b/drivers/power/supply/Kconfig
index 237d7aa73e8c..6dd0cde98761 100644
--- a/drivers/power/supply/Kconfig
+++ b/drivers/power/supply/Kconfig
@@ -75,6 +75,11 @@ config BATTERY_88PM860X
 	help
 	  Say Y here to enable battery monitor for Marvell 88PM860x chip.
 
+config RPI_POWER_SWITCH
+	tristate "Raspberry Pi GPIO power switch"
+	help
+	  Use a GPIO as a pseudo power switch.
+
 config BATTERY_ACT8945A
 	tristate "Active-semi ACT8945A charger driver"
 	depends on MFD_ACT8945A || COMPILE_TEST
diff --git a/drivers/power/supply/Makefile b/drivers/power/supply/Makefile
index b656638f8b39..d03761bbc734 100644
--- a/drivers/power/supply/Makefile
+++ b/drivers/power/supply/Makefile
@@ -15,6 +15,7 @@ obj-$(CONFIG_WM831X_BACKUP)	+= wm831x_backup.o
 obj-$(CONFIG_WM831X_POWER)	+= wm831x_power.o
 obj-$(CONFIG_WM8350_POWER)	+= wm8350_power.o
 obj-$(CONFIG_TEST_POWER)	+= test_power.o
+obj-$(CONFIG_RPI_POWER_SWITCH)	+= rpi_power_switch.o
 
 obj-$(CONFIG_BATTERY_88PM860X)	+= 88pm860x_battery.o
 obj-$(CONFIG_BATTERY_ACT8945A)	+= act8945a_charger.o
diff --git a/drivers/power/supply/rpi_power_switch.c b/drivers/power/supply/rpi_power_switch.c
new file mode 100644
index 000000000000..a6a9e70d6039
--- /dev/null
+++ b/drivers/power/supply/rpi_power_switch.c
@@ -0,0 +1,450 @@
+/*
+ * Adafruit power switch driver for Raspberry Pi
+ *
+ * Simulated power switch / button, using the GPIO banks.
+ *
+ * - Written by Sean Cross for Adafruit Industries (www.adafruit.com)
+ */
+
+#define RPI_POWER_SWITCH_VERSION "1.7"
+#define POWER_SWITCH_CLASS_NAME "rpi-power-switch"
+
+#include <linux/module.h>
+
+#include <asm/io.h>
+#include <asm/gpio.h>
+#include <linux/delay.h>
+#include <linux/reboot.h>
+#include <linux/irq.h>
+#include <linux/err.h>
+#include <linux/kdev_t.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/init.h>
+#include <linux/workqueue.h>
+#include <mach/platform.h>
+
+
+/* the BCM2709 redefines this for us right!
+#define BCM2708_PERI_BASE	0x20000000
+*/
+#define GPIO_BASE		(BCM2708_PERI_BASE + 0x200000)
+
+#define GPPUD (gpio_reg+0x94)
+#define GPPUDCLK0 (gpio_reg+0x98)
+#define GPPUDCLK1 (gpio_reg+0x9C)
+#define GPSET0    (gpio_reg+0x1c)
+#define GPSET1    (gpio_reg+0x20)
+#define GPCLR0    (gpio_reg+0x28)
+#define GPCLR1    (gpio_reg+0x2c)
+
+#define GPIO_REG(g) (gpio_reg+((g/10)*4))
+#define SET_GPIO_OUTPUT(g) \
+	__raw_writel( 							\
+		(1<<(((g)%10)*3))					\
+		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
+		GPIO_REG(g))
+#define SET_GPIO_INPUT(g) \
+	__raw_writel( 							\
+		0							\
+		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
+		GPIO_REG(g))
+#define SET_GPIO_ALT(g,a) \
+	__raw_writel( 							\
+		(((a)<=3?(a)+4:(a)==4?3:2)<<(((g)%10)*3))		\
+		| (__raw_readl(GPIO_REG(g)) & (~(7<<(((g)%10)*3)))),	\
+		GPIO_REG(g))
+
+enum button_mode {
+	MODE_BUTTON = 0,
+	MODE_SWITCH = 1,
+};
+
+
+enum gpio_pull_direction {
+	GPIO_PULL_NONE = 0,
+	GPIO_PULL_DOWN = 1,
+	GPIO_PULL_UP = 2,
+};
+
+
+/* Module Parameters */
+static int gpio_pin = 22;
+static int mode = MODE_SWITCH;
+static int led_pin = 16;
+
+/* This is the base state.  When this changes, do a shutdown. */
+static int gpio_pol;
+
+static void __iomem *gpio_reg;
+static void (*old_pm_power_off)(void);
+static struct device *switch_dev;
+static int raw_gpio = 0;
+
+
+/* Attach either a pull up or pull down to the specified GPIO pin.  Or
+ * clear any pull on the pin, if requested.
+ */
+static int set_gpio_pull(int gpio, enum gpio_pull_direction direction) {
+	long *bank;
+	int pin;
+
+	bank = ((gpio&(~31))?GPPUDCLK1:GPPUDCLK0);
+	pin = gpio & 31;
+
+	/* Set the direction (involves two writes and a clock wait) */
+	__raw_writel(direction, GPPUD);
+	udelay(20);
+	__raw_writel(1<<pin, bank);
+	udelay(20);
+
+	/* Cleanup */
+	__raw_writel(0, GPPUD);
+	__raw_writel(0, bank);
+	return 0;
+}
+
+
+/* If the GPIO we want to use is already being used (e.g. if a driver
+ * forgot to call gpio_free() during its module_exit() call), then we
+ * will have to directly access the GPIO registers in order to set or
+ * clear values.
+ */
+static int raw_gpio_set(int gpio, int val) {
+	if (gpio < 0 || gpio > 63)
+		return -1;
+	else if (gpio < 32)
+		__raw_writel(1<<gpio, val?GPSET0:GPCLR0);
+	else if (gpio < 64)
+		__raw_writel(1<<gpio, val?GPSET1:GPCLR1);
+	return 0;
+}
+
+/* Bottom half of the power switch ISR.
+ * We need to break this out here, as you can't run call_usermodehelper
+ * from an interrupt context.
+ * This function will actually Call /sbin/shutdown when the switch gets hit.
+ */
+static void initiate_shutdown(struct work_struct *work) {
+	int ret;
+	char *cmd = "/sbin/shutdown";
+	char *argv[] = {
+		cmd,
+		"-h",
+		"now",
+		NULL,
+	};
+	char *envp[] = {
+		"HOME=/",
+		"PATH=/sbin:/bin:/usr/sbin:/usr/bin",
+		NULL,
+	};
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	/* We only want this IRQ to fire once, ever. */
+	free_irq(gpio_to_irq(gpio_pin), NULL);
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	/* Make sure the switch hasn't just bounced */
+	if (mode == MODE_SWITCH && gpio_get_value(gpio_pin) != gpio_pol)
+		return;
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+
+	ret = call_usermodehelper(cmd, argv, envp, UMH_WAIT_PROC);
+
+//printk(KERN_ALERT "returned %d\n", ret);
+
+}
+
+static struct delayed_work initiate_shutdown_work;
+
+
+/* This ISR gets called when the board is "off" and the switch changes.
+ * It indicates we should start back up again, which means we need to
+ * do a reboot.
+ */
+static irqreturn_t reboot_isr(int irqno, void *param) {
+	emergency_restart();
+	return IRQ_HANDLED;
+}
+
+
+
+/* Pulse the GPIO low for /duty/ cycles and then /high/ for 100-duty cycles.
+ * Returns the number of usecs delayed.
+ */
+#define RATE 1
+static int gpio_pulse(int gpio, int duty) {
+	int low;
+	int high;
+
+	if (duty < 0)
+		duty = 0;
+	if (duty > 100)
+		duty = 100;
+	low = duty;
+	high = 100-duty;
+
+	if (raw_gpio)
+		raw_gpio_set(gpio, 0);
+	else
+		gpio_set_value(gpio, 0);
+	udelay(RATE*low);
+
+	if (raw_gpio)
+		raw_gpio_set(gpio, 1);
+	else
+		gpio_set_value(gpio, 1);
+	udelay(RATE*high);
+
+	return (RATE*low)+(RATE*high);
+}
+
+
+
+/* Give an indication that it's safe to turn off the board.  Pulse the LED
+ * in a kind of "breathing" pattern, so the user knows that it's
+ * "powered down".
+ */
+static int do_breathing_forever(int gpio) {
+	int err;
+	err = gpio_request(gpio, "LED light");
+	if (err < 0) {
+		pr_err("Unable to request GPIO, switching to raw access");
+		raw_gpio = 1;
+	}
+	SET_GPIO_OUTPUT(gpio);
+
+	while (1) {
+		int usecs;
+		/* We want four seconds:
+		 *   - One second of ramp-up
+		 *   - One second of ramp-down
+		 *   - Two seconds of low
+		 */
+		for (usecs=0; usecs < 800000; )
+			usecs += gpio_pulse(gpio, ((usecs*9)/80000)+10);
+
+		for (usecs=0; usecs < 800000; )
+			usecs += gpio_pulse(gpio, 100-((usecs*9)/80000));
+
+		for (usecs=0; usecs < 800000; )
+			usecs += gpio_pulse(gpio, 10);
+
+		for (usecs=0; usecs < 800000; )
+			usecs += gpio_pulse(gpio, 10);
+	}
+	return 0;
+}
+
+
+
+/* Our shutdown function.  Execution will stay here until the switch is
+ * flipped.
+ * NOTE: The default power_off function sends a message to the GPU via
+ * a mailbox message to shut down most parts of the core.  Since we don't
+ * have any documentation on the mailbox message formats, we will leave
+ * the CPU powered up here but not executing any code in order to simulate
+ * an "off" state.
+ */
+static void rpi_power_switch_power_off(void) {
+	int ret;
+	pr_info("Waiting for the switch to be flipped back...\n");
+	if (mode == MODE_SWITCH)
+		gpio_pol = !gpio_pol;
+	ret = request_irq(gpio_to_irq(gpio_pin), reboot_isr,
+			  gpio_pol?IRQF_TRIGGER_RISING:IRQF_TRIGGER_FALLING,
+			  "Reboot ISR", NULL);
+
+	/* If it's taken us so long to reboot that the switch was flipped,
+	 * immediately reboot.
+	 */
+	if (gpio_pol == gpio_get_value(gpio_pin))
+		reboot_isr(0, NULL);
+
+	do_breathing_forever(led_pin);
+	return;
+}
+
+
+static irqreturn_t power_isr(int irqno, void *param) {
+	schedule_delayed_work(&initiate_shutdown_work, msecs_to_jiffies(100));
+	return IRQ_HANDLED;
+}
+
+
+
+/* Sysfs entry */
+
+static ssize_t do_shutdown_show(struct device *d,
+				struct device_attribute *attr, char *buf)
+{
+        ssize_t ret;
+        ret = sprintf(buf, "Write into this file to initiate a shutdown\n");
+        return ret;
+}
+
+static ssize_t do_shutdown_store(struct device *d,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	if (mode == MODE_SWITCH)
+		gpio_pol = !gpio_pol;
+	schedule_delayed_work(&initiate_shutdown_work, msecs_to_jiffies(10));
+	return count;
+}
+static DEVICE_ATTR(do_shutdown, 0660, do_shutdown_show, do_shutdown_store);
+
+static struct attribute *rpi_power_switch_sysfs_entries[] = {
+	&dev_attr_do_shutdown.attr,
+	NULL,
+};
+
+static struct attribute_group rpi_power_switch_attribute_group = {
+        .name = NULL,
+        .attrs = rpi_power_switch_sysfs_entries,
+};
+
+static struct class power_switch_class = {
+	.name =		POWER_SWITCH_CLASS_NAME,
+	.owner =	THIS_MODULE,
+};
+
+
+
+
+/* Main module entry point */
+
+int __init rpi_power_switch_init(void)
+{
+	int ret = 0;
+
+	old_pm_power_off = pm_power_off;
+	pm_power_off = rpi_power_switch_power_off;
+
+	pr_info("Adafruit Industries' power switch driver v%s\n",
+		RPI_POWER_SWITCH_VERSION);
+
+	INIT_DELAYED_WORK(&initiate_shutdown_work, initiate_shutdown);
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	/* Register our own class for the power switch */
+	ret = class_register(&power_switch_class);
+        if (ret < 0) {
+		pr_err("%s: Unable to register class\n", power_switch_class.name);
+		goto out0;
+	}
+
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+        /* Create devices for each PWM present */
+	switch_dev = device_create(&power_switch_class, &platform_bus,
+                                MKDEV(0, 0), NULL, "pswitch%u", 0);
+	if (IS_ERR(switch_dev)) {
+		pr_err("%s: device_create failed\n", power_switch_class.name);
+		ret = PTR_ERR(switch_dev);
+		goto out1;
+        }
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	ret = sysfs_create_group(&switch_dev->kobj,
+				 &rpi_power_switch_attribute_group);
+	if (ret < 0) {
+		pr_err("%s: create_group failed\n", power_switch_class.name);
+		goto out2;
+	}
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	/* GPIO register memory must be mapped before doing any direct
+	 * accesses such as changing GPIO alt functions or changing GPIO
+	 * pull ups or pull downs.
+	 */
+	gpio_reg = ioremap(GPIO_BASE, 1024);
+
+	/* Set the specified pin as a GPIO input */
+	SET_GPIO_INPUT(gpio_pin);
+
+	/* Set the pin as a pulldown.  Most pins should default to having
+	 * pulldowns, and this seems most intuitive.
+	 */
+	set_gpio_pull(gpio_pin, GPIO_PULL_UP);
+
+	ret = gpio_request(gpio_pin, "Power switch");
+	if (ret) {
+		printk(KERN_ALERT "GPIO request failure: %d\n", ret);
+		goto out3;
+	}
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	gpio_direction_input(gpio_pin);
+
+	/* The targeted polarity should be the opposite of the current value.
+	 * I.e. we want the pin to transition to this state in order to
+	 * initiate a shutdown.
+	 */
+	gpio_pol = !gpio_get_value(gpio_pin);
+
+	/* Request an interrupt to fire when the pin transitions to our
+	 * desired state.
+	 */
+	ret = request_irq(__gpio_to_irq(gpio_pin), power_isr,
+			  gpio_pol?IRQF_TRIGGER_RISING:IRQF_TRIGGER_FALLING,
+			  "Power button", NULL);
+	if (ret) {
+		pr_err("Unable to request IRQ\n");
+		goto out3;
+	}
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+	return 0;
+
+
+	/* Error handling */
+out3:
+	sysfs_remove_group(&switch_dev->kobj,&rpi_power_switch_attribute_group);
+out2:
+	device_unregister(switch_dev);
+out1:
+	class_unregister(&power_switch_class);
+out0:
+	iounmap(gpio_reg);
+	pm_power_off = old_pm_power_off;
+	return ret;
+}
+
+
+/* Main module exit point (called at unload) */
+
+void __exit rpi_power_switch_cleanup(void)
+{
+
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	sysfs_remove_group(&switch_dev->kobj,&rpi_power_switch_attribute_group);
+	device_unregister(switch_dev);
+	free_irq(__gpio_to_irq(gpio_pin), NULL);
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+	gpio_free(gpio_pin);
+	pm_power_off = old_pm_power_off;
+	class_unregister(&power_switch_class);
+	iounmap(gpio_reg);
+//printk(KERN_ALERT "DEBUG: Passed %s %d \n",__FUNCTION__,__LINE__);
+
+}
+
+module_init(rpi_power_switch_init);
+module_exit(rpi_power_switch_cleanup);
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Sean Cross <xobs@xoblo.gs> for Adafruit Industries <www.adafruit.com>");
+MODULE_ALIAS("platform:bcm2708_power_switch");
+module_param(gpio_pin, int, 0);
+module_param(led_pin, int, 0);
+module_param(mode, int, 0);
diff --git a/drivers/staging/fbtft/fb_hx8357d.c b/drivers/staging/fbtft/fb_hx8357d.c
index a381dbcf5535..eb432aa9c626 100644
--- a/drivers/staging/fbtft/fb_hx8357d.c
+++ b/drivers/staging/fbtft/fb_hx8357d.c
@@ -1,8 +1,6 @@
 /*
  * FB driver for the HX8357D LCD Controller
- * Copyright (C) 2015 Adafruit Industries
  *
- * Based on the HX8347D FB driver
  * Copyright (C) 2013 Christian Vogelgsang
  *
  * Based on driver code found here: https://github.com/watterott/r61505u-Adapter
@@ -16,6 +14,10 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  */
 
 #include <linux/module.h>
@@ -30,17 +32,51 @@
 #define WIDTH		320
 #define HEIGHT		480
 
+/***************** my sekret register writer @ 8MHz */
+static int slow_write_spi(struct fbtft_par *par, void *buf, size_t len)
+{
+  struct spi_transfer t = {
+    .tx_buf = buf,
+    .len = len,
+    .speed_hz = 8000000,
+  };
+  struct spi_message m;
+
+  fbtft_par_dbg_hex(DEBUG_WRITE, par, par->info->device, u8, buf, len,
+                    "%s(len=%d): ", __func__, len);
+
+  if (!par->spi) {
+    dev_err(par->info->device,
+            "%s: par->spi is unexpectedly NULL\n", __func__);
+    return -1;
+  }
+
+  spi_message_init(&m);
+  if (par->txbuf.dma && buf == par->txbuf.buf) {
+    t.tx_dma = par->txbuf.dma;
+    m.is_dma_mapped = 1;
+  }
+  spi_message_add_tail(&t, &m);
+  return spi_sync(par->spi, &m);
+}
+
+/***************** my sekret register writer @ 8MHz */
+
 static int init_display(struct fbtft_par *par)
 {
+        /* slow down spi-speed for writing registers */
+	par->fbtftops.write = slow_write_spi;
+
+	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
+
 	par->fbtftops.reset(par);
 
 	/* Reset things like Gamma */
 	write_reg(par, MIPI_DCS_SOFT_RESET);
-	usleep_range(5000, 7000);
 
 	/* setextc */
 	write_reg(par, HX8357D_SETC, 0xFF, 0x83, 0x57);
-	msleep(150);
+	mdelay(300);
 
 	/* setRGB which also enables SDO */
 	write_reg(par, HX8357_SETRGB, 0x00, 0x00, 0x06, 0x06);
@@ -128,16 +164,26 @@ static int init_display(struct fbtft_par *par)
 
 	/* Exit Sleep */
 	write_reg(par, MIPI_DCS_EXIT_SLEEP_MODE);
-	msleep(150);
+	mdelay(150);
 
 	/* display on */
 	write_reg(par, MIPI_DCS_SET_DISPLAY_ON);
-	usleep_range(5000, 7000);
+	mdelay(50);
+
+	/* restore user spi-speed */
+        par->fbtftops.write = fbtft_write_spi;
+        udelay(100);
 
 	return 0;
 }
 
 static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
 {
+        /* slow down spi-speed for writing registers */
+	par->fbtftops.write = slow_write_spi;
+
+	fbtft_par_dbg(DEBUG_SET_ADDR_WIN, par,
+		"%s(xs=%d, ys=%d, xe=%d, ye=%d)\n", __func__, xs, ys, xe, ye);
+
 	write_reg(par, MIPI_DCS_SET_COLUMN_ADDRESS,
 		  xs >> 8, xs & 0xff,  /* XSTART */
@@ -151,5 +197,9 @@ static void set_addr_win(struct fbtft_par *par, int xs, int ys, int xe, int ye)
 
 	write_reg(par, MIPI_DCS_WRITE_MEMORY_START);
+
+	/* restore user spi-speed */
+        par->fbtftops.write = fbtft_write_spi;
+        //udelay(100);
 }
 
 #define HX8357D_MADCTL_MY  0x80
@@ -164,15 +214,17 @@ static int set_var(struct fbtft_par *par)
 {
 	u8 val;
 
+	fbtft_par_dbg(DEBUG_INIT_DISPLAY, par, "%s()\n", __func__);
+
 	switch (par->info->var.rotate) {
 	case 270:
-		val = HX8357D_MADCTL_MV | HX8357D_MADCTL_MX;
+		val = HX8357D_MADCTL_MV | HX8357D_MADCTL_MY;
 		break;
 	case 180:
 		val = 0;
 		break;
 	case 90:
-		val = HX8357D_MADCTL_MV | HX8357D_MADCTL_MY;
+		val = HX8357D_MADCTL_MV | HX8357D_MADCTL_MX;
 		break;
 	default:
 		val = HX8357D_MADCTL_MX | HX8357D_MADCTL_MY;
@@ -199,7 +251,6 @@ static struct fbtft_display display = {
 		.set_var = set_var,
 	},
 };
-
 FBTFT_REGISTER_DRIVER(DRVNAME, "himax,hx8357d", &display);
 
 MODULE_ALIAS("spi:" DRVNAME);
diff --git a/drivers/staging/fbtft/fb_hx8357d.h b/drivers/staging/fbtft/fb_hx8357d.h
index de05e8cdf04c..1c868457bf05 100644
--- a/drivers/staging/fbtft/fb_hx8357d.h
+++ b/drivers/staging/fbtft/fb_hx8357d.h
@@ -89,14 +89,14 @@
 #define HX8357B_SETGAMMA 0xC8
 #define HX8357B_SETPANELRELATED  0xE9
 
-/* Color definitions */
+// Color definitions
 #define	HX8357_BLACK   0x0000
 #define	HX8357_BLUE    0x001F
 #define	HX8357_RED     0xF800
 #define	HX8357_GREEN   0x07E0
 #define HX8357_CYAN    0x07FF
 #define HX8357_MAGENTA 0xF81F
-#define HX8357_YELLOW  0xFFE0
+#define HX8357_YELLOW  0xFFE0
 #define HX8357_WHITE   0xFFFF
 
 #endif /* __HX8357_H__ */
diff --git a/drivers/video/4d-hats/24-hat.dts b/drivers/video/4d-hats/24-hat.dts
new file mode 100644
index 000000000000..e88b934ec845
--- /dev/null
+++ b/drivers/video/4d-hats/24-hat.dts
@@ -0,0 +1,80 @@
+/*
+ * Device Tree overlay for 24-HAT by 4D Systems
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+	fragment@0 {
+		target = <&spi0>;
+		__overlay__ {
+                        compatible = "brcm,bcm2708-spi-dma";
+			status = "okay";
+
+			spidev@0{
+				status = "disabled";
+			};
+		};
+	};
+
+        fragment@1 {
+		target = <&spi0>;
+		__overlay__ {
+			/* needed to avoid dtc warning */
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rpidisplay: rpi-display@0{
+                                compatible = "4dsystems,24-hat";
+				reg = <0>;
+
+
+                                spi-max-frequency = <48000000>;
+                                /*
+                                rotate = <0>;
+                                rotate-codes = /bits/ 8 <0x03 0x05 0x00 0x06>;
+                                */
+                        };
+		};
+	};
+
+        fragment@2 {
+                target = <&i2c1>;
+                __overlay__ {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        status = "okay";
+
+                        ar1020@4d {
+                                compatible = "microchip,ar10204d";
+                                reg = <0x4d>;
+                                status = "okay";
+                        };
+                };
+        };
+
+        fragment@3 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "4dsystems,dma-pwm";
+
+                                4d,pwmbl-gpio = /bits/ 16 <22>;
+                                4d,pwmbl-type = /bits/ 16 <2>;
+                                4d,pwmbl-brightness = /bits/ 16 <100>;
+                                4d,pwmbl-title = "24-hat-pwm";
+                        };
+                };
+        };
+
+
+/*        __overrides__ {
+                speed =   <&rpidisplay>,"spi-max-frequency:0";
+                rotate =  <&rpidisplay>,"rotate:0";
+        };
+*/
+};
diff --git a/drivers/video/4d-hats/32-hat.dts b/drivers/video/4d-hats/32-hat.dts
new file mode 100644
index 000000000000..d935748a65d7
--- /dev/null
+++ b/drivers/video/4d-hats/32-hat.dts
@@ -0,0 +1,80 @@
+/*
+ * Device Tree overlay for 32-HAT by 4D Systems
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+	fragment@0 {
+		target = <&spi0>;
+		__overlay__ {
+                        compatible = "brcm,bcm2708-spi-dma";
+			status = "okay";
+
+			spidev@0{
+				status = "disabled";
+			};
+		};
+	};
+
+        fragment@1 {
+		target = <&spi0>;
+		__overlay__ {
+			/* needed to avoid dtc warning */
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rpidisplay: rpi-display@0{
+                                compatible = "4dsystems,32-hat";
+				reg = <0>;
+
+
+                                spi-max-frequency = <48000000>;
+                                /*
+                                rotate = <0>;
+                                rotate-codes = /bits/ 8 <0x03 0x05 0x00 0x06>;
+                                */
+                        };
+		};
+	};
+
+        fragment@2 {
+                target = <&i2c1>;
+                __overlay__ {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        status = "okay";
+
+                        ar1020@4d {
+                                compatible = "microchip,ar10204d";
+                                reg = <0x4d>;
+                                status = "okay";
+                        };
+                };
+        };
+
+        fragment@3 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "4dsystems,dma-pwm";
+
+                                4d,pwmbl-gpio = /bits/ 16 <18>;
+                                4d,pwmbl-type = /bits/ 16 <2>;
+                                4d,pwmbl-brightness = /bits/ 16 <100>;
+                                4d,pwmbl-title = "32-hat-pwm";
+                        };
+                };
+        };
+
+
+/*        __overrides__ {
+                speed =   <&rpidisplay>,"spi-max-frequency:0";
+                rotate =  <&rpidisplay>,"rotate:0";
+        };
+*/
+};
diff --git a/drivers/video/4d-hats/35-hat.dts b/drivers/video/4d-hats/35-hat.dts
new file mode 100644
index 000000000000..42d96ad5d7ac
--- /dev/null
+++ b/drivers/video/4d-hats/35-hat.dts
@@ -0,0 +1,80 @@
+/*
+ * Device Tree overlay for 35-HAT by 4D Systems
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+	fragment@0 {
+		target = <&spi0>;
+		__overlay__ {
+                        compatible = "brcm,bcm2708-spi-dma";
+			status = "okay";
+
+			spidev@0{
+				status = "disabled";
+			};
+		};
+	};
+
+        fragment@1 {
+		target = <&spi0>;
+		__overlay__ {
+			/* needed to avoid dtc warning */
+			#address-cells = <1>;
+                        #si24-HATze-cells = <0>;
+
+			rpidisplay: rpi-display@0{
+                                compatible = "4dsystems,35-hat";
+				reg = <0>;
+
+
+                                spi-max-frequency = <48000000>;
+                                /*
+                                rotate = <0>;
+                                rotate-codes = /bits/ 8 <0x03 0x05 0x00 0x06>;
+                                */
+                        };
+		};
+	};
+
+        fragment@2 {
+                target = <&i2c1>;
+                __overlay__ {
+                        #address-cells = <1>;
+                        #size-cells = <0>;
+                        status = "okay";
+
+                        ar1020@4d {
+                                compatible = "microchip,ar10204d";
+                                reg = <0x4d>;
+                                status = "okay";
+                        };
+                };
+        };
+
+        fragment@3 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "4dsystems,dma-pwm";
+
+                                4d,pwmbl-gpio = /bits/ 16 <18>;
+                                4d,pwmbl-type = /bits/ 16 <2>;
+                                4d,pwmbl-brightness = /bits/ 16 <100>;
+                                4d,pwmbl-title = "35-hat-pwm";
+                        };
+                };
+        };
+
+
+/*        __overrides__ {
+                speed =   <&rpidisplay>,"spi-max-frequency:0";
+                rotate =  <&rpidisplay>,"rotate:0";
+        };
+*/
+};
diff --git a/drivers/video/4d-hats/4d-hats.c b/drivers/video/4d-hats/4d-hats.c
new file mode 100644
index 000000000000..eb82afa61da4
--- /dev/null
+++ b/drivers/video/4d-hats/4d-hats.c
@@ -0,0 +1,1447 @@
+/*
+ * Framebuffer for 4D Systems displays
+ * ili9481 and hx8357 drivers are supported
+ * Copyright (c) 2015 Andrej Strancar
+ *
+ * Original: Copyright (c) 2009 Jean-Christian de Rivaz
+ *
+ * SPI mods, console support, 320x240 instead of 240x320:
+ * Copyright (c) 2012 Jeroen Domburg <jeroen@spritesmods.com>
+ *
+ * Bits and pieces borrowed from the fsl-lcdpi.c:
+ * Copyright (C) 2010-2011 Freescale Semiconductor, Inc. All Rights Reserved.
+ * Author: Alison Wang <b18965@freescale.com>
+ *         Jason Jin <Jason.jin@freescale.com>
+ *
+ * This file is subject to the terms and conditions of the GNU General Public
+ * License.  See the file "COPYING" in the main directory of this archive
+ * for more details.
+ *
+ */
+
+//#define DEBUG
+
+//#define CONFIG_FB_BACKLIGHT
+
+#include <linux/kernel.h>
+#include <linux/device.h>
+#include <linux/module.h>
+#include <linux/moduleparam.h>
+#include <linux/platform_device.h>
+#include <linux/of_device.h>
+#include <linux/mm.h>
+#include <linux/vmalloc.h>
+#include <linux/fb.h>
+#include <asm/io.h>
+#include <linux/spi/spi.h>
+#include <linux/pinctrl/consumer.h>
+#include <linux/backlight.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/version.h>
+#include <linux/ioctl.h>
+#include <asm/uaccess.h>
+
+#include <linux/clk.h>
+#include <linux/time.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+
+#include <mach/platform.h>
+
+/* ILI9341 commands */
+#define ILI9341_READ_DISPLAY_PIXEL_FORMAT 0x0C
+#define ILI9341_SLEEP_OUT 0x11
+#define ILI9341_GAMMA_SET 0x26
+#define ILI9341_DISPLAY_OFF 0x28
+#define ILI9341_DISPLAY_ON 0x29
+#define ILI9341_SET_COLUMN_ADDRESS 0x2A
+#define ILI9341_SET_PAGE_ADDRESS 0x2B
+#define ILI9341_WRITE_MEMORY 0x2C
+#define ILI9341_READ_MEMORY 0x2E
+#define ILI9341_MEMORY_ACCESS_CONTROL 0x36
+#define ILI9341_WRITE_MEMORY_CONTINUE 0x3C
+#define ILI9341_READ_MEMORY_CONTINUE 0x3E
+#define ILI9341_PIXEL_FORMAT_SET 0x3A
+#define ILI9341_FRAME_RATE_CONTROL 0xB1
+#define ILI9341_DISPLAY_FUNCTION_CONTROL 0xB6
+#define ILI9341_POWER_CONTROL_1 0xC0
+#define ILI9341_POWER_CONTROL_2 0xC1
+#define ILI9341_VCOM_CONTROL_1 0xC5
+#define ILI9341_VCOM_CONTROL_2 0xC7
+#define ILI9341_POWER_CONTROL_A 0xCB
+#define ILI9341_POWER_CONTROL_B 0xCF
+#define ILI9341_POSITIVE_GAMMA_CORRECTION 0xE0
+#define ILI9341_NEGATIVE_GAMMA_CORRECTION 0xE1
+#define ILI9341_DRIVER_TIMING_CONTROL_A 0xE8
+#define ILI9341_DRIVER_TIMING_CONTROL_B 0xEA
+#define ILI9341_POWER_ON_SEQUENCE_CONTROL 0xED
+#define ILI9341_UNDOCUMENTED_0xEF 0xEF
+#define ILI9341_ENABLE_3G 0xF2
+#define ILI9341_INTERFACE_CONTROL 0xF6
+#define ILI9341_DPUMP_RATIO_CONTROL 0xF7
+
+/* HX8357 commands */
+#define HX8357_EXIT_SLEEP_MODE          0x11
+#define HX8357_SET_DISPLAY_OFF          0x28
+#define HX8357_SET_DISPLAY_ON           0x29
+#define HX8357_SET_COLUMN_ADDRESS       0x2a
+#define HX8357_SET_PAGE_ADDRESS         0x2b
+#define HX8357_WRITE_MEMORY_START       0x2c
+#define HX8357_READ_MEMORY_START        0x2e
+#define HX8357_SET_TEAR_ON              0x35
+#define HX8357_SET_ADDRESS_MODE         0x36
+#define HX8357_SET_PIXEL_FORMAT         0x3a
+#define HX8357_WRITE_MEMORY_CONTINUE    0x3c
+#define HX8357_READ_MEMORY_CONTINUE     0x3e
+#define HX8357_SET_INTERNAL_OSCILLATOR   0xB0
+#define HX8357_SET_POWER_CONTROL         0xB1
+#define HX8357_SET_DISPLAY_MODE          0xb4
+#define HX8357_SET_VCOM_VOLTAGE         0xB6
+#define HX8357_ENABLE_EXTENSION_COMMAND 0xB9
+#define HX8357_SET_PANEL_DRIVING        0xc0    // not documented!
+#define HX8357_SET_PANEL_CHARACTERISTIC  0xCC
+#define HX8357_SET_GAMMA_CURVE           0xe0
+
+
+enum lcdpi_model { HAT35 = 0xab, HAT32, HAT24 };
+
+struct lcdpi_page {
+    unsigned short x;
+    unsigned short y;
+    unsigned short *buffer;
+    unsigned short len;
+    int must_update;
+};
+
+struct lcdpi {
+    struct device *dev;
+    spinlock_t spi_lock;
+    struct spi_device *spidev;
+    struct fb_info *info;
+    unsigned int pages_count;
+    struct lcdpi_page *pages;
+    unsigned long pseudo_palette[17];
+    int backlight;
+    int brightness;
+    int update_brightness;
+};
+
+struct spiblock_dma {
+    u8 *buf;
+    dma_addr_t dma;
+    size_t len;
+};
+
+/* touchscreen parameters */
+static u16 touchscreens[][4] = {
+    {0x07, 0x01, 0x04, 0x02}, // 24-HAT
+    {0x04, 0x02, 0x07, 0x01}, // 32-HAT
+    {0x07, 0x01, 0x04, 0x02}, // 35-HAT
+};
+
+/* touchscreen parameters form DT */
+static u8 rotate_codes[4] = {0xff, 0xff, 0xff, 0xff };
+
+/* module parameters */
+static int rotate = 360;
+module_param(rotate, int, 0444);
+MODULE_PARM_DESC(rotate, "Screen rotation: 0/90/180/270");
+
+static int compress = 1;
+module_param(compress, int, 0444);
+MODULE_PARM_DESC(compress, "SPI compresion 1/0");
+
+static ushort product_code = 0;
+module_param(product_code, ushort, 0444);
+MODULE_PARM_DESC(product_code, "Force product code");
+
+static ulong sclk = 48000000;
+module_param(sclk, ulong, 0444);
+MODULE_PARM_DESC(sclk, "SPI clock frequency");
+
+static ulong frames = 0;
+module_param(frames, ulong, 0444);
+MODULE_PARM_DESC(frames, "Count of drawn frames");
+
+/* exports */
+u16 lcdpi_touchparams;
+EXPORT_SYMBOL(lcdpi_touchparams);
+
+/* horizontal and vertical resolution */
+static u16 HDP=320;
+static u16 VDP=240;
+
+/* LCD width and height, depend on rotation! */
+static u16 width;
+static u16 height;
+
+/* ILI9341 init sequences for 24-HAT */
+static u8 ili9341_24_seq_interface[] =         { ILI9341_INTERFACE_CONTROL,
+                                              0x01, 0x01, 0x00, };
+static u8 ili9341_24_seq_power_b[] =           { ILI9341_POWER_CONTROL_B,
+                                              0x00, 0xC1, 0x30, };
+static u8 ili9341_24_seq_power_on[] =          { ILI9341_POWER_ON_SEQUENCE_CONTROL,
+                                              0x64, 0x03, 0x12, 0x81, };
+static u8 ili9341_24_seq_power_a[] =           { ILI9341_POWER_CONTROL_A,
+                                              0x39, 0x2C, 0x00, 0x34, 0x02, };
+static u8 ili9341_24_seq_timing_b[] =          { ILI9341_DRIVER_TIMING_CONTROL_B,
+                                              0x00, 0x00, };
+static u8 ili9341_24_seq_timing_a[] =          { ILI9341_DRIVER_TIMING_CONTROL_A,
+                                              0x85, 0x00, 0x7A, };
+static u8 ili9341_24_seq_power1[] =            { ILI9341_POWER_CONTROL_1,
+                                              0x26, };
+static u8 ili9341_24_seq_power2[] =            { ILI9341_POWER_CONTROL_2,
+                                              0x11, };
+static u8 ili9341_24_seq_vcom1[] =             { ILI9341_VCOM_CONTROL_1,
+                                              0x39, 0x37, };
+static u8 ili9341_24_seq_vcom2[] =             { ILI9341_VCOM_CONTROL_2,
+                                              0xA6, };
+static u8 ili9341_24_seq_pixel_format[] =      { ILI9341_PIXEL_FORMAT_SET,
+                                              0x55, };
+static u8 ili9341_24_seq_memory_access[] =     { ILI9341_MEMORY_ACCESS_CONTROL,
+                                              0x08, };
+static u8 ili9341_24_seq_frame_rate[] =        { ILI9341_FRAME_RATE_CONTROL,
+                                              0x00, 0x1B, };
+static u8 ili9341_24_seq_display_function[] =  { ILI9341_DISPLAY_FUNCTION_CONTROL,
+                                              0x0A, 0xA2, };
+static u8 ili9341_24_seq_enable_3g[] =         { ILI9341_ENABLE_3G,
+                                              0x00, };
+static u8 ili9341_24_seq_gama_set[] =          { ILI9341_GAMMA_SET,
+                                              0x01, };
+/*
+static u8 ili9341_24_seq_positive_gama[] =     { ILI9341_POSITIVE_GAMMA_CORRECTION,
+                                               0x0f, 0x2D, 0x0E, 0x08, 0x12, 0x0A, 0x3D, 0x95, 0x31, 0x04, 0x10, 0x09, 0x09, 0x0D, 0x00, };
+static u8 ili9341_24_seq_negative_gama[] =     { ILI9341_NEGATIVE_GAMMA_CORRECTION,
+                                               0x00, 0x12, 0x17, 0x03, 0x0d, 0x05, 0x2c, 0x44, 0x41, 0x05, 0x0F, 0x0a, 0x30, 0x32, 0x0F, };
+*/
+static u8 ili9341_24_seq_write_memory[] =      { ILI9341_WRITE_MEMORY, };
+static u8 ili9341_24_seq_sleep_out[] =         { ILI9341_SLEEP_OUT, 0x06};
+static u8 ili9341_24_seq_display_on[] =        { ILI9341_DISPLAY_ON };
+static u8 ili9341_24_seq_pump_ratio[] =        { ILI9341_DPUMP_RATIO_CONTROL,
+                                              0x20};
+
+
+/* ILI9341 init sequences for 32-HAT */
+static u8 ili9341_32_seq_interface[] =      { ILI9341_INTERFACE_CONTROL,
+                                              0x01, 0x01, 0x00, };
+static u8 ili9341_32_seq_undocumented[] =   { ILI9341_UNDOCUMENTED_0xEF,
+                                              0x03, 0x80, 0x02, };
+static u8 ili9341_32_seq_power_b[] =        { ILI9341_POWER_CONTROL_B,
+                                              0x00, 0xF2, 0xA0, };
+static u8 ili9341_32_seq_power_on[] =       { ILI9341_POWER_ON_SEQUENCE_CONTROL,
+                                              0x64, 0x03, 0x12, 0x81, };
+static u8 ili9341_32_seq_power_a[] =        { ILI9341_POWER_CONTROL_A,
+                                              0x39, 0x2C, 0x00, 0x34, 0x02, };
+static u8 ili9341_32_seq_timing_b[] =       { ILI9341_DRIVER_TIMING_CONTROL_B,
+                                              0x00, 0x00, };
+static u8 ili9341_32_seq_timing_a[] =       { ILI9341_DRIVER_TIMING_CONTROL_A,
+                                              0x85, 0x10, 0x7A, };
+static u8 ili9341_32_seq_power1[] =         { ILI9341_POWER_CONTROL_1,
+                                              0x21, };
+static u8 ili9341_32_seq_power2[] =         { ILI9341_POWER_CONTROL_2,
+                                              0x11, };
+static u8 ili9341_32_seq_vcom1[] =          { ILI9341_VCOM_CONTROL_1,
+                                              0x3F, 0x3C, };
+static u8 ili9341_32_seq_vcom2[] =          { ILI9341_VCOM_CONTROL_2,
+                                              0xC6, };
+static u8 ili9341_32_seq_pixel_format[] =   { ILI9341_PIXEL_FORMAT_SET,
+                                              0x55, };
+static u8 ili9341_32_seq_memory_access[] =  { ILI9341_MEMORY_ACCESS_CONTROL,
+                                              0xA8, };
+static u8 ili9341_32_seq_frame_rate[] =     { ILI9341_FRAME_RATE_CONTROL,
+                                              0x00, 0x1B, };
+static u8 ili9341_32_seq_display_function[] = { ILI9341_DISPLAY_FUNCTION_CONTROL,
+                                                0x0A, 0xA2, };
+static u8 ili9341_32_seq_enable_3g[] =      { ILI9341_ENABLE_3G,
+                                              0x00, };
+static u8 ili9341_32_seq_gama_set[] =       { ILI9341_GAMMA_SET,
+                                              0x01, };
+static u8 ili9341_32_seq_positive_gama[] =  { ILI9341_POSITIVE_GAMMA_CORRECTION,
+                                              0x0f, 0x24, 0x21, 0x0F, 0x13, 0x0A, 0x52, 0xC9, 0x3B, 0x05, 0x00, 0x00,
+                                              0x00, 0x00, 0x00, };
+static u8 ili9341_32_seq_negative_gama[] =  { ILI9341_NEGATIVE_GAMMA_CORRECTION,
+                                              0x00, 0x1B, 0x1E, 0x00, 0x0C, 0x04, 0x2F, 0x36, 0x44, 0x0a, 0x1F, 0x0F,
+                                              0x3F, 0x3F, 0x0F, };
+static u8 ili9341_32_seq_write_memory[] =   { ILI9341_WRITE_MEMORY, };
+static u8 ili9341_32_seq_sleep_out[] =      { ILI9341_SLEEP_OUT, };
+static u8 ili9341_32_seq_display_on[] =     { ILI9341_DISPLAY_ON };
+
+
+/* HX8357 init sequences for 35-HAT */
+static u8 hx8357_seq_exit_sleep[] =         { HX8357_EXIT_SLEEP_MODE, };
+static u8 hx8357_seq_enable_extension_command[] = { HX8357_ENABLE_EXTENSION_COMMAND,
+                                                    0xFF, 0x83, 0x57, };
+static u8 hx8357_seq_set_power_control[] =  { HX8357_SET_POWER_CONTROL, 0x00,
+                                              0x12, 0x12, 0x12, 0xC3, 0x44, };
+static u8 hx8357_seq_set_display_mode[] =   { HX8357_SET_DISPLAY_MODE, 0x02, 0x40,
+                                              0x00, 0x2A, 0x2A, 0x20, 0x91, };
+static u8 hx8357_seq_set_vcom_voltage[] =   { HX8357_SET_VCOM_VOLTAGE, 0x38, };
+static u8 hx8357_seq_set_internal_oscillator[] = { HX8357_SET_INTERNAL_OSCILLATOR,
+                                                   0x68, 0xE3, 0x2F, 0x1F, 0xB5, 0x01, 0x01, 0x67, };
+static u8 hx8357_seq_set_panel_driving[] =  { HX8357_SET_PANEL_DRIVING, 0x70,
+                                              0x70, 0x01, 0x3C, 0xC8, 0x08, };
+static u8 hx8357_seq_c2[] =                 { 0xC2,
+                                              0x00, 0x08, 0x04, };
+static u8 hx8357_seq_set_panel_characteristic[] = { HX8357_SET_PANEL_CHARACTERISTIC,
+                                                    0x09, };
+static u8 hx8357_seq_set_gama_curve[] =     { HX8357_SET_GAMMA_CURVE,
+                                              0x01, 0x02, 0x03, 0x05, 0x0E, 0x22, 0x32, 0x3B, 0x5C, 0x54, 0x4C, 0x41, 0x3D, 0x37,
+                                              0x31, 0x21, 0x01, 0x02, 0x03, 0x05, 0x0E, 0x22, 0x32, 0x3B, 0x5C, 0x54,
+                                              0x4C, 0x41, 0x3D, 0x37, 0x31, 0x21, 0x00, 0x01, };
+static u8 hx8357_seq_set_pixel_format[] =   { HX8357_SET_PIXEL_FORMAT,
+                                              0x55, };
+static u8 hx8357_seq_set_address_mode[] =   { HX8357_SET_ADDRESS_MODE,
+                                              0x00, };
+static u8 hx8357_seq_set_tear_on[] =        { HX8357_SET_TEAR_ON,
+                                              0x00, };
+static u8 hx8357_seq_set_display_on[] =     { HX8357_SET_DISPLAY_ON,
+                                            };
+static u8 hx8357_seq_write_memory_start[] = { HX8357_WRITE_MEMORY_START };
+
+
+/* ioctl for reading tactile switches */
+#define QUERY_GET_KEYS _IOR('K', 1, unsigned char *)
+
+/* ioctl to force LCD module initialization */
+#define QUERY_INIT _IOR('I', 1, unsigned char *)
+
+/* ioctl for reading tactile product code */
+#define QUERY_GET_PRODUCT_CODE _IOR('P', 1, unsigned char *)
+
+static int lcdpi_spi_write(struct lcdpi *item, unsigned short value,
+                           unsigned int isdata);
+
+static int lcdpi_backlight_update_status(struct backlight_device *bd) {
+    struct lcdpi *item = bl_get_data(bd);
+
+    if(bd->props.fb_blank == 0)
+        item->brightness = bd->props.brightness;
+    else
+        item->brightness = 0;
+
+    item->update_brightness = 1;
+    item->pages[0].must_update=1;
+    schedule_delayed_work(&item->info->deferred_work, HZ / 20);
+
+    return 0;
+}
+
+static int lcdpi_backlight_get_brightness(struct backlight_device *bd)
+{
+    return bd->props.brightness;
+}
+
+static void lcdpi_unregister_backlight(struct lcdpi *item)
+{
+    const struct backlight_ops *bl_ops;
+
+    if (item->info->bl_dev) {
+        item->info->bl_dev->props.power = FB_BLANK_POWERDOWN;
+        backlight_update_status(item->info->bl_dev);
+        bl_ops = item->info->bl_dev->ops;
+        backlight_device_unregister(item->info->bl_dev);
+        item->info->bl_dev = NULL;
+        kfree(bl_ops);
+    }
+}
+
+static void lcdpi_register_backlight(struct lcdpi *item) {
+    struct backlight_device *bd;
+    struct backlight_properties bl_props = {0, 1, };
+    struct backlight_ops *bl_ops;
+
+    bl_ops = kzalloc(sizeof(struct backlight_ops), GFP_KERNEL);
+    if (!bl_ops) {
+        dev_err(item->info->device,
+                "%s: could not allocate memeory for backlight operations.\n",
+                __func__);
+        return;
+    }
+
+    bl_ops->get_brightness = lcdpi_backlight_get_brightness;
+    bl_ops->update_status = lcdpi_backlight_update_status;
+    bl_props.type = BACKLIGHT_RAW;
+    /* Assume backlight is off, get polarity from current state of pin */
+    bl_props.power = FB_BLANK_POWERDOWN;
+
+    bd = backlight_device_register(dev_driver_string(item->info->device),
+                                   item->info->device, item, bl_ops, &bl_props);
+
+    if (IS_ERR(bd)) {
+        dev_err(item->info->device, "cannot register backlight device (%ld)\n",
+                PTR_ERR(bd));
+        goto failed;
+    }
+    item->info->bl_dev = bd;
+
+    item->info->bl_dev->props.brightness = 1;
+    return;
+
+failed: kfree(bl_ops);
+}
+
+
+static struct spi_device *lcdpi_spi_device;
+static struct lcdpi *lcdpi_item;
+static void ili9341_24_setup(struct lcdpi *item);
+static void ili9341_32_setup(struct lcdpi *item);
+static void hx8357_35_setup(struct lcdpi *item);
+static void lcdpi_update_all(struct lcdpi *item);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35))
+static int ssd1289_ioctl(struct inode *i, struct file *f, unsigned int cmd, unsigned long arg)
+#else
+static int lcdpi_ioctl(struct fb_info *info, unsigned int cmd, unsigned long arg)
+#endif
+{
+    unsigned char keys;
+
+    switch (cmd)
+    {
+    case QUERY_GET_KEYS:
+        lcdpi_spi_device->max_speed_hz=1000000;
+        lcdpi_spi_device->master->setup(lcdpi_spi_device);
+        spi_read(lcdpi_spi_device, &keys, sizeof(unsigned char));
+        lcdpi_spi_device->max_speed_hz=sclk;
+        lcdpi_spi_device->master->setup(lcdpi_spi_device);
+        keys = (keys >> 3) & 0x1f;
+        if (copy_to_user((unsigned char *)arg, &keys, sizeof(unsigned char)))
+        {
+            return -EACCES;
+        }
+        break;
+
+    case QUERY_GET_PRODUCT_CODE:
+        if (copy_to_user((unsigned char *)arg, &product_code, sizeof(unsigned char)))
+        {
+            return -EACCES;
+        }
+        break;
+
+    case QUERY_INIT:
+        switch(product_code) {
+        case HAT24:
+            ili9341_24_setup(lcdpi_item);
+            break;
+        case HAT32:
+            ili9341_32_setup(lcdpi_item);
+            break;
+        case HAT35:
+            hx8357_35_setup(lcdpi_item);
+            break;
+        }
+        lcdpi_update_all(lcdpi_item);
+        break;
+
+    default:
+        return -EINVAL;
+    }
+
+    return 0;
+}
+
+
+#define BLOCKLEN (HDP * VDP * 2 + 10)
+static u8 *lcdpi_spiblock;
+
+#define MAX_DMA_PIXELS 32767
+static struct spiblock_dma lcdpi_spiblock_dma;
+
+static int write_spi_dma(struct lcdpi *item, size_t len)
+{
+    struct spi_transfer t = {
+        .tx_buf = lcdpi_spiblock_dma.buf,
+                .len = len,
+    };
+    struct spi_message m;
+
+    spi_message_init(&m);
+    t.tx_dma = lcdpi_spiblock_dma.dma;
+    m.is_dma_mapped = 1;
+    spi_message_add_tail(&t, &m);
+    return spi_sync(item->spidev, &m);
+}
+
+/*
+This routine will write a single 16-bit value, either as data or as a command
+(depends on isdata). The LCD will clock this in because the SPIs /CS goes high.
+*/
+
+/*
+ * bits in control byte
+ */
+#define LCDPI_LONG (1<<7)
+#define LCDPI_BLOCK (1<<6)
+#define LCDPI_RESET (1<<5)
+#define LCDPI_RS (1<<4)
+#define LCDPI_BL (1<<3)
+#define LCDPI_RD (1<<2)
+
+static int lcdpi_spi_write(struct lcdpi *item, unsigned short value,
+                           unsigned int isdata)
+{
+
+    item->backlight = item->info->bl_dev->props.brightness;
+
+    /*
+     * control byte
+     */
+    lcdpi_spiblock[0]=((isdata?LCDPI_RS:0)|(item->backlight?LCDPI_BL:0))|LCDPI_RESET|LCDPI_RD;
+    /*
+     * 16-bit data / command
+     */
+    lcdpi_spiblock[1]=(value>>8)&0xff;
+    lcdpi_spiblock[2]=(value)&0xff;
+
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    return 0;
+}
+
+static inline void lcdpi_reg_set(struct lcdpi *item, unsigned char reg,
+                                 unsigned short value)
+{
+    lcdpi_spi_write(item, reg&0xff, 0);
+    lcdpi_spi_write(item, value, 1);
+}
+
+static inline void lcdpi_spi_write_array(struct lcdpi *item,
+                                         u8 *value, u8 len)
+{
+    u8 i;
+
+    lcdpi_spi_write(item, value[0]&0xff, 0);
+    for(i=1; i < len; i++)
+        lcdpi_spi_write(item, value[i], 1);
+}
+
+static void lcdpi_update_all(struct lcdpi *item)
+{
+    unsigned short i;
+    struct fb_deferred_io *fbdefio = item->info->fbdefio;
+    for (i = 0; i < item->pages_count; i++) {
+        item->pages[i].must_update=1;
+    }
+    schedule_delayed_work(&item->info->deferred_work, fbdefio->delay);
+}
+
+extern void obj_update_compress(struct fb_info *info, struct list_head *pagelist, struct spiblock_dma *lcdpi_spiblock_dma,
+                           ulong sclk, int compress, u16 width, u16 height, ulong *frames);
+
+static void lcdpi_update_compress(struct fb_info *info, struct list_head *pagelist)
+{
+    obj_update_compress(info, pagelist, &lcdpi_spiblock_dma, sclk, compress, width, height, &frames);
+}
+
+static void lcdpi_update(struct fb_info *info, struct list_head *pagelist)
+{
+    struct lcdpi *item = (struct lcdpi *)info->par;
+    struct page *page;
+    int i;
+    int x, lasti, ptr;
+    unsigned short *buffer, value;
+
+    if(item->update_brightness == 1) {
+        /* nop */
+        lcdpi_spi_write(item, 0x00, 0);
+        mdelay(1);
+        item->update_brightness = 0;
+    }
+
+    /*
+     * We can be called because of pagefaults (mmap'ed framebuffer, pages
+     * returned in *pagelist) or because of kernel activity
+     * (pages[i]/must_update!=0). Add the former to the list of the latter.
+     */
+    list_for_each_entry(page, pagelist, lru) {
+        item->pages[page->index].must_update=1;
+    }
+
+    frames++;
+
+    /* Copy changed pages. */
+    lasti = -2;
+    ptr = 0;
+
+    for (i=0; i<item->pages_count; i++) {
+        /*
+         * ToDo: Small race here between checking and setting must_update,
+         * maybe lock?
+         */
+        if (item->pages[i].must_update) {
+            item->pages[i].must_update=0;
+
+            buffer = item->pages[i].buffer;
+
+            if(ptr >= MAX_DMA_PIXELS - item->pages[i].len) {
+                pr_debug("Transfering block of max=%d bytes\n", ptr*4);
+                lasti = -2;
+            }
+
+            if(i != lasti + 1) {
+                if(ptr) {
+                    write_spi_dma(item, ptr*2+2);
+                    ptr = 0;
+                    pr_debug("Transfering block of %d bytes\n", ptr*4);
+                }
+
+                lcdpi_spi_write(item, HX8357_SET_COLUMN_ADDRESS, 0);
+                lcdpi_spi_write(item, 0, 1);
+                lcdpi_spi_write(item, 0, 1);
+                lcdpi_spi_write(item, width >> 8, 1);
+                lcdpi_spi_write(item, width & 0x00ff, 1);
+                lcdpi_spi_write(item, HX8357_SET_PAGE_ADDRESS, 0);
+                lcdpi_spi_write(item, item->pages[i].y >> 8, 1);
+                lcdpi_spi_write(item, item->pages[i].y &0x0ff, 1);
+                lcdpi_spi_write(item, height >> 8, 1);
+                lcdpi_spi_write(item, height & 0x00ff, 1);
+                lcdpi_spi_write(item, HX8357_WRITE_MEMORY_START, 0);
+
+
+                /*
+                 * control byte for long data transfer. Any number of 16-bit data can follow.
+                 */
+                lcdpi_spiblock_dma.buf[0]=LCDPI_RS|(item->backlight?LCDPI_BL:0)|LCDPI_RESET|LCDPI_RD|LCDPI_LONG;
+            }
+
+            if((ptr == 0) && (i != 0)) {
+                for (x=0; x<item->pages[i].x; x++) {
+                    value=item->pages[i - 1].buffer[item->pages[i - 1].len - item->pages[i].x + x];
+                    lcdpi_spiblock_dma.buf[(ptr*2)+1]=(value>>8)&0xff;
+                    lcdpi_spiblock_dma.buf[(ptr*2)+2]=(value)&0xff;
+                    ptr++;
+                }
+            }
+
+            for (x=0; x<item->pages[i].len; x++) {
+                value=buffer[x];
+                lcdpi_spiblock_dma.buf[(ptr*2)+1]=(value>>8)&0xff;
+                lcdpi_spiblock_dma.buf[(ptr*2)+2]=(value)&0xff;
+                ptr++;
+            }
+
+            lasti = i;
+            pr_debug("Added page %d, ptr=%d\n", i, ptr);
+        }
+    }
+
+    if(ptr) {
+        pr_debug("Transfering block of %d bytes [%2x, %2x, %2x, ...]\n", ptr*2+1, lcdpi_spiblock[0],
+                lcdpi_spiblock[1], lcdpi_spiblock[2]);
+
+        /*
+         * long transfer. Control byte + ptr of 16-bit data
+         */
+        write_spi_dma(item, ptr*2+2);
+        ptr = 0;
+    }
+
+}
+
+/* ILI9341 init for 24-HAT */
+static void ili9341_24_setup(struct lcdpi *item)
+{
+    dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *)item);
+
+    item->spidev->max_speed_hz=sclk/4;
+    item->spidev->mode=0;
+    item->spidev->master->setup(item->spidev);
+
+    lcdpi_spiblock[1]=0;
+    lcdpi_spiblock[2]=0;
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(100);
+    lcdpi_spiblock[0]=LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(100);
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(150);
+
+    lcdpi_spi_write_array(item, ili9341_24_seq_interface, ARRAY_SIZE(ili9341_24_seq_interface));
+    lcdpi_spi_write_array(item, ili9341_24_seq_power_b, ARRAY_SIZE(ili9341_24_seq_power_b));
+    lcdpi_spi_write_array(item, ili9341_24_seq_power_on, ARRAY_SIZE(ili9341_24_seq_power_on));
+    lcdpi_spi_write_array(item, ili9341_24_seq_timing_a, ARRAY_SIZE(ili9341_24_seq_timing_a));
+    lcdpi_spi_write_array(item, ili9341_24_seq_power_a, ARRAY_SIZE(ili9341_24_seq_power_a));
+    lcdpi_spi_write_array(item, ili9341_24_seq_pump_ratio, ARRAY_SIZE(ili9341_24_seq_pump_ratio));
+    lcdpi_spi_write_array(item, ili9341_24_seq_timing_b, ARRAY_SIZE(ili9341_24_seq_timing_b));
+    lcdpi_spi_write_array(item, ili9341_24_seq_power1, ARRAY_SIZE(ili9341_24_seq_power1));
+    lcdpi_spi_write_array(item, ili9341_24_seq_power2, ARRAY_SIZE(ili9341_24_seq_power2));
+    lcdpi_spi_write_array(item, ili9341_24_seq_vcom1, ARRAY_SIZE(ili9341_24_seq_vcom1));
+    lcdpi_spi_write_array(item, ili9341_24_seq_vcom2, ARRAY_SIZE(ili9341_24_seq_vcom2));
+    switch(rotate) {
+    case 90:
+        ili9341_24_seq_memory_access[1] = 0xC8;
+        break;
+
+    case 270:
+        ili9341_24_seq_memory_access[1] = 0x08;
+        break;
+
+    case 180:
+        ili9341_24_seq_memory_access[1] = 0x68;
+        break;
+
+    default:
+        ili9341_24_seq_memory_access[1] = 0xA8;
+        break;
+    }
+
+
+    lcdpi_spi_write_array(item, ili9341_24_seq_memory_access, ARRAY_SIZE(ili9341_24_seq_memory_access));
+    lcdpi_spi_write_array(item, ili9341_24_seq_display_function, ARRAY_SIZE(ili9341_24_seq_display_function));
+    lcdpi_spi_write_array(item, ili9341_24_seq_frame_rate, ARRAY_SIZE(ili9341_24_seq_frame_rate));
+    lcdpi_spi_write_array(item, ili9341_24_seq_enable_3g, ARRAY_SIZE(ili9341_24_seq_enable_3g));
+    lcdpi_spi_write_array(item, ili9341_24_seq_gama_set, ARRAY_SIZE(ili9341_24_seq_gama_set));
+    lcdpi_spi_write_array(item, ili9341_24_seq_pixel_format, ARRAY_SIZE(ili9341_24_seq_pixel_format));
+//    lcdpi_spi_write_array(item, ili9341_24_seq_positive_gama, ARRAY_SIZE(ili9341_24_seq_positive_gama));
+//    lcdpi_spi_write_array(item, ili9341_24_seq_negative_gama, ARRAY_SIZE(ili9341_24_seq_negative_gama));
+    lcdpi_spi_write_array(item, ili9341_32_seq_positive_gama, ARRAY_SIZE(ili9341_32_seq_positive_gama));
+    lcdpi_spi_write_array(item, ili9341_32_seq_negative_gama, ARRAY_SIZE(ili9341_32_seq_negative_gama));
+
+    lcdpi_spi_write_array(item, ili9341_24_seq_write_memory, ARRAY_SIZE(ili9341_24_seq_write_memory));
+    lcdpi_spi_write_array(item, ili9341_24_seq_sleep_out, ARRAY_SIZE(ili9341_24_seq_sleep_out));
+    msleep(120);
+    lcdpi_spi_write_array(item, ili9341_24_seq_display_on, ARRAY_SIZE(ili9341_24_seq_display_on));
+    usleep_range(5000, 7000);
+    lcdpi_spi_write(item, HX8357_WRITE_MEMORY_START, 0);
+
+    lcdpi_spiblock_dma.buf[0]=LCDPI_RS|LCDPI_BL|LCDPI_RESET|LCDPI_RD;
+
+    item->spidev->max_speed_hz=sclk;
+    item->spidev->mode=0;
+    item->spidev->master->setup(item->spidev);
+}
+
+
+/* ILI9341 init for 32-HAT*/
+static void ili9341_32_setup(struct lcdpi *item)
+{
+    lcdpi_spiblock[1]=0;
+    lcdpi_spiblock[2]=0;
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+    lcdpi_spiblock[0]=LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+
+    lcdpi_spi_write_array(item, ili9341_32_seq_interface, ARRAY_SIZE(ili9341_32_seq_interface));
+    lcdpi_spi_write_array(item, ili9341_32_seq_undocumented, ARRAY_SIZE(ili9341_32_seq_undocumented));
+    lcdpi_spi_write_array(item, ili9341_32_seq_power_b, ARRAY_SIZE(ili9341_32_seq_power_b));
+    lcdpi_spi_write_array(item, ili9341_32_seq_power_on, ARRAY_SIZE(ili9341_32_seq_power_on));
+    lcdpi_spi_write_array(item, ili9341_32_seq_power_a, ARRAY_SIZE(ili9341_32_seq_power_a));
+    lcdpi_spi_write_array(item, ili9341_32_seq_timing_b, ARRAY_SIZE(ili9341_32_seq_timing_b));
+    lcdpi_spi_write_array(item, ili9341_32_seq_timing_a, ARRAY_SIZE(ili9341_32_seq_timing_a));
+    lcdpi_spi_write_array(item, ili9341_32_seq_power1, ARRAY_SIZE(ili9341_32_seq_power1));
+    lcdpi_spi_write_array(item, ili9341_32_seq_power2, ARRAY_SIZE(ili9341_32_seq_power2));
+    lcdpi_spi_write_array(item, ili9341_32_seq_vcom1, ARRAY_SIZE(ili9341_32_seq_vcom1));
+    lcdpi_spi_write_array(item, ili9341_32_seq_vcom2, ARRAY_SIZE(ili9341_32_seq_vcom2));
+    lcdpi_spi_write_array(item, ili9341_32_seq_pixel_format, ARRAY_SIZE(ili9341_32_seq_pixel_format));
+
+    switch(rotate) {
+    case 90:
+        ili9341_32_seq_memory_access[1] = 0xC8;
+        break;
+
+    case 270:
+        ili9341_32_seq_memory_access[1] = 0x08;
+        break;
+
+    case 180:
+        ili9341_32_seq_memory_access[1] = 0x68;
+        break;
+
+    default:
+        ili9341_32_seq_memory_access[1] = 0xA8;
+        break;
+    }
+
+    lcdpi_spi_write_array(item, ili9341_32_seq_memory_access, ARRAY_SIZE(ili9341_32_seq_memory_access));
+    lcdpi_spi_write_array(item, ili9341_32_seq_frame_rate, ARRAY_SIZE(ili9341_32_seq_frame_rate));
+    lcdpi_spi_write_array(item, ili9341_32_seq_display_function, ARRAY_SIZE(ili9341_32_seq_display_function));
+    lcdpi_spi_write_array(item, ili9341_32_seq_enable_3g, ARRAY_SIZE(ili9341_32_seq_enable_3g));
+    lcdpi_spi_write_array(item, ili9341_32_seq_gama_set, ARRAY_SIZE(ili9341_32_seq_gama_set));
+    lcdpi_spi_write_array(item, ili9341_32_seq_positive_gama, ARRAY_SIZE(ili9341_32_seq_positive_gama));
+    lcdpi_spi_write_array(item, ili9341_32_seq_negative_gama, ARRAY_SIZE(ili9341_32_seq_negative_gama));
+    lcdpi_spi_write_array(item, ili9341_32_seq_write_memory, ARRAY_SIZE(ili9341_32_seq_write_memory));
+    lcdpi_spi_write_array(item, ili9341_32_seq_sleep_out, ARRAY_SIZE(ili9341_32_seq_sleep_out));
+    msleep(120);
+    lcdpi_spi_write_array(item, ili9341_32_seq_display_on, ARRAY_SIZE(ili9341_32_seq_display_on));
+    usleep_range(5000, 7000);
+    lcdpi_spi_write(item, HX8357_WRITE_MEMORY_START, 0);
+
+    lcdpi_spiblock_dma.buf[0]=LCDPI_RS|LCDPI_BL|LCDPI_RESET|LCDPI_RD;
+}
+
+/* HX8357 init for 35-HAT*/
+static void hx8357_35_setup(struct lcdpi *item)
+{
+    lcdpi_spiblock[1]=0;
+    lcdpi_spiblock[2]=0;
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+    lcdpi_spiblock[0]=LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+
+    lcdpi_spi_write_array(item, hx8357_seq_exit_sleep, ARRAY_SIZE(hx8357_seq_exit_sleep));
+    mdelay(150);
+    lcdpi_spi_write_array(item, hx8357_seq_enable_extension_command, ARRAY_SIZE(hx8357_seq_enable_extension_command));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_power_control, ARRAY_SIZE(hx8357_seq_set_power_control));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_display_mode, ARRAY_SIZE(hx8357_seq_set_display_mode));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_vcom_voltage, ARRAY_SIZE(hx8357_seq_set_vcom_voltage));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_internal_oscillator, ARRAY_SIZE(hx8357_seq_set_internal_oscillator));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_panel_driving, ARRAY_SIZE(hx8357_seq_set_panel_driving));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_c2, ARRAY_SIZE(hx8357_seq_c2));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_panel_characteristic, ARRAY_SIZE(hx8357_seq_set_panel_characteristic));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_gama_curve, ARRAY_SIZE(hx8357_seq_set_gama_curve));
+    mdelay(1);
+    lcdpi_spi_write_array(item, hx8357_seq_set_pixel_format, ARRAY_SIZE(hx8357_seq_set_pixel_format));
+
+    switch(rotate) {
+    case 90:
+        hx8357_seq_set_address_mode[1] = 0x00;
+        break;
+
+    case 270:
+        hx8357_seq_set_address_mode[1] = 0xC0;
+        break;
+
+    case 180:
+        hx8357_seq_set_address_mode[1] = 0xA0;
+        break;
+
+    default:
+        hx8357_seq_set_address_mode[1] = 0x60;
+        break;
+    }
+
+    lcdpi_spi_write_array(item, hx8357_seq_set_address_mode, ARRAY_SIZE(hx8357_seq_set_address_mode));
+    lcdpi_spi_write_array(item, hx8357_seq_set_tear_on, ARRAY_SIZE(hx8357_seq_set_tear_on));
+    mdelay(10);
+    lcdpi_spi_write_array(item, hx8357_seq_set_display_on, ARRAY_SIZE(hx8357_seq_set_display_on));
+    mdelay(10);
+    lcdpi_spi_write_array(item, hx8357_seq_write_memory_start, ARRAY_SIZE(hx8357_seq_write_memory_start));
+}
+
+/*
+ * This routine will allocate the buffer for the complete framebuffer. This
+ * is one continuous chunk of 16-bit pixel values; userspace programs
+ * will write here.
+ */
+static int __init lcdpi_video_alloc(struct lcdpi *item)
+{
+    unsigned int frame_size;
+
+    dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *)item);
+
+    frame_size = item->info->fix.line_length * item->info->var.yres;
+    dev_dbg(item->dev, "%s: item=0x%p frame_size=%u\n",
+            __func__, (void *)item, frame_size);
+
+    item->pages_count = frame_size / PAGE_SIZE;
+    if ((item->pages_count * PAGE_SIZE) < frame_size) {
+        item->pages_count++;
+    }
+    dev_dbg(item->dev, "%s: item=0x%p pages_count=%u\n",
+            __func__, (void *)item, item->pages_count);
+
+    item->info->fix.smem_len = item->pages_count * PAGE_SIZE;
+    item->info->fix.smem_start =
+            (unsigned long)vmalloc(item->info->fix.smem_len);
+    if (!item->info->fix.smem_start) {
+        dev_err(item->dev, "%s: unable to vmalloc\n", __func__);
+        return -ENOMEM;
+    }
+    memset((void *)item->info->fix.smem_start, 0, item->info->fix.smem_len);
+
+    return 0;
+}
+
+static void lcdpi_video_free(struct lcdpi *item)
+{
+    dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *)item);
+    vfree((void *)item->info->fix.smem_start);
+}
+
+/*
+ * This routine will allocate a lcdpi_page struct for each vm page in the
+ * main framebuffer memory. Each struct will contain a pointer to the page
+ * start, an x- and y-offset, and the length of the pagebuffer which is in the framebuffer.
+ */
+static int __init lcdpi_pages_alloc(struct lcdpi *item)
+{
+    unsigned short pixels_per_page;
+    unsigned short yoffset_per_page;
+    unsigned short xoffset_per_page;
+    unsigned short index;
+    unsigned short x = 0;
+    unsigned short y = 0;
+    unsigned short *buffer;
+    unsigned int len;
+
+    dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *)item);
+
+    item->pages = kmalloc(item->pages_count * sizeof(struct lcdpi_page),
+                          GFP_KERNEL);
+    if (!item->pages) {
+        dev_err(item->dev, "%s: unable to kmalloc for lcdpi_page\n",
+                __func__);
+        return -ENOMEM;
+    }
+
+    pixels_per_page = PAGE_SIZE / (item->info->var.bits_per_pixel / 8);
+    yoffset_per_page = pixels_per_page / item->info->var.xres;
+    xoffset_per_page = pixels_per_page -
+            (yoffset_per_page * item->info->var.xres);
+    dev_dbg(item->dev, "%s: item=0x%p pixels_per_page=%hu "
+                       "yoffset_per_page=%hu xoffset_per_page=%hu\n",
+            __func__, (void *)item, pixels_per_page,
+            yoffset_per_page, xoffset_per_page);
+
+    buffer = (unsigned short *)item->info->fix.smem_start;
+    for (index = 0; index < item->pages_count; index++) {
+        len = (item->info->var.xres * item->info->var.yres) -
+                (index * pixels_per_page);
+        if (len > pixels_per_page) {
+            len = pixels_per_page;
+        }
+        dev_dbg(item->dev,
+                "%s: page[%d]: x=%3hu y=%3hu buffer=0x%p len=%3hu\n",
+                __func__, index, x, y, buffer, len);
+        item->pages[index].x = x;
+        item->pages[index].y = y;
+        item->pages[index].buffer = buffer;
+        item->pages[index].len = len;
+
+        x += xoffset_per_page;
+        if (x >= item->info->var.xres) {
+            y++;
+            x -= item->info->var.xres;
+        }
+        y += yoffset_per_page;
+        buffer += pixels_per_page;
+    }
+
+    return 0;
+}
+
+static void lcdpi_pages_free(struct lcdpi *item)
+{
+    dev_dbg(item->dev, "%s: item=0x%p\n", __func__, (void *)item);
+
+    kfree(item->pages);
+}
+
+static inline __u32 CNVT_TOHW(__u32 val, __u32 width)
+{
+    return ((val<<width) + 0x7FFF - val)>>16;
+}
+
+/* This routine is needed because the console driver won't work without it. */
+static int lcdpi_setcolreg(unsigned regno,
+                           unsigned red, unsigned green, unsigned blue,
+                           unsigned transp, struct fb_info *info)
+{
+    int ret = 1;
+
+    /*
+     * If greyscale is true, then we convert the RGB value
+     * to greyscale no matter what visual we are using.
+     */
+    if (info->var.grayscale)
+        red = green = blue = (19595 * red + 38470 * green +
+                              7471 * blue) >> 16;
+    switch (info->fix.visual) {
+    case FB_VISUAL_TRUECOLOR:
+        if (regno < 16) {
+            u32 *pal = info->pseudo_palette;
+            u32 value;
+
+            red = CNVT_TOHW(red, info->var.red.length);
+            green = CNVT_TOHW(green, info->var.green.length);
+            blue = CNVT_TOHW(blue, info->var.blue.length);
+            transp = CNVT_TOHW(transp, info->var.transp.length);
+
+            value = (red << info->var.red.offset) |
+                    (green << info->var.green.offset) |
+                    (blue << info->var.blue.offset) |
+                    (transp << info->var.transp.offset);
+
+            pal[regno] = value;
+            ret = 0;
+        }
+        break;
+    case FB_VISUAL_STATIC_PSEUDOCOLOR:
+    case FB_VISUAL_PSEUDOCOLOR:
+        break;
+    }
+    return ret;
+}
+
+static int lcdpi_blank(int blank_mode, struct fb_info *info)
+{
+    struct lcdpi *item = (struct lcdpi *)info->par;
+    if (blank_mode == FB_BLANK_UNBLANK)
+        item->backlight=1;
+    else
+        item->backlight=0;
+    /*
+     * Item->backlight won't take effect until the LCD is written to. Force that
+     * by dirty'ing a page.
+     */
+    item->pages[0].must_update=1;
+    schedule_delayed_work(&info->deferred_work, 0);
+    return 0;
+}
+
+static void lcdpi_touch(struct fb_info *info, int x, int y, int w, int h)
+{
+    struct fb_deferred_io *fbdefio = info->fbdefio;
+    struct lcdpi *item = (struct lcdpi *)info->par;
+    int i, ystart, yend;
+    if (fbdefio) {
+        /* Touch the pages the y-range hits, so the deferred io will update them. */
+        for (i=0; i<item->pages_count; i++) {
+            ystart=item->pages[i].y;
+            yend=item->pages[i].y+(item->pages[i].len/info->fix.line_length)+1;
+            if (!((y+h)<ystart || y>yend)) {
+                item->pages[i].must_update=1;
+            }
+        }
+        /* Schedule the deferred IO to kick in after a delay. */
+        schedule_delayed_work(&info->deferred_work, fbdefio->delay);
+    }
+}
+
+static void lcdpi_fillrect(struct fb_info *p, const struct fb_fillrect *rect)
+{
+    sys_fillrect(p, rect);
+    lcdpi_touch(p, rect->dx, rect->dy, rect->width, rect->height);
+}
+
+static void lcdpi_imageblit(struct fb_info *p, const struct fb_image *image)
+{
+    sys_imageblit(p, image);
+    lcdpi_touch(p, image->dx, image->dy, image->width, image->height);
+}
+
+static void lcdpi_copyarea(struct fb_info *p, const struct fb_copyarea *area)
+{
+    sys_copyarea(p, area);
+    lcdpi_touch(p, area->dx, area->dy, area->width, area->height);
+}
+
+static ssize_t lcdpi_write(struct fb_info *p, const char __user *buf,
+                           size_t count, loff_t *ppos)
+{
+    ssize_t res;
+    res = fb_sys_write(p, buf, count, ppos);
+    lcdpi_touch(p, 0, 0, p->var.xres, p->var.yres);
+    return res;
+}
+
+static struct fb_ops lcdpi_fbops = {
+    .owner        = THIS_MODULE,
+    .fb_read      = fb_sys_read,
+    .fb_write     = lcdpi_write,
+    .fb_fillrect  = lcdpi_fillrect,
+    .fb_copyarea  = lcdpi_copyarea,
+    .fb_imageblit = lcdpi_imageblit,
+    .fb_setcolreg	= lcdpi_setcolreg,
+    .fb_blank	= lcdpi_blank,
+    .fb_ioctl = lcdpi_ioctl,
+};
+
+static struct fb_fix_screeninfo lcdpi_fix __initdata = {
+    .id          = "lcdpi",
+    .type        = FB_TYPE_PACKED_PIXELS,
+    .visual      = FB_VISUAL_TRUECOLOR,
+    .accel       = FB_ACCEL_NONE,
+    /*	.line_length =  HDP * 2, */
+};
+
+static struct fb_var_screeninfo lcdpi_var __initdata = {
+    /*		.xres		= HDP,
+     * 		.yres		= VDP,
+     * 		.xres_virtual	= HDP,
+     *  	.yres_virtual	= VDP,
+     */
+    .width		= 74,
+    .height		= 49,
+    .bits_per_pixel	= 16,
+    .red		= {11, 5, 0},
+    .green		= {5, 6, 0},
+    .blue		= {0, 5, 0},
+    .activate	= FB_ACTIVATE_NOW,
+    .vmode		= FB_VMODE_NONINTERLACED,
+};
+
+static struct fb_deferred_io lcdpi_defio = {
+    .delay          = HZ / 60,
+    .deferred_io    = &lcdpi_update_compress,
+};
+
+static u32 lcdpi_of_value(struct device_node *node, const char *propname)
+{
+    u32 val = -1;
+
+    of_property_read_u32(node, propname, &val);
+    return val;
+}
+
+static const struct of_device_id lcdpi_dt_ids[];
+
+static int lcdpi_parse_dt(struct device *dev)
+{
+    struct device_node *node = dev->of_node;
+    const struct of_device_id *of_id;
+    u32 dummy;
+
+    if(!node)
+        return -1;
+
+    of_id = of_match_device(lcdpi_dt_ids, dev);
+    if(!product_code)
+        product_code = (int)of_id->data;
+
+     //of_property_read_u8(node, "product-code", (u8*)&product_code);
+
+    dummy = lcdpi_of_value(node, "rotate");
+    if((dummy != -1) && (rotate == 360))
+        rotate = dummy;
+
+/*
+    dummy = lcdpi_of_value(node, "spi-max-frequency");
+    if(dummy != -1)
+        sclk = dummy;
+*/
+
+    of_property_read_u8_array(node, "rotate-codes", rotate_codes, 4);
+
+    return 0;
+}
+
+static int __init lcdpi_probe(struct spi_device *dev)
+{
+    int ret = 0;
+    struct lcdpi *item;
+    struct fb_info *info;
+
+    dev_dbg(&dev->dev, "%s\n", __func__);
+
+    lcdpi_parse_dt(&dev->dev);
+
+    item = kzalloc(sizeof(struct lcdpi), GFP_KERNEL);
+    if (!item) {
+        dev_err(&dev->dev, "%s: unable to kzalloc for lcdpi\n", __func__);
+        ret = -ENOMEM;
+        goto out;
+    }
+    item->dev = &dev->dev;
+    dev_set_drvdata(&dev->dev, item);
+    item->backlight=1;
+
+    lcdpi_item = item;
+    lcdpi_spi_device=item->spidev=dev;
+    spin_lock_init(&item->spi_lock);
+    item->dev=&dev->dev;
+    spi_set_drvdata(dev, item);
+    dev_info(&dev->dev, "4d-hat registered, product code = %x\n", product_code);
+
+    lcdpi_spiblock = (u8*)kmalloc(10, GFP_KERNEL);
+
+    item->spidev->max_speed_hz=16000000;
+    item->spidev->mode=0;
+    item->spidev->master->setup(item->spidev);
+
+    /* reset display and get the pruduct code */
+    lcdpi_spiblock[1]=0;
+    lcdpi_spiblock[2]=0;
+    lcdpi_spiblock[0]=LCDPI_RESET|LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+    lcdpi_spiblock[0]=LCDPI_RD;
+    spi_write(item->spidev, lcdpi_spiblock, 3);
+    mdelay(50);
+
+    switch(product_code) {
+    case HAT24:
+    case HAT32:
+    case HAT35:
+        break;
+    default:
+        spi_read(lcdpi_spi_device, &product_code, sizeof(unsigned char));
+        break;
+    }
+
+    rotate %= 360;
+
+    switch(product_code) {
+    case HAT24:
+        HDP = 320;
+        VDP = 240;
+        lcdpi_touchparams = touchscreens[0][rotate / 90];
+        break;
+    case HAT32:
+        HDP = 320;
+        VDP = 240;
+        lcdpi_touchparams = touchscreens[1][rotate / 90];
+        break;
+    case HAT35:
+        HDP = 480;
+        VDP = 320;
+        lcdpi_touchparams = touchscreens[2][rotate / 90];
+        break;
+    }
+
+    /* override with DT touch parameters */
+    if(rotate_codes[rotate / 90] != 0xff)
+        lcdpi_touchparams = rotate_codes[rotate / 90];
+
+    dev_dbg(&dev->dev, "%s: product_code=0x%x\n", __func__, product_code);
+
+    switch(rotate) {
+    case 90:
+    case 270: lcdpi_var.yres = HDP;
+        lcdpi_var.xres = VDP;
+        lcdpi_var.yres_virtual = HDP;
+        lcdpi_var.xres_virtual = VDP;
+        lcdpi_var.width = 49;
+        lcdpi_var.height = 74;
+        lcdpi_fix.line_length =  VDP * 2;
+        width = VDP - 1;
+        height = HDP - 1;
+        break;
+
+    default: lcdpi_var.xres = HDP;
+        lcdpi_var.yres = VDP;
+        lcdpi_var.xres_virtual = HDP;
+        lcdpi_var.yres_virtual = VDP;
+        lcdpi_var.width = 74;
+        lcdpi_var.height = 49;
+        lcdpi_fix.line_length =  HDP * 2;
+        width = HDP - 1;
+        height = VDP - 1;
+        break;
+    }
+
+    info = framebuffer_alloc(sizeof(struct lcdpi), &dev->dev);
+    if (!info) {
+        ret = -ENOMEM;
+        dev_err(&dev->dev, "%s: unable to framebuffer_alloc\n", __func__);
+        goto out_item;
+    }
+
+    info->pseudo_palette = &item->pseudo_palette;
+    item->info = info;
+    info->par = item;
+    info->dev = &dev->dev;
+    info->fbops = &lcdpi_fbops;
+    info->flags = FBINFO_FLAG_DEFAULT|FBINFO_VIRTFB;
+    info->fix = lcdpi_fix;
+    info->var = lcdpi_var;
+
+    ret = lcdpi_video_alloc(item);
+    if (ret) {
+        dev_err(&dev->dev, "%s: unable to lcdpi_video_alloc\n", __func__);
+        goto out_info;
+    }
+    info->screen_base = (char __iomem *)item->info->fix.smem_start;
+
+    ret = lcdpi_pages_alloc(item);
+    if (ret < 0) {
+        dev_err(&dev->dev, "%s: unable to lcdpi_pages_init\n", __func__);
+        goto out_video;
+    }
+
+    lcdpi_register_backlight(item);
+
+    switch(compress) {
+    case 0:
+        lcdpi_defio.deferred_io = &lcdpi_update;
+        break;
+
+    default:
+        lcdpi_defio.deferred_io = &lcdpi_update_compress;
+        break;
+    }
+
+    info->fbdefio = &lcdpi_defio;
+    fb_deferred_io_init(info);
+
+    item->dev->coherent_dma_mask = ~0;
+    lcdpi_spiblock_dma.buf = dma_alloc_coherent(item->dev, BLOCKLEN * 4, &lcdpi_spiblock_dma.dma, GFP_DMA);
+    lcdpi_spiblock_dma.len = BLOCKLEN * 4;
+
+    if(!lcdpi_spiblock){
+        dev_err(&dev->dev, "%s: unable to allocate spi buffer\n", __func__);
+        goto out_pages;
+    }
+
+    switch(product_code) {
+    case HAT24:
+        rotate = (rotate + 180) % 360;
+        ili9341_24_setup(item);
+        break;
+    case HAT32:
+        ili9341_32_setup(item);
+        break;
+    case HAT35:
+        hx8357_35_setup(item);
+        break;
+    default:
+        dev_err(&dev->dev, "%s: product not supporterd!\n", __func__);
+        break;
+    }
+
+    item->spidev->max_speed_hz=sclk;
+    item->spidev->master->setup(item->spidev);
+
+    lcdpi_update_all(item);
+
+    ret = register_framebuffer(info);
+    if (ret < 0) {
+        dev_err(&dev->dev, "%s: unable to register_frambuffer\n", __func__);
+        goto out_pages;
+    }
+
+    return ret;
+
+out_pages:
+    lcdpi_unregister_backlight(item);
+    lcdpi_pages_free(item);
+out_video:
+    lcdpi_video_free(item);
+out_info:
+    framebuffer_release(info);
+out_item:
+    kfree(item);
+out:
+    return ret;
+}
+
+static int __exit lcdpi_remove(struct spi_device *dev)
+{
+    struct lcdpi *item = dev_get_drvdata(&dev->dev);
+    struct fb_info *info;
+
+    dev_dbg(&dev->dev, "%s\n", __func__);
+
+    dev_set_drvdata(&dev->dev, NULL);
+    if (item) {
+        lcdpi_unregister_backlight(item);
+        info = item->info;
+        if (info) {
+            fb_deferred_io_cleanup(info);
+            unregister_framebuffer(info);
+            framebuffer_release(info);
+        }
+        lcdpi_pages_free(item);
+        lcdpi_video_free(item);
+
+        if(lcdpi_spiblock_dma.buf)
+            dma_free_coherent(item->dev, BLOCKLEN * 4, lcdpi_spiblock_dma.buf, lcdpi_spiblock_dma.dma);
+
+        kfree(item);
+    }
+
+    if(lcdpi_spiblock)
+        kfree(lcdpi_spiblock);
+
+    return 0;
+
+}
+
+/*
+#ifdef CONFIG_PM
+static int lcdpi_suspend(struct spi_device *spi, pm_message_t state)
+{
+    struct fb_info *info = dev_get_drvdata(&spi->dev);
+    struct lcdpi *item = (struct lcdpi *)info->par;
+    // enter into sleep mode
+    lcdpi_reg_set(item, lcdpi_REG_SLEEP_MODE, 0x0001);
+    return 0;
+}
+
+static int lcdpi_resume(struct spi_device *spi)
+{
+    struct fb_info *info = dev_get_drvdata(&spi->dev);
+    struct lcdpi *item = (struct lcdpi *)info->par;
+    // leave sleep mode
+    lcdpi_reg_set(item, lcdpi_REG_SLEEP_MODE, 0x0000);
+    return 0;
+}
+#else
+*/
+#define lcdpi_suspend NULL
+#define lcdpi_resume NULL
+/* #endif */
+
+static const struct of_device_id lcdpi_dt_ids[] = {
+{ .compatible = "4dsystems,24-hat", .data = (void *)HAT24 },
+{ .compatible = "4dsystems,32-hat", .data = (void *)HAT32  },
+{ .compatible = "4dsystems,35-hat", .data = (void *)HAT35  },
+{ .compatible = "4dsystems,4dpi-3x", .data = (void *)0  }, /* product code is read from Xilinx */
+{},
+};
+
+MODULE_DEVICE_TABLE(of, lcdpi_dt_ids);
+
+static struct spi_driver spi_lcdpi_driver = {
+    .driver = {
+        .name	= "4d-hats",
+        .owner	= THIS_MODULE,
+        .of_match_table = of_match_ptr(lcdpi_dt_ids),
+    },
+    .probe = lcdpi_probe,
+    .remove = lcdpi_remove,
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0))
+    .suspend = lcdpi_suspend,
+    .resume = lcdpi_resume,
+#endif
+
+};
+
+static int __init lcdpi_init(void)
+{
+    int ret = 0;
+
+    ret = spi_register_driver(&spi_lcdpi_driver);
+    if (ret) {
+        pr_err("%s: unable to platform_driver_register\n", __func__);
+    }
+
+    return ret;
+}
+static void __exit lcdpi_exit(void)
+{
+    pr_debug("%s\n", __func__);
+
+    spi_unregister_driver(&spi_lcdpi_driver);
+}
+
+module_init(lcdpi_init);
+module_exit(lcdpi_exit);
+
+MODULE_DESCRIPTION("4D-HAT LCD Driver");
+MODULE_AUTHOR("Andrej Strancar <info@hwlevel.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/video/4d-hats/4dpi-32.dts b/drivers/video/4d-hats/4dpi-32.dts
new file mode 100644
index 000000000000..f46a6eb5ebb5
--- /dev/null
+++ b/drivers/video/4d-hats/4dpi-32.dts
@@ -0,0 +1,103 @@
+/*
+ * Device Tree overlay for 4DPi-32 by 4D Systems
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+	fragment@0 {
+		target = <&spi0>;
+		__overlay__ {
+                        compatible = "brcm,bcm2708-spi-dma";
+			status = "okay";
+
+			spidev@0{
+				status = "disabled";
+			};
+
+			spidev@1{
+				status = "disabled";
+			};
+		};
+	};
+
+        fragment@1 {
+		target = <&spi0>;
+		__overlay__ {
+			/* needed to avoid dtc warning */
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rpidisplay: rpi-display@0{
+                                compatible = "4dsystems,32-hat";
+				reg = <0>;
+
+
+                                spi-max-frequency = <48000000>;
+                                /*
+                                rotate = <0>;
+                                rotate-codes = /bits/ 8 <0x03 0x05 0x00 0x06>;
+                                */
+                        };
+
+
+                        rpidisplay_ts: rpi-display-ts@1 {
+                                compatible = "ti,ads7846-4dpi3x";
+                                reg = <1>;
+
+                                spi-max-frequency = <1000000>;
+                                interrupts = <17 2>; /* high-to-low edge triggered */
+                                interrupt-parent = <&gpio>;
+                                pendown-gpio = <&gpio 17 0>;
+
+                                /*
+                                ti,swap-xy = /bits/ 16 <0>;
+                                ti,x-min = /bits/ 16 <280>;
+                                ti,x-max = /bits/ 16 <3830>;
+                                ti,y-min = /bits/ 16 <190>;
+                                ti,y-max = /bits/ 16 <3830>;
+                                */
+
+                                ti,x-min = /bits/ 16 <320>;
+                                ti,x-max = /bits/ 16 <3600>;
+                                ti,y-min = /bits/ 16 <220>;
+                                ti,y-max = /bits/ 16 <3400>;
+                                ti,vref-delay-usecs = /bits/ 16 <100>;
+
+                                ti,x-plate-ohms = /bits/ 16 <576>;
+                                ti,y-plate-ohms = /bits/ 16 <366>;
+
+                                ti,pressure-max = /bits/ 16 <15000>;
+
+                                ti,debounce-max = /bits/ 16 <5>;
+                                ti,debounce-rep = /bits/ 16 <1>;
+                                ti,debounce-tol = /bits/ 16 <8>;
+                        };
+		};
+	};
+
+        fragment@2 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "4dsystems,dma-pwm";
+
+                                4d,pwmbl-gpio = /bits/ 16 <18>;
+                                4d,pwmbl-type = /bits/ 16 <2>;
+                                4d,pwmbl-brightness = /bits/ 16 <100>;
+                                4d,pwmbl-title = "4dpi-32-pwm";
+                        };
+                };
+        };
+
+
+/*        __overrides__ {
+                speed =   <&rpidisplay>,"spi-max-frequency:0";
+                rotate =  <&rpidisplay>,"rotate:0";
+        };
+*/
+};
diff --git a/drivers/video/4d-hats/4dpi-35.dts b/drivers/video/4d-hats/4dpi-35.dts
new file mode 100644
index 000000000000..3a87dc46ec95
--- /dev/null
+++ b/drivers/video/4d-hats/4dpi-35.dts
@@ -0,0 +1,103 @@
+/*
+ * Device Tree overlay for 4DPi-35 by 4D Systems
+ *
+ */
+
+/dts-v1/;
+/plugin/;
+
+/ {
+	compatible = "brcm,bcm2835", "brcm,bcm2708", "brcm,bcm2709";
+
+	fragment@0 {
+		target = <&spi0>;
+		__overlay__ {
+                        compatible = "brcm,bcm2708-spi-dma";
+			status = "okay";
+
+			spidev@0{
+				status = "disabled";
+			};
+
+			spidev@1{
+				status = "disabled";
+			};
+		};
+	};
+
+        fragment@1 {
+		target = <&spi0>;
+		__overlay__ {
+			/* needed to avoid dtc warning */
+			#address-cells = <1>;
+			#size-cells = <0>;
+
+			rpidisplay: rpi-display@0{
+                                compatible = "4dsystems,35-hat";
+				reg = <0>;
+
+
+                                spi-max-frequency = <48000000>;
+                                /*
+                                rotate = <0>;
+                                rotate-codes = /bits/ 8 <0x03 0x05 0x00 0x06>;
+                                */
+                        };
+
+
+                        rpidisplay_ts: rpi-display-ts@1 {
+                                compatible = "ti,ads7846-4dpi3x";
+                                reg = <1>;
+
+                                spi-max-frequency = <1000000>;
+                                interrupts = <17 2>; /* high-to-low edge triggered */
+                                interrupt-parent = <&gpio>;
+                                pendown-gpio = <&gpio 17 0>;
+
+                                /*
+                                ti,swap-xy = /bits/ 16 <0>;
+                                ti,x-min = /bits/ 16 <280>;
+                                ti,x-max = /bits/ 16 <3830>;
+                                ti,y-min = /bits/ 16 <190>;
+                                ti,y-max = /bits/ 16 <3830>;
+                                */
+
+                                ti,x-min = /bits/ 16 <320>;
+                                ti,x-max = /bits/ 16 <3600>;
+                                ti,y-min = /bits/ 16 <220>;
+                                ti,y-max = /bits/ 16 <3400>;
+                                ti,vref-delay-usecs = /bits/ 16 <100>;
+
+                                ti,x-plate-ohms = /bits/ 16 <576>;
+                                ti,y-plate-ohms = /bits/ 16 <366>;
+
+                                ti,pressure-max = /bits/ 16 <15000>;
+
+                                ti,debounce-max = /bits/ 16 <5>;
+                                ti,debounce-rep = /bits/ 16 <1>;
+                                ti,debounce-tol = /bits/ 16 <8>;
+                        };
+		};
+	};
+
+        fragment@2 {
+                target-path = "/soc";
+                __overlay__ {
+                        backlight {
+                                compatible = "4dsystems,dma-pwm";
+
+                                4d,pwmbl-gpio = /bits/ 16 <18>;
+                                4d,pwmbl-type = /bits/ 16 <2>;
+                                4d,pwmbl-brightness = /bits/ 16 <100>;
+                                4d,pwmbl-title = "4dpi-35-pwm";
+                        };
+                };
+        };
+
+
+/*        __overrides__ {
+                speed =   <&rpidisplay>,"spi-max-frequency:0";
+                rotate =  <&rpidisplay>,"rotate:0";
+        };
+*/
+};
diff --git a/drivers/video/4d-hats/4dpi_touch.c b/drivers/video/4d-hats/4dpi_touch.c
new file mode 100644
index 000000000000..631111b3c529
--- /dev/null
+++ b/drivers/video/4d-hats/4dpi_touch.c
@@ -0,0 +1,1568 @@
+/*
+ * ADS7846 based touchscreen and sensor driver
+ *
+ * Copyright (c) 2005 David Brownell
+ * Copyright (c) 2006 Nokia Corporation
+ * Various changes: Imre Deak <imre.deak@nokia.com>
+ *
+ * Using code from:
+ *  - corgi_ts.c
+ *	Copyright (C) 2004-2005 Richard Purdie
+ *  - omap_ts.[hc], ads7846.h, ts_osk.c
+ *	Copyright (C) 2002 MontaVista Software
+ *	Copyright (C) 2004 Texas Instruments
+ *	Copyright (C) 2005 Dirk Behme
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+#include <linux/types.h>
+#include <linux/hwmon.h>
+#include <linux/init.h>
+#include <linux/err.h>
+#include <linux/sched.h>
+#include <linux/delay.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/slab.h>
+#include <linux/pm.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+#include <linux/of_device.h>
+#include <linux/gpio.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/ads7846.h>
+#include <linux/regulator/consumer.h>
+#include <linux/module.h>
+#include <asm/irq.h>
+
+/*
+ * This code has been heavily tested on a Nokia 770, and lightly
+ * tested on other ads7846 devices (OSK/Mistral, Lubbock, Spitz).
+ * TSC2046 is just newer ads7846 silicon.
+ * Support for ads7843 tested on Atmel at91sam926x-EK.
+ * Support for ads7845 has only been stubbed in.
+ * Support for Analog Devices AD7873 and AD7843 tested.
+ *
+ * IRQ handling needs a workaround because of a shortcoming in handling
+ * edge triggered IRQs on some platforms like the OMAP1/2. These
+ * platforms don't handle the ARM lazy IRQ disabling properly, thus we
+ * have to maintain our own SW IRQ disabled status. This should be
+ * removed as soon as the affected platform's IRQ handling is fixed.
+ *
+ * App note sbaa036 talks in more detail about accurate sampling...
+ * that ought to help in situations like LCDs inducing noise (which
+ * can also be helped by using synch signals) and more generally.
+ * This driver tries to utilize the measures described in the app
+ * note. The strength of filtering can be set in the board-* specific
+ * files.
+ */
+
+#define TS_POLL_DELAY	1	/* ms delay before the first sample */
+#define TS_POLL_PERIOD	5	/* ms delay between samples */
+
+/* this driver doesn't aim at the peak continuous sample rate */
+#define	SAMPLE_BITS	(8 /*cmd*/ + 16 /*sample*/ + 2 /* before, after */)
+
+extern u16 lcdpi_touchparams;
+u8 invert_x, invert_y;
+
+struct ts_event {
+	/*
+	 * For portability, we can't read 12 bit values using SPI (which
+	 * would make the controller deliver them as native byte order u16
+	 * with msbs zeroed).  Instead, we read them as two 8-bit values,
+	 * *** WHICH NEED BYTESWAPPING *** and range adjustment.
+	 */
+	u16	x;
+	u16	y;
+	u16	z1, z2;
+	bool	ignore;
+	u8	x_buf[3];
+	u8	y_buf[3];
+};
+
+/*
+ * We allocate this separately to avoid cache line sharing issues when
+ * driver is used with DMA-based SPI controllers (like atmel_spi) on
+ * systems where main memory is not DMA-coherent (most non-x86 boards).
+ */
+struct ads7846_packet {
+	u8			read_x, read_y, read_z1, read_z2, pwrdown;
+	u16			dummy;		/* for the pwrdown read */
+	struct ts_event		tc;
+	/* for ads7845 with mpc5121 psc spi we use 3-byte buffers */
+	u8			read_x_cmd[3], read_y_cmd[3], pwrdown_cmd[3];
+};
+
+struct ads7846 {
+	struct input_dev	*input;
+	char			phys[32];
+	char			name[32];
+
+	struct spi_device	*spi;
+	struct regulator	*reg;
+
+#if defined(CONFIG_HWMON) || defined(CONFIG_HWMON_MODULE)
+	struct attribute_group	*attr_group;
+	struct device		*hwmon;
+#endif
+
+	u16			model;
+	u16			vref_mv;
+	u16			vref_delay_usecs;
+	u16			x_plate_ohms;
+	u16			pressure_max;
+
+	bool			swap_xy;
+
+	u16			x_min;
+	u16			x_max;
+	u16			y_min;
+	u16			y_max;
+
+	bool			use_internal;
+
+	struct ads7846_packet	*packet;
+
+	struct spi_transfer	xfer[18];
+	struct spi_message	msg[5];
+	int			msg_count;
+	wait_queue_head_t	wait;
+
+	bool			pendown;
+
+	int			read_cnt;
+	int			read_rep;
+	int			last_read;
+
+	u16			debounce_max;
+	u16			debounce_tol;
+	u16			debounce_rep;
+
+	u16			penirq_recheck_delay_usecs;
+
+	struct mutex		lock;
+	bool			stopped;	/* P: lock */
+	bool			disabled;	/* P: lock */
+	bool			suspended;	/* P: lock */
+
+	int			(*filter)(void *data, int data_idx, int *val);
+	void			*filter_data;
+	void			(*filter_cleanup)(void *data);
+	int			(*get_pendown_state)(void);
+	int			gpio_pendown;
+
+	void			(*wait_for_sync)(void);
+};
+
+/* leave chip selected when we're done, for quicker re-select? */
+#if	0
+#define	CS_CHANGE(xfer)	((xfer).cs_change = 1)
+#else
+#define	CS_CHANGE(xfer)	((xfer).cs_change = 0)
+#endif
+
+/*--------------------------------------------------------------------------*/
+
+/* The ADS7846 has touchscreen and other sensors.
+ * Earlier ads784x chips are somewhat compatible.
+ */
+#define	ADS_START		(1 << 7)
+#define	ADS_A2A1A0_d_y		(1 << 4)	/* differential */
+#define	ADS_A2A1A0_d_z1		(3 << 4)	/* differential */
+#define	ADS_A2A1A0_d_z2		(4 << 4)	/* differential */
+#define	ADS_A2A1A0_d_x		(5 << 4)	/* differential */
+#define	ADS_A2A1A0_temp0	(0 << 4)	/* non-differential */
+#define	ADS_A2A1A0_vbatt	(2 << 4)	/* non-differential */
+#define	ADS_A2A1A0_vaux		(6 << 4)	/* non-differential */
+#define	ADS_A2A1A0_temp1	(7 << 4)	/* non-differential */
+#define	ADS_8_BIT		(1 << 3)
+#define	ADS_12_BIT		(0 << 3)
+#define	ADS_SER			(1 << 2)	/* non-differential */
+#define	ADS_DFR			(0 << 2)	/* differential */
+#define	ADS_PD10_PDOWN		(0 << 0)	/* low power mode + penirq */
+#define	ADS_PD10_ADC_ON		(1 << 0)	/* ADC on */
+#define	ADS_PD10_REF_ON		(2 << 0)	/* vREF on + penirq */
+#define	ADS_PD10_ALL_ON		(3 << 0)	/* ADC + vREF on */
+
+#define	MAX_12BIT	((1<<12)-1)
+
+/* leave ADC powered up (disables penirq) between differential samples */
+#define	READ_12BIT_DFR(x, adc, vref) (ADS_START | ADS_A2A1A0_d_ ## x \
+	| ADS_12_BIT | ADS_DFR | \
+	(adc ? ADS_PD10_ADC_ON : 0) | (vref ? ADS_PD10_REF_ON : 0))
+
+#define	READ_Y(vref)	(READ_12BIT_DFR(y,  1, vref))
+#define	READ_Z1(vref)	(READ_12BIT_DFR(z1, 1, vref))
+#define	READ_Z2(vref)	(READ_12BIT_DFR(z2, 1, vref))
+
+#define	READ_X(vref)	(READ_12BIT_DFR(x,  1, vref))
+#define	PWRDOWN		(READ_12BIT_DFR(y,  0, 0))	/* LAST */
+
+/* single-ended samples need to first power up reference voltage;
+ * we leave both ADC and VREF powered
+ */
+#define	READ_12BIT_SER(x) (ADS_START | ADS_A2A1A0_ ## x \
+	| ADS_12_BIT | ADS_SER)
+
+#define	REF_ON	(READ_12BIT_DFR(x, 1, 1))
+#define	REF_OFF	(READ_12BIT_DFR(y, 0, 0))
+
+/* Must be called with ts->lock held */
+static void ads7846_stop(struct ads7846 *ts)
+{
+	if (!ts->disabled && !ts->suspended) {
+		/* Signal IRQ thread to stop polling and disable the handler. */
+		ts->stopped = true;
+		mb();
+		wake_up(&ts->wait);
+		disable_irq(ts->spi->irq);
+	}
+}
+
+/* Must be called with ts->lock held */
+static void ads7846_restart(struct ads7846 *ts)
+{
+	if (!ts->disabled && !ts->suspended) {
+		/* Tell IRQ thread that it may poll the device. */
+		ts->stopped = false;
+		mb();
+		enable_irq(ts->spi->irq);
+	}
+}
+
+/* Must be called with ts->lock held */
+static void __ads7846_disable(struct ads7846 *ts)
+{
+	ads7846_stop(ts);
+	regulator_disable(ts->reg);
+
+	/*
+	 * We know the chip's in low power mode since we always
+	 * leave it that way after every request
+	 */
+}
+
+/* Must be called with ts->lock held */
+static void __ads7846_enable(struct ads7846 *ts)
+{
+	int error;
+
+	error = regulator_enable(ts->reg);
+	if (error != 0)
+		dev_err(&ts->spi->dev, "Failed to enable supply: %d\n", error);
+
+	ads7846_restart(ts);
+}
+
+static void ads7846_disable(struct ads7846 *ts)
+{
+	mutex_lock(&ts->lock);
+
+	if (!ts->disabled) {
+
+		if  (!ts->suspended)
+			__ads7846_disable(ts);
+
+		ts->disabled = true;
+	}
+
+	mutex_unlock(&ts->lock);
+}
+
+static void ads7846_enable(struct ads7846 *ts)
+{
+	mutex_lock(&ts->lock);
+
+	if (ts->disabled) {
+
+		ts->disabled = false;
+
+		if (!ts->suspended)
+			__ads7846_enable(ts);
+	}
+
+	mutex_unlock(&ts->lock);
+}
+
+/*--------------------------------------------------------------------------*/
+
+/*
+ * Non-touchscreen sensors only use single-ended conversions.
+ * The range is GND..vREF. The ads7843 and ads7835 must use external vREF;
+ * ads7846 lets that pin be unconnected, to use internal vREF.
+ */
+
+struct ser_req {
+	u8			ref_on;
+	u8			command;
+	u8			ref_off;
+	u16			scratch;
+	struct spi_message	msg;
+	struct spi_transfer	xfer[6];
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 */
+	__be16 sample ____cacheline_aligned;
+};
+
+struct ads7845_ser_req {
+	u8			command[3];
+	struct spi_message	msg;
+	struct spi_transfer	xfer[2];
+	/*
+	 * DMA (thus cache coherency maintenance) requires the
+	 * transfer buffers to live in their own cache lines.
+	 */
+	u8 sample[3] ____cacheline_aligned;
+};
+
+static int ads7846_read12_ser(struct device *dev, unsigned command)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct ads7846 *ts = dev_get_drvdata(dev);
+	struct ser_req *req;
+	int status;
+
+	req = kzalloc(sizeof *req, GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	spi_message_init(&req->msg);
+
+	/* maybe turn on internal vREF, and let it settle */
+	if (ts->use_internal) {
+		req->ref_on = REF_ON;
+		req->xfer[0].tx_buf = &req->ref_on;
+		req->xfer[0].len = 1;
+		spi_message_add_tail(&req->xfer[0], &req->msg);
+
+		req->xfer[1].rx_buf = &req->scratch;
+		req->xfer[1].len = 2;
+
+		/* for 1uF, settle for 800 usec; no cap, 100 usec.  */
+		req->xfer[1].delay_usecs = ts->vref_delay_usecs;
+		spi_message_add_tail(&req->xfer[1], &req->msg);
+
+		/* Enable reference voltage */
+		command |= ADS_PD10_REF_ON;
+	}
+
+	/* Enable ADC in every case */
+	command |= ADS_PD10_ADC_ON;
+
+	/* take sample */
+	req->command = (u8) command;
+	req->xfer[2].tx_buf = &req->command;
+	req->xfer[2].len = 1;
+	spi_message_add_tail(&req->xfer[2], &req->msg);
+
+	req->xfer[3].rx_buf = &req->sample;
+	req->xfer[3].len = 2;
+	spi_message_add_tail(&req->xfer[3], &req->msg);
+
+	/* REVISIT:  take a few more samples, and compare ... */
+
+	/* converter in low power mode & enable PENIRQ */
+	req->ref_off = PWRDOWN;
+	req->xfer[4].tx_buf = &req->ref_off;
+	req->xfer[4].len = 1;
+	spi_message_add_tail(&req->xfer[4], &req->msg);
+
+	req->xfer[5].rx_buf = &req->scratch;
+	req->xfer[5].len = 2;
+	CS_CHANGE(req->xfer[5]);
+	spi_message_add_tail(&req->xfer[5], &req->msg);
+
+	mutex_lock(&ts->lock);
+	ads7846_stop(ts);
+	status = spi_sync(spi, &req->msg);
+	ads7846_restart(ts);
+	mutex_unlock(&ts->lock);
+
+	if (status == 0) {
+		/* on-wire is a must-ignore bit, a BE12 value, then padding */
+		status = be16_to_cpu(req->sample);
+		status = status >> 3;
+		status &= 0x0fff;
+	}
+
+	kfree(req);
+	return status;
+}
+
+static int ads7845_read12_ser(struct device *dev, unsigned command)
+{
+	struct spi_device *spi = to_spi_device(dev);
+	struct ads7846 *ts = dev_get_drvdata(dev);
+	struct ads7845_ser_req *req;
+	int status;
+
+	req = kzalloc(sizeof *req, GFP_KERNEL);
+	if (!req)
+		return -ENOMEM;
+
+	spi_message_init(&req->msg);
+
+	req->command[0] = (u8) command;
+	req->xfer[0].tx_buf = req->command;
+	req->xfer[0].rx_buf = req->sample;
+	req->xfer[0].len = 3;
+	spi_message_add_tail(&req->xfer[0], &req->msg);
+
+	mutex_lock(&ts->lock);
+	ads7846_stop(ts);
+	status = spi_sync(spi, &req->msg);
+	ads7846_restart(ts);
+	mutex_unlock(&ts->lock);
+
+	if (status == 0) {
+		/* BE12 value, then padding */
+		status = be16_to_cpu(*((u16 *)&req->sample[1]));
+		status = status >> 3;
+		status &= 0x0fff;
+	}
+
+	kfree(req);
+	return status;
+}
+
+#if defined(CONFIG_HWMON) || defined(CONFIG_HWMON_MODULE)
+
+#define SHOW(name, var, adjust) static ssize_t \
+name ## _show(struct device *dev, struct device_attribute *attr, char *buf) \
+{ \
+	struct ads7846 *ts = dev_get_drvdata(dev); \
+	ssize_t v = ads7846_read12_ser(dev, \
+			READ_12BIT_SER(var)); \
+	if (v < 0) \
+		return v; \
+	return sprintf(buf, "%u\n", adjust(ts, v)); \
+} \
+static DEVICE_ATTR(name, S_IRUGO, name ## _show, NULL);
+
+
+/* Sysfs conventions report temperatures in millidegrees Celsius.
+ * ADS7846 could use the low-accuracy two-sample scheme, but can't do the high
+ * accuracy scheme without calibration data.  For now we won't try either;
+ * userspace sees raw sensor values, and must scale/calibrate appropriately.
+ */
+static inline unsigned null_adjust(struct ads7846 *ts, ssize_t v)
+{
+	return v;
+}
+
+SHOW(temp0, temp0, null_adjust)		/* temp1_input */
+SHOW(temp1, temp1, null_adjust)		/* temp2_input */
+
+
+/* sysfs conventions report voltages in millivolts.  We can convert voltages
+ * if we know vREF.  userspace may need to scale vAUX to match the board's
+ * external resistors; we assume that vBATT only uses the internal ones.
+ */
+static inline unsigned vaux_adjust(struct ads7846 *ts, ssize_t v)
+{
+	unsigned retval = v;
+
+	/* external resistors may scale vAUX into 0..vREF */
+	retval *= ts->vref_mv;
+	retval = retval >> 12;
+
+	return retval;
+}
+
+static inline unsigned vbatt_adjust(struct ads7846 *ts, ssize_t v)
+{
+	unsigned retval = vaux_adjust(ts, v);
+
+	/* ads7846 has a resistor ladder to scale this signal down */
+	if (ts->model == 7846)
+		retval *= 4;
+
+	return retval;
+}
+
+SHOW(in0_input, vaux, vaux_adjust)
+SHOW(in1_input, vbatt, vbatt_adjust)
+
+static struct attribute *ads7846_attributes[] = {
+	&dev_attr_temp0.attr,
+	&dev_attr_temp1.attr,
+	&dev_attr_in0_input.attr,
+	&dev_attr_in1_input.attr,
+	NULL,
+};
+
+static struct attribute_group ads7846_attr_group = {
+	.attrs = ads7846_attributes,
+};
+
+static struct attribute *ads7843_attributes[] = {
+	&dev_attr_in0_input.attr,
+	&dev_attr_in1_input.attr,
+	NULL,
+};
+
+static struct attribute_group ads7843_attr_group = {
+	.attrs = ads7843_attributes,
+};
+
+static struct attribute *ads7845_attributes[] = {
+	&dev_attr_in0_input.attr,
+	NULL,
+};
+
+static struct attribute_group ads7845_attr_group = {
+	.attrs = ads7845_attributes,
+};
+
+static int ads784x_hwmon_register(struct spi_device *spi, struct ads7846 *ts)
+{
+	struct device *hwmon;
+	int err;
+
+	/* hwmon sensors need a reference voltage */
+	switch (ts->model) {
+	case 7846:
+		if (!ts->vref_mv) {
+			dev_dbg(&spi->dev, "assuming 2.5V internal vREF\n");
+			ts->vref_mv = 2500;
+			ts->use_internal = true;
+		}
+		break;
+	case 7845:
+	case 7843:
+		if (!ts->vref_mv) {
+			dev_warn(&spi->dev,
+				"external vREF for ADS%d not specified\n",
+				ts->model);
+			return 0;
+		}
+		break;
+	}
+
+	/* different chips have different sensor groups */
+	switch (ts->model) {
+	case 7846:
+		ts->attr_group = &ads7846_attr_group;
+		break;
+	case 7845:
+		ts->attr_group = &ads7845_attr_group;
+		break;
+	case 7843:
+		ts->attr_group = &ads7843_attr_group;
+		break;
+	default:
+		dev_dbg(&spi->dev, "ADS%d not recognized\n", ts->model);
+		return 0;
+	}
+
+	err = sysfs_create_group(&spi->dev.kobj, ts->attr_group);
+	if (err)
+		return err;
+
+	hwmon = hwmon_device_register(&spi->dev);
+	if (IS_ERR(hwmon)) {
+		sysfs_remove_group(&spi->dev.kobj, ts->attr_group);
+		return PTR_ERR(hwmon);
+	}
+
+	ts->hwmon = hwmon;
+	return 0;
+}
+
+static void ads784x_hwmon_unregister(struct spi_device *spi,
+				     struct ads7846 *ts)
+{
+	if (ts->hwmon) {
+		sysfs_remove_group(&spi->dev.kobj, ts->attr_group);
+		hwmon_device_unregister(ts->hwmon);
+	}
+}
+
+#else
+static inline int ads784x_hwmon_register(struct spi_device *spi,
+					 struct ads7846 *ts)
+{
+	return 0;
+}
+
+static inline void ads784x_hwmon_unregister(struct spi_device *spi,
+					    struct ads7846 *ts)
+{
+}
+#endif
+
+static ssize_t ads7846_pen_down_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct ads7846 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->pendown);
+}
+
+static DEVICE_ATTR(pen_down, S_IRUGO, ads7846_pen_down_show, NULL);
+
+static ssize_t ads7846_disable_show(struct device *dev,
+				     struct device_attribute *attr, char *buf)
+{
+	struct ads7846 *ts = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", ts->disabled);
+}
+
+static ssize_t ads7846_disable_store(struct device *dev,
+				     struct device_attribute *attr,
+				     const char *buf, size_t count)
+{
+	struct ads7846 *ts = dev_get_drvdata(dev);
+	unsigned int i;
+	int err;
+
+	err = kstrtouint(buf, 10, &i);
+	if (err)
+		return err;
+
+	if (i)
+		ads7846_disable(ts);
+	else
+		ads7846_enable(ts);
+
+	return count;
+}
+
+static DEVICE_ATTR(disable, 0664, ads7846_disable_show, ads7846_disable_store);
+
+static struct attribute *ads784x_attributes[] = {
+	&dev_attr_pen_down.attr,
+	&dev_attr_disable.attr,
+	NULL,
+};
+
+static struct attribute_group ads784x_attr_group = {
+	.attrs = ads784x_attributes,
+};
+
+/*--------------------------------------------------------------------------*/
+
+static int get_pendown_state(struct ads7846 *ts)
+{
+	if (ts->get_pendown_state)
+		return ts->get_pendown_state();
+
+	return !gpio_get_value(ts->gpio_pendown);
+}
+
+static void null_wait_for_sync(void)
+{
+}
+
+static int ads7846_debounce_filter(void *ads, int data_idx, int *val)
+{
+	struct ads7846 *ts = ads;
+
+	if (!ts->read_cnt || (abs(ts->last_read - *val) > ts->debounce_tol)) {
+		/* Start over collecting consistent readings. */
+		ts->read_rep = 0;
+		/*
+		 * Repeat it, if this was the first read or the read
+		 * wasn't consistent enough.
+		 */
+		if (ts->read_cnt < ts->debounce_max) {
+			ts->last_read = *val;
+			ts->read_cnt++;
+			return ADS7846_FILTER_REPEAT;
+		} else {
+			/*
+			 * Maximum number of debouncing reached and still
+			 * not enough number of consistent readings. Abort
+			 * the whole sample, repeat it in the next sampling
+			 * period.
+			 */
+			ts->read_cnt = 0;
+			return ADS7846_FILTER_IGNORE;
+		}
+	} else {
+		if (++ts->read_rep > ts->debounce_rep) {
+			/*
+			 * Got a good reading for this coordinate,
+			 * go for the next one.
+			 */
+			ts->read_cnt = 0;
+			ts->read_rep = 0;
+			return ADS7846_FILTER_OK;
+		} else {
+			/* Read more values that are consistent. */
+			ts->read_cnt++;
+			return ADS7846_FILTER_REPEAT;
+		}
+	}
+}
+
+static int ads7846_no_filter(void *ads, int data_idx, int *val)
+{
+	return ADS7846_FILTER_OK;
+}
+
+static int ads7846_get_value(struct ads7846 *ts, struct spi_message *m)
+{
+	struct spi_transfer *t =
+		list_entry(m->transfers.prev, struct spi_transfer, transfer_list);
+
+	if (ts->model == 7845) {
+		return be16_to_cpup((__be16 *)&(((char*)t->rx_buf)[1])) >> 3;
+	} else {
+		/*
+		 * adjust:  on-wire is a must-ignore bit, a BE12 value, then
+		 * padding; built from two 8 bit values written msb-first.
+		 */
+		return be16_to_cpup((__be16 *)t->rx_buf) >> 3;
+	}
+}
+
+static void ads7846_update_value(struct spi_message *m, int val)
+{
+	struct spi_transfer *t =
+		list_entry(m->transfers.prev, struct spi_transfer, transfer_list);
+
+	*(u16 *)t->rx_buf = val;
+}
+
+static void ads7846_read_state(struct ads7846 *ts)
+{
+	struct ads7846_packet *packet = ts->packet;
+	struct spi_message *m;
+	int msg_idx = 0;
+	int val;
+	int action;
+	int error;
+
+	while (msg_idx < ts->msg_count) {
+
+		ts->wait_for_sync();
+
+		m = &ts->msg[msg_idx];
+		error = spi_sync(ts->spi, m);
+		if (error) {
+			dev_err(&ts->spi->dev, "spi_async --> %d\n", error);
+			packet->tc.ignore = true;
+			return;
+		}
+
+		/*
+		 * Last message is power down request, no need to convert
+		 * or filter the value.
+		 */
+		if (msg_idx < ts->msg_count - 1) {
+
+			val = ads7846_get_value(ts, m);
+
+			action = ts->filter(ts->filter_data, msg_idx, &val);
+			switch (action) {
+			case ADS7846_FILTER_REPEAT:
+				continue;
+
+			case ADS7846_FILTER_IGNORE:
+				packet->tc.ignore = true;
+				msg_idx = ts->msg_count - 1;
+				continue;
+
+			case ADS7846_FILTER_OK:
+				ads7846_update_value(m, val);
+				packet->tc.ignore = false;
+				msg_idx++;
+				break;
+
+			default:
+				BUG();
+			}
+		} else {
+			msg_idx++;
+		}
+	}
+}
+
+static void ads7846_report_state(struct ads7846 *ts)
+{
+	struct ads7846_packet *packet = ts->packet;
+	unsigned int Rt;
+	u16 x, y, z1, z2;
+
+	/*
+	 * ads7846_get_value() does in-place conversion (including byte swap)
+	 * from on-the-wire format as part of debouncing to get stable
+	 * readings.
+	 */
+	if (ts->model == 7845) {
+		x = *(u16 *)packet->tc.x_buf;
+		y = *(u16 *)packet->tc.y_buf;
+		z1 = 0;
+		z2 = 0;
+	} else {
+		x = packet->tc.x;
+		y = packet->tc.y;
+		z1 = packet->tc.z1;
+		z2 = packet->tc.z2;
+	}
+
+	/* range filtering */
+	if (x == MAX_12BIT)
+		x = 0;
+
+	if (ts->model == 7843) {
+		Rt = ts->pressure_max / 2;
+	} else if (ts->model == 7845) {
+		if (get_pendown_state(ts))
+			Rt = ts->pressure_max / 2;
+		else
+			Rt = 0;
+		dev_vdbg(&ts->spi->dev, "x/y: %d/%d, PD %d\n", x, y, Rt);
+	} else if (likely(x && z1)) {
+		/* compute touch pressure resistance using equation #2 */
+		Rt = z2;
+		Rt -= z1;
+		Rt *= x;
+		Rt *= ts->x_plate_ohms;
+		Rt /= z1;
+		Rt = (Rt + 2047) >> 12;
+	} else {
+		Rt = 0;
+	}
+
+	/*
+	 * Sample found inconsistent by debouncing or pressure is beyond
+	 * the maximum. Don't report it to user space, repeat at least
+	 * once more the measurement
+	 */
+	if (packet->tc.ignore || Rt > ts->pressure_max) {
+		dev_vdbg(&ts->spi->dev, "ignored %d pressure %d\n",
+			 packet->tc.ignore, Rt);
+		return;
+	}
+
+	/*
+	 * Maybe check the pendown state before reporting. This discards
+	 * false readings when the pen is lifted.
+	 */
+	if (ts->penirq_recheck_delay_usecs) {
+		udelay(ts->penirq_recheck_delay_usecs);
+		if (!get_pendown_state(ts))
+			Rt = 0;
+	}
+
+	/*
+	 * NOTE: We can't rely on the pressure to determine the pen down
+	 * state, even this controller has a pressure sensor. The pressure
+	 * value can fluctuate for quite a while after lifting the pen and
+	 * in some cases may not even settle at the expected value.
+	 *
+	 * The only safe way to check for the pen up condition is in the
+	 * timer by reading the pen signal state (it's a GPIO _and_ IRQ).
+	 */
+	if (Rt) {
+		struct input_dev *input = ts->input;
+
+		if (ts->swap_xy)
+			swap(x, y);
+
+		if (!ts->pendown) {
+			input_report_key(input, BTN_TOUCH, 1);
+			ts->pendown = true;
+			dev_vdbg(&ts->spi->dev, "DOWN\n");
+		}
+
+		if(invert_x)
+			x = ts->x_min + ts->x_max - x;
+
+		if(invert_y)
+					y = ts->y_min + ts->y_max - y;
+
+		input_report_abs(input, ABS_X, x);
+		input_report_abs(input, ABS_Y, y);
+		input_report_abs(input, ABS_PRESSURE, ts->pressure_max - Rt);
+
+		input_sync(input);
+		dev_vdbg(&ts->spi->dev, "%4d/%4d/%4d\n", x, y, Rt);
+	}
+}
+
+static irqreturn_t ads7846_hard_irq(int irq, void *handle)
+{
+	struct ads7846 *ts = handle;
+
+	return get_pendown_state(ts) ? IRQ_WAKE_THREAD : IRQ_HANDLED;
+}
+
+
+static irqreturn_t ads7846_irq(int irq, void *handle)
+{
+	struct ads7846 *ts = handle;
+
+	/* Start with a small delay before checking pendown state */
+	msleep(TS_POLL_DELAY);
+
+	while (!ts->stopped && get_pendown_state(ts)) {
+
+		/* pen is down, continue with the measurement */
+		ads7846_read_state(ts);
+
+		if (!ts->stopped)
+			ads7846_report_state(ts);
+
+		wait_event_timeout(ts->wait, ts->stopped,
+				   msecs_to_jiffies(TS_POLL_PERIOD));
+	}
+
+	if (ts->pendown) {
+		struct input_dev *input = ts->input;
+
+		input_report_key(input, BTN_TOUCH, 0);
+		input_report_abs(input, ABS_PRESSURE, 0);
+		input_sync(input);
+
+		ts->pendown = false;
+		dev_vdbg(&ts->spi->dev, "UP\n");
+	}
+
+	return IRQ_HANDLED;
+}
+
+#ifdef CONFIG_PM_SLEEP
+static int ads7846_suspend(struct device *dev)
+{
+	struct ads7846 *ts = dev_get_drvdata(dev);
+
+	mutex_lock(&ts->lock);
+
+	if (!ts->suspended) {
+
+		if (!ts->disabled)
+			__ads7846_disable(ts);
+
+		if (device_may_wakeup(&ts->spi->dev))
+			enable_irq_wake(ts->spi->irq);
+
+		ts->suspended = true;
+	}
+
+	mutex_unlock(&ts->lock);
+
+	return 0;
+}
+
+static int ads7846_resume(struct device *dev)
+{
+	struct ads7846 *ts = dev_get_drvdata(dev);
+
+	mutex_lock(&ts->lock);
+
+	if (ts->suspended) {
+
+		ts->suspended = false;
+
+		if (device_may_wakeup(&ts->spi->dev))
+			disable_irq_wake(ts->spi->irq);
+
+		if (!ts->disabled)
+			__ads7846_enable(ts);
+	}
+
+	mutex_unlock(&ts->lock);
+
+	return 0;
+}
+#endif
+
+static SIMPLE_DEV_PM_OPS(ads7846_pm, ads7846_suspend, ads7846_resume);
+
+static int ads7846_setup_pendown(struct spi_device *spi,
+				 struct ads7846 *ts,
+				 const struct ads7846_platform_data *pdata)
+{
+	int err;
+
+	/*
+	 * REVISIT when the irq can be triggered active-low, or if for some
+	 * reason the touchscreen isn't hooked up, we don't need to access
+	 * the pendown state.
+	 */
+
+	if (pdata->get_pendown_state) {
+		ts->get_pendown_state = pdata->get_pendown_state;
+	} else if (gpio_is_valid(pdata->gpio_pendown)) {
+
+		err = gpio_request_one(pdata->gpio_pendown, GPIOF_IN,
+				       "ads7846_pendown");
+		if (err) {
+			dev_err(&spi->dev,
+				"failed to request/setup pendown GPIO%d: %d\n",
+				pdata->gpio_pendown, err);
+			return err;
+		}
+
+		ts->gpio_pendown = pdata->gpio_pendown;
+
+		if (pdata->gpio_pendown_debounce)
+			gpio_set_debounce(pdata->gpio_pendown,
+					  pdata->gpio_pendown_debounce);
+	} else {
+		dev_err(&spi->dev, "no get_pendown_state nor gpio_pendown?\n");
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * Set up the transfers to read touchscreen state; this assumes we
+ * use formula #2 for pressure, not #3.
+ */
+static void ads7846_setup_spi_msg(struct ads7846 *ts,
+				  const struct ads7846_platform_data *pdata)
+{
+	struct spi_message *m = &ts->msg[0];
+	struct spi_transfer *x = ts->xfer;
+	struct ads7846_packet *packet = ts->packet;
+	int vref = pdata->keep_vref_on;
+
+	if (ts->model == 7873) {
+		/*
+		 * The AD7873 is almost identical to the ADS7846
+		 * keep VREF off during differential/ratiometric
+		 * conversion modes.
+		 */
+		ts->model = 7846;
+		vref = 0;
+	}
+
+	ts->msg_count = 1;
+	spi_message_init(m);
+	m->context = ts;
+
+	if (ts->model == 7845) {
+		packet->read_y_cmd[0] = READ_Y(vref);
+		packet->read_y_cmd[1] = 0;
+		packet->read_y_cmd[2] = 0;
+		x->tx_buf = &packet->read_y_cmd[0];
+		x->rx_buf = &packet->tc.y_buf[0];
+		x->len = 3;
+		spi_message_add_tail(x, m);
+	} else {
+		/* y- still on; turn on only y+ (and ADC) */
+		packet->read_y = READ_Y(vref);
+		x->tx_buf = &packet->read_y;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->tc.y;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+	}
+
+	/*
+	 * The first sample after switching drivers can be low quality;
+	 * optionally discard it, using a second one after the signals
+	 * have had enough time to stabilize.
+	 */
+	if (pdata->settle_delay_usecs) {
+		x->delay_usecs = pdata->settle_delay_usecs;
+
+		x++;
+		x->tx_buf = &packet->read_y;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->tc.y;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+	}
+
+	ts->msg_count++;
+	m++;
+	spi_message_init(m);
+	m->context = ts;
+
+	if (ts->model == 7845) {
+		x++;
+		packet->read_x_cmd[0] = READ_X(vref);
+		packet->read_x_cmd[1] = 0;
+		packet->read_x_cmd[2] = 0;
+		x->tx_buf = &packet->read_x_cmd[0];
+		x->rx_buf = &packet->tc.x_buf[0];
+		x->len = 3;
+		spi_message_add_tail(x, m);
+	} else {
+		/* turn y- off, x+ on, then leave in lowpower */
+		x++;
+		packet->read_x = READ_X(vref);
+		x->tx_buf = &packet->read_x;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->tc.x;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+	}
+
+	/* ... maybe discard first sample ... */
+	if (pdata->settle_delay_usecs) {
+		x->delay_usecs = pdata->settle_delay_usecs;
+
+		x++;
+		x->tx_buf = &packet->read_x;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->tc.x;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+	}
+
+	/* turn y+ off, x- on; we'll use formula #2 */
+	if (ts->model == 7846) {
+		ts->msg_count++;
+		m++;
+		spi_message_init(m);
+		m->context = ts;
+
+		x++;
+		packet->read_z1 = READ_Z1(vref);
+		x->tx_buf = &packet->read_z1;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->tc.z1;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+
+		/* ... maybe discard first sample ... */
+		if (pdata->settle_delay_usecs) {
+			x->delay_usecs = pdata->settle_delay_usecs;
+
+			x++;
+			x->tx_buf = &packet->read_z1;
+			x->len = 1;
+			spi_message_add_tail(x, m);
+
+			x++;
+			x->rx_buf = &packet->tc.z1;
+			x->len = 2;
+			spi_message_add_tail(x, m);
+		}
+
+		ts->msg_count++;
+		m++;
+		spi_message_init(m);
+		m->context = ts;
+
+		x++;
+		packet->read_z2 = READ_Z2(vref);
+		x->tx_buf = &packet->read_z2;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->tc.z2;
+		x->len = 2;
+		spi_message_add_tail(x, m);
+
+		/* ... maybe discard first sample ... */
+		if (pdata->settle_delay_usecs) {
+			x->delay_usecs = pdata->settle_delay_usecs;
+
+			x++;
+			x->tx_buf = &packet->read_z2;
+			x->len = 1;
+			spi_message_add_tail(x, m);
+
+			x++;
+			x->rx_buf = &packet->tc.z2;
+			x->len = 2;
+			spi_message_add_tail(x, m);
+		}
+	}
+
+	/* power down */
+	ts->msg_count++;
+	m++;
+	spi_message_init(m);
+	m->context = ts;
+
+	if (ts->model == 7845) {
+		x++;
+		packet->pwrdown_cmd[0] = PWRDOWN;
+		packet->pwrdown_cmd[1] = 0;
+		packet->pwrdown_cmd[2] = 0;
+		x->tx_buf = &packet->pwrdown_cmd[0];
+		x->len = 3;
+	} else {
+		x++;
+		packet->pwrdown = PWRDOWN;
+		x->tx_buf = &packet->pwrdown;
+		x->len = 1;
+		spi_message_add_tail(x, m);
+
+		x++;
+		x->rx_buf = &packet->dummy;
+		x->len = 2;
+	}
+
+	CS_CHANGE(*x);
+	spi_message_add_tail(x, m);
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id ads7846_dt_ids[] = {
+//	{ .compatible = "ti,tsc2046",	.data = (void *) 7846 },
+//	{ .compatible = "ti,ads7843",	.data = (void *) 7843 },
+//	{ .compatible = "ti,ads7845",	.data = (void *) 7845 },
+    { .compatible = "ti,ads7846-4dpi3x",	.data = (void *) 7846 },
+//	{ .compatible = "ti,ads7873",	.data = (void *) 7873 },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, ads7846_dt_ids);
+
+static const struct ads7846_platform_data *ads7846_probe_dt(struct device *dev)
+{
+	struct ads7846_platform_data *pdata;
+	struct device_node *node = dev->of_node;
+	const struct of_device_id *match;
+
+	if (!node) {
+		dev_err(dev, "Device does not have associated DT data\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	match = of_match_device(ads7846_dt_ids, dev);
+	if (!match) {
+		dev_err(dev, "Unknown device model\n");
+		return ERR_PTR(-EINVAL);
+	}
+
+	pdata = devm_kzalloc(dev, sizeof(*pdata), GFP_KERNEL);
+	if (!pdata)
+		return ERR_PTR(-ENOMEM);
+
+	pdata->model = (unsigned long)match->data;
+
+	of_property_read_u16(node, "ti,vref-delay-usecs",
+			     &pdata->vref_delay_usecs);
+	of_property_read_u16(node, "ti,vref-mv", &pdata->vref_mv);
+	pdata->keep_vref_on = of_property_read_bool(node, "ti,keep-vref-on");
+
+	pdata->swap_xy = of_property_read_bool(node, "ti,swap-xy");
+
+	of_property_read_u16(node, "ti,settle-delay-usec",
+			     &pdata->settle_delay_usecs);
+	of_property_read_u16(node, "ti,penirq-recheck-delay-usecs",
+			     &pdata->penirq_recheck_delay_usecs);
+
+	of_property_read_u16(node, "ti,x-plate-ohms", &pdata->x_plate_ohms);
+	of_property_read_u16(node, "ti,y-plate-ohms", &pdata->y_plate_ohms);
+
+	of_property_read_u16(node, "ti,x-min", &pdata->x_min);
+	of_property_read_u16(node, "ti,y-min", &pdata->y_min);
+	of_property_read_u16(node, "ti,x-max", &pdata->x_max);
+	of_property_read_u16(node, "ti,y-max", &pdata->y_max);
+
+	of_property_read_u16(node, "ti,pressure-min", &pdata->pressure_min);
+	of_property_read_u16(node, "ti,pressure-max", &pdata->pressure_max);
+
+	of_property_read_u16(node, "ti,debounce-max", &pdata->debounce_max);
+	of_property_read_u16(node, "ti,debounce-tol", &pdata->debounce_tol);
+	of_property_read_u16(node, "ti,debounce-rep", &pdata->debounce_rep);
+
+	of_property_read_u32(node, "ti,pendown-gpio-debounce",
+			     &pdata->gpio_pendown_debounce);
+
+	pdata->wakeup = of_property_read_bool(node, "linux,wakeup");
+
+	pdata->gpio_pendown = of_get_named_gpio(dev->of_node, "pendown-gpio", 0);
+
+	return pdata;
+}
+#else
+static const struct ads7846_platform_data *ads7846_probe_dt(struct device *dev)
+{
+	dev_err(dev, "no platform data defined\n");
+	return ERR_PTR(-EINVAL);
+}
+#endif
+
+static int ads7846_probe(struct spi_device *spi)
+{
+	const struct ads7846_platform_data *pdata;
+	struct ads7846 *ts;
+	struct ads7846_packet *packet;
+	struct input_dev *input_dev;
+	unsigned long irq_flags;
+	int err;
+
+	printk("touchparams:%x", lcdpi_touchparams);
+
+	if (!spi->irq) {
+		dev_dbg(&spi->dev, "no IRQ?\n");
+		return -EINVAL;
+	}
+
+	/* don't exceed max specified sample rate */
+	if (spi->max_speed_hz > (125000 * SAMPLE_BITS)) {
+		dev_err(&spi->dev, "f(sample) %d KHz?\n",
+				(spi->max_speed_hz/SAMPLE_BITS)/1000);
+		return -EINVAL;
+	}
+
+	/*
+	 * We'd set TX word size 8 bits and RX word size to 13 bits ... except
+	 * that even if the hardware can do that, the SPI controller driver
+	 * may not.  So we stick to very-portable 8 bit words, both RX and TX.
+	 */
+	spi->bits_per_word = 8;
+	spi->mode = SPI_MODE_0;
+	err = spi_setup(spi);
+	if (err < 0)
+		return err;
+
+	ts = kzalloc(sizeof(struct ads7846), GFP_KERNEL);
+	packet = kzalloc(sizeof(struct ads7846_packet), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!ts || !packet || !input_dev) {
+		err = -ENOMEM;
+		goto err_free_mem;
+	}
+
+	spi_set_drvdata(spi, ts);
+
+	ts->packet = packet;
+	ts->spi = spi;
+	ts->input = input_dev;
+
+	mutex_init(&ts->lock);
+	init_waitqueue_head(&ts->wait);
+
+	pdata = dev_get_platdata(&spi->dev);
+	if (!pdata) {
+		pdata = ads7846_probe_dt(&spi->dev);
+		if (IS_ERR(pdata))
+			return PTR_ERR(pdata);
+	}
+
+	ts->model = pdata->model ? : 7846;
+	ts->vref_delay_usecs = pdata->vref_delay_usecs ? : 100;
+	ts->x_plate_ohms = pdata->x_plate_ohms ? : 400;
+	ts->pressure_max = pdata->pressure_max ? : ~0;
+
+	ts->vref_mv = pdata->vref_mv;
+	ts->swap_xy = pdata->swap_xy;
+
+	ts->x_min = pdata->x_min;
+	ts->x_max = pdata->x_max;
+	ts->y_min = pdata->y_min;
+	ts->y_max = pdata->y_max;
+
+	ts->swap_xy = (lcdpi_touchparams & 0x04) >> 2;
+	invert_x = (lcdpi_touchparams & 0x02) >> 1;
+	invert_y = (lcdpi_touchparams & 0x01);
+
+	if (pdata->filter != NULL) {
+		if (pdata->filter_init != NULL) {
+			err = pdata->filter_init(pdata, &ts->filter_data);
+			if (err < 0)
+				goto err_free_mem;
+		}
+		ts->filter = pdata->filter;
+		ts->filter_cleanup = pdata->filter_cleanup;
+	} else if (pdata->debounce_max) {
+		ts->debounce_max = pdata->debounce_max;
+		if (ts->debounce_max < 2)
+			ts->debounce_max = 2;
+		ts->debounce_tol = pdata->debounce_tol;
+		ts->debounce_rep = pdata->debounce_rep;
+		ts->filter = ads7846_debounce_filter;
+		ts->filter_data = ts;
+	} else {
+		ts->filter = ads7846_no_filter;
+	}
+
+	err = ads7846_setup_pendown(spi, ts, pdata);
+	if (err)
+		goto err_cleanup_filter;
+
+	if (pdata->penirq_recheck_delay_usecs)
+		ts->penirq_recheck_delay_usecs =
+				pdata->penirq_recheck_delay_usecs;
+
+	ts->wait_for_sync = pdata->wait_for_sync ? : null_wait_for_sync;
+
+	snprintf(ts->phys, sizeof(ts->phys), "%s/input0", dev_name(&spi->dev));
+	snprintf(ts->name, sizeof(ts->name), "ADS%d Touchscreen", ts->model);
+
+	input_dev->name = ts->name;
+	input_dev->phys = ts->phys;
+	input_dev->dev.parent = &spi->dev;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+	input_set_abs_params(input_dev, ABS_X,
+			pdata->x_min ? : 0,
+			pdata->x_max ? : MAX_12BIT,
+			0, 0);
+	input_set_abs_params(input_dev, ABS_Y,
+			pdata->y_min ? : 0,
+			pdata->y_max ? : MAX_12BIT,
+			0, 0);
+	input_set_abs_params(input_dev, ABS_PRESSURE,
+			pdata->pressure_min, pdata->pressure_max, 0, 0);
+
+	ads7846_setup_spi_msg(ts, pdata);
+
+	ts->reg = regulator_get(&spi->dev, "vcc");
+	if (IS_ERR(ts->reg)) {
+		err = PTR_ERR(ts->reg);
+		dev_err(&spi->dev, "unable to get regulator: %d\n", err);
+		goto err_free_gpio;
+	}
+
+	err = regulator_enable(ts->reg);
+	if (err) {
+		dev_err(&spi->dev, "unable to enable regulator: %d\n", err);
+		goto err_put_regulator;
+	}
+
+	irq_flags = pdata->irq_flags ? : IRQF_TRIGGER_FALLING;
+	irq_flags |= IRQF_ONESHOT;
+
+	err = request_threaded_irq(spi->irq, ads7846_hard_irq, ads7846_irq,
+				   irq_flags, spi->dev.driver->name, ts);
+	if (err && !pdata->irq_flags) {
+		dev_info(&spi->dev,
+			"trying pin change workaround on irq %d\n", spi->irq);
+		irq_flags |= IRQF_TRIGGER_RISING;
+		err = request_threaded_irq(spi->irq,
+				  ads7846_hard_irq, ads7846_irq,
+				  irq_flags, spi->dev.driver->name, ts);
+	}
+
+	if (err) {
+		dev_dbg(&spi->dev, "irq %d busy?\n", spi->irq);
+		goto err_disable_regulator;
+	}
+
+	err = ads784x_hwmon_register(spi, ts);
+	if (err)
+		goto err_free_irq;
+
+	dev_info(&spi->dev, "touchscreen, irq %d\n", spi->irq);
+
+	/*
+	 * Take a first sample, leaving nPENIRQ active and vREF off; avoid
+	 * the touchscreen, in case it's not connected.
+	 */
+	if (ts->model == 7845)
+		ads7845_read12_ser(&spi->dev, PWRDOWN);
+	else
+		(void) ads7846_read12_ser(&spi->dev, READ_12BIT_SER(vaux));
+
+	err = sysfs_create_group(&spi->dev.kobj, &ads784x_attr_group);
+	if (err)
+		goto err_remove_hwmon;
+
+	err = input_register_device(input_dev);
+	if (err)
+		goto err_remove_attr_group;
+
+	device_init_wakeup(&spi->dev, pdata->wakeup);
+
+	/*
+	 * If device does not carry platform data we must have allocated it
+	 * when parsing DT data.
+	 */
+	if (!dev_get_platdata(&spi->dev))
+		devm_kfree(&spi->dev, (void *)pdata);
+
+	return 0;
+
+ err_remove_attr_group:
+	sysfs_remove_group(&spi->dev.kobj, &ads784x_attr_group);
+ err_remove_hwmon:
+	ads784x_hwmon_unregister(spi, ts);
+ err_free_irq:
+	free_irq(spi->irq, ts);
+ err_disable_regulator:
+	regulator_disable(ts->reg);
+ err_put_regulator:
+	regulator_put(ts->reg);
+ err_free_gpio:
+	if (!ts->get_pendown_state)
+		gpio_free(ts->gpio_pendown);
+ err_cleanup_filter:
+	if (ts->filter_cleanup)
+		ts->filter_cleanup(ts->filter_data);
+ err_free_mem:
+	input_free_device(input_dev);
+	kfree(packet);
+	kfree(ts);
+	return err;
+}
+
+static int ads7846_remove(struct spi_device *spi)
+{
+	struct ads7846 *ts = spi_get_drvdata(spi);
+
+	device_init_wakeup(&spi->dev, false);
+
+	sysfs_remove_group(&spi->dev.kobj, &ads784x_attr_group);
+
+	ads7846_disable(ts);
+	free_irq(ts->spi->irq, ts);
+
+	input_unregister_device(ts->input);
+
+	ads784x_hwmon_unregister(spi, ts);
+
+	regulator_disable(ts->reg);
+	regulator_put(ts->reg);
+
+	if (!ts->get_pendown_state) {
+		/*
+		 * If we are not using specialized pendown method we must
+		 * have been relying on gpio we set up ourselves.
+		 */
+		gpio_free(ts->gpio_pendown);
+	}
+
+	if (ts->filter_cleanup)
+		ts->filter_cleanup(ts->filter_data);
+
+	kfree(ts->packet);
+	kfree(ts);
+
+	dev_dbg(&spi->dev, "unregistered touchscreen\n");
+
+	return 0;
+}
+
+static struct spi_driver ads7846_driver = {
+	.driver = {
+		.name	= "ads7846",
+		.owner	= THIS_MODULE,
+		.pm	= &ads7846_pm,
+		.of_match_table = of_match_ptr(ads7846_dt_ids),
+	},
+	.probe		= ads7846_probe,
+	.remove		= ads7846_remove,
+};
+
+module_spi_driver(ads7846_driver);
+
+MODULE_DESCRIPTION("ADS7846 TouchScreen Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("spi:ads7846");
diff --git a/drivers/video/4d-hats/Kconfig b/drivers/video/4d-hats/Kconfig
new file mode 100644
index 000000000000..76a4b05711da
--- /dev/null
+++ b/drivers/video/4d-hats/Kconfig
@@ -0,0 +1,28 @@
+menuconfig 4DHATS
+        tristate "Support for 4D Systems display modules"
+        depends on FB
+        select FB_SYS_FILLRECT
+        select FB_SYS_COPYAREA
+        select FB_SYS_IMAGEBLIT
+        select FB_SYS_FOPS
+        select FB_DEFERRED_IO
+        select FB_BACKLIGHT
+
+config FB_HATS
+        tristate "4D Systems LCD HAT support (2.4, 3.2 and 3.5 inch)"
+        depends on 4DHATS
+
+config 4DPI_SPI_DMA
+        tristate "DMA Enabled SPI Master Driver"
+        depends on 4DHATS
+
+config 4DPI_ADS7846
+        tristate "Module for ADS7846 resistive touch screen controller"
+        depends on 4DHATS
+
+config 4DPI_AR1020I2C
+        tristate "Module for AR1020 resistive touch screen controller"
+        depends on I2C
+
+config 4DPI_PWMBL
+        tristate "Module for DMA supported PWM backlight driver"
diff --git a/drivers/video/4d-hats/Kconfig_patch.txt b/drivers/video/4d-hats/Kconfig_patch.txt
new file mode 100644
index 000000000000..a315cf852367
--- /dev/null
+++ b/drivers/video/4d-hats/Kconfig_patch.txt
@@ -0,0 +1,11 @@
+--- Kconfig	2016-11-23 14:21:36.000000000 +0000
++++ Kconfig_a	2016-12-29 09:30:22.186229110 +0000
+@@ -40,6 +40,8 @@
+ config HDMI
+	bool
+
++source "drivers/video/4d-hats/Kconfig"
++
+ if VT
+	source "drivers/video/console/Kconfig"
+ endif
diff --git a/drivers/video/4d-hats/Makefile b/drivers/video/4d-hats/Makefile
new file mode 100644
index 000000000000..e071d40764e7
--- /dev/null
+++ b/drivers/video/4d-hats/Makefile
@@ -0,0 +1,20 @@
+EXTRA_CFLAGS += -I$(src)
+
+KERNEL_GE_4_1 := $(shell [ $(VERSION) -ge 4 -a $(PATCHLEVEL) -ge 1 ] && echo true)
+ifeq ($(KERNEL_GE_4_1),true)
+	obj-$(CONFIG_4DPI_SPI_DMA)        += spi-bcm2835_dma.o
+else
+	obj-$(CONFIG_4DPI_SPI_DMA)        += spi-bcm2708_dma.o
+endif
+
+obj-$(CONFIG_FB_HATS)             += 4dpi.o
+
+ifeq ($(CONFIG_LOCALVERSION),"-v7_Re4son-Kali-Pi-TFT")
+        4dpi-objs                       := 4d-hats.o compress-v7.o
+else
+        4dpi-objs                       := 4d-hats.o compress-v6.o
+endif
+
+obj-$(CONFIG_4DPI_ADS7846)        += 4dpi_touch.o
+obj-$(CONFIG_4DPI_AR1020I2C)      += ar1020-i2c.o
+obj-$(CONFIG_4DPI_PWMBL)          += pwmbl.o
diff --git a/drivers/video/4d-hats/Makefile_patch.txt b/drivers/video/4d-hats/Makefile_patch.txt
new file mode 100644
index 000000000000..2e8880085b4a
--- /dev/null
+++ b/drivers/video/4d-hats/Makefile_patch.txt
@@ -0,0 +1,10 @@
+--- Makefile	2016-11-23 14:21:36.000000000 +0000
++++ Makefile_a	2016-12-29 09:30:55.245896596 +0000
+@@ -6,6 +6,7 @@
+ obj-y				  += backlight/
+
+ obj-y				  += fbdev/
++obj-y                             += 4d-hats/
+
+ obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
+ ifeq ($(CONFIG_OF),y)
diff --git a/drivers/video/4d-hats/README b/drivers/video/4d-hats/README
new file mode 100644
index 000000000000..799db51e2cb9
--- /dev/null
+++ b/drivers/video/4d-hats/README
@@ -0,0 +1,47 @@
+INSTALLATION
+  Download kernel sources
+
+  From linux directory:
+    cd drivers/video
+    git clone https://bitbucket.org/4DPi/4d-hats.git
+
+    Add to drivers/video/Kconfig:   source "drivers/video/4d-hats/Kconfig"
+    -----------------------------------
+    config HDMI
+            bool
+
+    source "drivers/video/4d-hats/Kconfig"
+
+    if VT
+            source "drivers/video/console/Kconfig"
+    endif
+    -----------------------------------
+
+    Add to drivers/video/Makefile:  obj-y += 4d-hats/
+    -----------------------------------
+    obj-y				  += fbdev/
+    obj-y                                 += 4d-hats/
+
+    obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
+
+    -----------------------------------
+
+  Enable driver(s) in menuconfig and build the kernel:
+    Device Drivers-->Graphics support
+
+    <*> Support for 4D Systems display modules  --->
+        <*>   4D Systems LCD HAT support (2.4, 3.2 and 3.5 inch)
+        <*>   DMA Enabled SPI Master Driver
+        <M>   Module for ADS7846 resistive touch screen controller
+
+    <M> Module for AR1020 resistive touch screen controller
+    <M> Module for DMA supported PWM backlight driver
+
+  Compiling device tree overlays (only necessary if overlay sources are mofified):
+    recent dtc (device tree compiler) has to be installed. A script is provided.
+    For example DT overlay for 24-hat can be compiled with:
+
+    ./dtc.sh 24-hat
+
+    resulting .dtb files should be flashed to HAT EEPROMs or copied to:
+    /boot/overlays on RPi.
diff --git a/drivers/video/4d-hats/ar1020-i2c.c b/drivers/video/4d-hats/ar1020-i2c.c
new file mode 100644
index 000000000000..b790c3cb0953
--- /dev/null
+++ b/drivers/video/4d-hats/ar1020-i2c.c
@@ -0,0 +1,1098 @@
+/*
+ * Microchip I2C Touchscreen Driver
+ *
+ * Copyright (c) 2011 Microchip Technology, Inc.
+ *
+ * http://www.microchip.com/mtouch
+ */
+
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 as published by
+ * the Free Software Foundation.
+ */
+
+#include <linux/input.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/init.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+
+
+// we want GPIO_30 (pin 11 on P5 pinout raspberry pi rev. 2 board)
+// to generate interrupt
+#define GPIO_ANY_GPIO               17
+
+// text below will be seen in 'cat /proc/interrupt' command
+#define GPIO_ANY_GPIO_DESC           "AR1021 Touch Panel Interrupt"
+
+// below is optional, used in more complex code, in our case, this could be
+// NULL
+#define GPIO_ANY_GPIO_DEVICE_DESC    "AR1021 Touch Panel"
+
+
+/****************************************************************************/
+/* Interrupts variables block                                               */
+/****************************************************************************/
+//short int irq_any_gpio    = 0;
+
+
+/* The maximum packet byte length */
+#define MCHIP_MAX_LENGTH 5
+
+/* The private data structure that is referenced within the I2C bus driver */
+struct ar1020_i2c_priv {
+	struct i2c_client *client;
+	struct input_dev *input;
+	struct work_struct work;
+	int irq;
+	int testCount;
+};
+
+
+/* These are all the sysfs variables used to store and retrieve information
+   from a user-level application */
+static char sendBuffer[100];
+static char receiveBuffer[100];
+static int commandMode=0;
+static int commandDataPending=0;
+#if 1 //default value
+static int minX=0;
+static int maxX=4095;
+static int minY=0;
+static int maxY=4095;
+static int swapAxes=0;
+static int invertX=0;
+static int invertY=0;
+#elif 0
+static int minX=100;
+static int maxX=3825;
+static int minY=340;
+static int maxY=3830;
+static int swapAxes=0;
+static int invertX=0;
+static int invertY=1;
+#elif 0
+static int minX=180;
+static int maxX=3725;
+static int minY=320;
+static int maxY=3730;
+static int swapAxes=0;
+static int invertX=0;
+static int invertY=1;
+#endif
+static int lastPUCoordX=0;
+static int lastPUCoordY=0;
+
+static int lastButton=0;
+
+/* These variables allows the IRQ to be specified via a module parameter
+   or kernel parameter.  To configuration of these value, please see
+   driver documentation. */
+static int touchIRQ=-1;
+static int probeForIRQ=0;
+static int testI2Cdata=0;
+static int probeMin=0;
+static int probeMax=200;
+
+module_param(touchIRQ, int, S_IRUGO);
+module_param(probeMin, int, S_IRUGO);
+module_param(probeMax, int, S_IRUGO);
+module_param(probeForIRQ, int, S_IRUGO);
+module_param(testI2Cdata, int, S_IRUGO);
+
+extern u16 lcdpi_touchparams;
+
+/* Since the reference to private data is stored within the I2C
+   bus driver, we will store another reference within this driver
+   so the sysfs related function may also access this data */
+struct ar1020_i2c_priv *privRef=NULL;
+
+/******************************************************************************
+Function:
+	commandDataPending_show()
+
+Description:
+	Display value of "commandDataPending" variable to application that is
+	requesting it's value.
+******************************************************************************/
+static ssize_t commandDataPending_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d", commandDataPending);
+}
+
+/******************************************************************************
+Function:
+	commandDataPending_store()
+
+Description:
+	Save value to "commandDataPending" variable from application that is
+	requesting this.
+******************************************************************************/
+static ssize_t commandDataPending_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	sscanf(buf, "%d", &commandDataPending);
+	return count;
+}
+
+static struct kobj_attribute commandDataPending_attribute =
+    __ATTR(commandDataPending, 0660, commandDataPending_show, commandDataPending_store);
+
+
+/******************************************************************************
+Function:
+	commandMode_show()
+
+Description:
+	Display value of "commandMode" variable to application that is
+	requesting it's value.
+******************************************************************************/
+static ssize_t commandMode_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%d", commandMode);
+}
+
+/******************************************************************************
+Function:
+	commandMode_store()
+
+Description:
+	Save value to "commandMode" variable from application that is
+	requesting this.
+******************************************************************************/
+static ssize_t commandMode_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	sscanf(buf, "%d", &commandMode);
+	return count;
+
+}
+
+static struct kobj_attribute commandMode_attribute =
+    __ATTR(commandMode, 0660, commandMode_show, commandMode_store);
+
+/******************************************************************************
+Function:
+	receiveBuffer_show()
+
+Description:
+	Display value of "receiveBuffer" variable to application that is
+	requesting it's value.
+******************************************************************************/
+static ssize_t receiveBuffer_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	/* since we have now read the receiveBuffer, receive data is no longer pending */
+	commandDataPending=0;
+	return sprintf(buf, "%s", receiveBuffer);
+}
+
+/******************************************************************************
+Function:
+	receiveBuffer_store()
+
+Description:
+	Save value to "receiveBuffer" variable from application that is
+	requesting this.
+******************************************************************************/
+static ssize_t receiveBuffer_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return snprintf(receiveBuffer,sizeof(receiveBuffer),"%s",buf);
+}
+
+static struct kobj_attribute receiveBuffer_attribute =
+    __ATTR(receiveBuffer, 0660, receiveBuffer_show, receiveBuffer_store);
+
+/******************************************************************************
+Function:
+	sendBuffer_show()
+
+Description:
+	Display value of "sendBuffer" variable to application that is
+	requesting it's value.
+******************************************************************************/
+static ssize_t sendBuffer_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	return sprintf(buf, "%s", sendBuffer);
+}
+
+/******************************************************************************
+Function:
+	sendBuffer_store()
+
+Description:
+	Save value to "sendBuffer" variable from application that is
+	requesting this.
+******************************************************************************/
+static ssize_t sendBuffer_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int commandByte[8];
+	char buff[8];
+	int numCommandBytes;
+	int i;
+
+	commandDataPending=0;
+
+	/* disallow commands to be sent until command mode is enabled */
+	if (0==commandMode)
+	{
+		// printk("AR1020 I2C: Warning: command bytes will be ignored until commandMode is enabled\n");
+		strcpy(sendBuffer,"");
+		return count;
+	}
+
+	numCommandBytes=sscanf(buf,"%x %x %x %x %x %x %x %x",&commandByte[0],&commandByte[1],&commandByte[2],&commandByte[3],&commandByte[4],&commandByte[5],&commandByte[6],&commandByte[7]);
+
+
+	// printk(KERN_DEBUG "AR1020 I2C: Processed %d bytes.\n",numCommandBytes);
+
+	/* Verify command string to send to controller is valid */
+	if (numCommandBytes<3)
+	{
+		// printk("AR1020 I2C: Insufficient command bytes to process.\n");
+	}
+	else if (commandByte[0]!=0x0)
+	{
+		// printk("AR1020 I2C: Leading zero required when sending I2C commands.\n");
+	}
+	else if (commandByte[1]!=0x55)
+	{
+		// printk("AR1020 I2C: Invalid header byte (0x55 expected).\n");
+	}
+	else if (commandByte[2] != (numCommandBytes-3))
+	{
+		// printk("AR1020 I2C: Number of command bytes specified not valid for current string.\n");
+	}
+
+	strcpy(sendBuffer,"");
+	// printk(KERN_DEBUG "AR1020 I2C: sending command bytes: ");
+	for (i=0;i<numCommandBytes;i++)
+	{
+	   buff[i]=(char)commandByte[i];
+	   // printk(KERN_DEBUG "0x%02x ", commandByte[i]);
+
+	}
+	// printk(KERN_DEBUG "\n");
+
+	i2c_master_send (privRef->client,buff,numCommandBytes);
+
+	return snprintf(sendBuffer,sizeof(sendBuffer),"%s",buf);
+}
+
+static struct kobj_attribute sendBuffer_attribute =
+    __ATTR(sendBuffer, 0660, sendBuffer_show, sendBuffer_store);
+
+/******************************************************************************
+Function:
+	calibrationSettings_show()
+
+Description:
+	Display value of "calibrationSettings" variable to application that is
+	requesting it's value.	The handling of the calibration settings has
+	been grouped together.
+******************************************************************************/
+static ssize_t calibrationSettings_show(struct kobject *kobj, struct kobj_attribute *attr,
+		      char *buf)
+{
+	int calibrationSetting=0;
+
+	if (strcmp(attr->attr.name, "minX") == 0)
+		calibrationSetting = minX;
+	else if (strcmp(attr->attr.name, "maxX") == 0)
+		calibrationSetting = maxX;
+	else if (strcmp(attr->attr.name, "minY") == 0)
+		calibrationSetting = minY;
+	else if (strcmp(attr->attr.name, "maxY") == 0)
+		calibrationSetting = maxY;
+	else if (strcmp(attr->attr.name, "swapAxes") == 0)
+		calibrationSetting = swapAxes;
+	else if (strcmp(attr->attr.name, "invertX") == 0)
+		calibrationSetting = invertX;
+	else if (strcmp(attr->attr.name, "invertY") == 0)
+		calibrationSetting = invertY;
+	else if (strcmp(attr->attr.name, "lastPUCoordX") == 0)
+		calibrationSetting = lastPUCoordX;
+	else if (strcmp(attr->attr.name, "lastPUCoordY") == 0)
+		calibrationSetting = lastPUCoordY;
+
+	return sprintf(buf, "%d\n", calibrationSetting);
+}
+
+/******************************************************************************
+Function:
+	calibrationSettings_store()
+
+Description:
+	Save calibration setting to corresponding variable from applicationv
+	that is requesting this.
+******************************************************************************/
+static ssize_t calibrationSettings_store(struct kobject *kobj, struct kobj_attribute *attr,
+		       const char *buf, size_t count)
+{
+	int calibrationSetting;
+
+	sscanf(buf, "%d", &calibrationSetting);
+
+	if (strcmp(attr->attr.name, "minX") == 0)
+		minX = calibrationSetting;
+	else if (strcmp(attr->attr.name, "maxX") == 0)
+		maxX = calibrationSetting;
+	else if (strcmp(attr->attr.name, "minY") == 0)
+		minY = calibrationSetting;
+	else if (strcmp(attr->attr.name, "maxY") == 0)
+		maxY = calibrationSetting;
+	else if (strcmp(attr->attr.name, "swapAxes") == 0)
+		swapAxes = calibrationSetting;
+	else if (strcmp(attr->attr.name, "invertX") == 0)
+		invertX = calibrationSetting;
+	else if (strcmp(attr->attr.name, "invertY") == 0)
+		invertY = calibrationSetting;
+	else if (strcmp(attr->attr.name, "lastPUCoordX") == 0)
+		lastPUCoordX = calibrationSetting;
+	else if (strcmp(attr->attr.name, "lastPUCoordY") == 0)
+		lastPUCoordY = calibrationSetting;
+
+	return count;
+}
+
+/* Defines sysfs variable associations */
+static struct kobj_attribute minX_attribute =
+    __ATTR(minX, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute maxX_attribute =
+    __ATTR(maxX, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute minY_attribute =
+    __ATTR(minY, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute maxY_attribute =
+    __ATTR(maxY, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute swapAxes_attribute =
+    __ATTR(swapAxes, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute invertX_attribute =
+    __ATTR(invertX, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute invertY_attribute =
+    __ATTR(invertY, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute lastPUCoordX_attribute =
+    __ATTR(lastPUCoordX, 0660, calibrationSettings_show, calibrationSettings_store);
+static struct kobj_attribute lastPUCoordY_attribute =
+    __ATTR(lastPUCoordY, 0660, calibrationSettings_show, calibrationSettings_store);
+
+/*
+ * Create a group of calibration attributes so we may work with them
+ * as a set.
+ */
+static struct attribute *attrs[] = {
+	&commandDataPending_attribute.attr,
+	&commandMode_attribute.attr,
+	&receiveBuffer_attribute.attr,
+	&sendBuffer_attribute.attr,
+	&minX_attribute.attr,
+	&maxX_attribute.attr,
+	&minY_attribute.attr,
+	&maxY_attribute.attr,
+	&swapAxes_attribute.attr,
+	&invertX_attribute.attr,
+	&invertY_attribute.attr,
+	&lastPUCoordX_attribute.attr,
+	&lastPUCoordY_attribute.attr,
+	NULL,
+};
+
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static struct kobject *ar1020_kobj;
+
+static irqreturn_t touch_irq_handler_func(int irq, void *dev_id);
+
+/******************************************************************************
+Function:
+	decodeAR1020Packet()
+
+Description:
+	Decode packets of data from a device path using AR1XXX protocol.
+	Returns 1 if a full packet is available, zero otherwise.
+******************************************************************************/
+int decodeAR1020Packet(struct ar1020_i2c_priv* priv, char* packet, int *index, char data)
+{
+	int returnValue=0;
+	int x;
+	int y;
+	int button;
+	int calX;
+	int calY;
+
+	packet[*index] = data;
+
+	/****************************************************
+
+	Data format, 5 bytes: SYNC, DATA1, DATA2, DATA3, DATA4
+
+	SYNC [7:0]: 1,0,0,0,0,TOUCHSTATUS[0:0]
+	DATA1[7:0]: 0,X-LOW[6:0]
+	DATA2[7:0]: 0,X-HIGH[4:0]
+	DATA3[7:0]: 0,Y-LOW[6:0]
+	DATA4[7:0]: 0,Y-HIGH[4:0]
+
+	TOUCHSTATUS: 0 = Touch up, 1 = Touch down
+
+	****************************************************/
+
+	switch ((*index)) {
+		case 0:
+			if (!(0x80 & data))
+			{
+			    /* Sync bit not set */
+			    returnValue=-1;
+			}
+			break;
+
+		case (MCHIP_MAX_LENGTH - 1):
+			/* verify byte is valid for current index */
+			if (0x80 & data)
+			{
+				/* byte not valid */
+				break;
+			}
+
+			x = ((packet[2] & 0x1f) << 7) | (packet[1] & 0x7f);
+			y= ((packet[4] & 0x1f) << 7) | (packet[3] & 0x7f);
+			button = 0 != (packet[0] & 1);
+
+
+			if (0==button)
+			{
+				lastPUCoordX=x;
+				lastPUCoordY=y;
+			}
+
+			if (swapAxes)
+			{
+				int temp=x;
+				x=y;
+				y=temp;
+			}
+
+
+			if (invertX)
+				x=4095-x;
+
+			if (invertY)
+				y=4095-y;
+
+
+			if (x<minX)
+				calX=0;
+			else if (x>maxX)
+				calX=4095;
+			else
+				/* percentage across calibration area times the maximum controller width */
+				calX=((x-minX)*4095)/(maxX-minX);
+
+			if (y<minY)
+				calY=0;
+			else if (y>maxY)
+				calY=4095;
+			else
+				/* percentage across calibration area times the maximum controller height */
+				calY=((y-minY)*4095)/(maxY-minY);
+
+			// printk(KERN_DEBUG "AR1020 I2C: %d %d %d\n",calX,calY,button);
+
+
+            if(button != lastButton) {
+                input_report_key(priv->input, BTN_TOUCH, button);
+                if(button)
+                    input_report_abs(priv->input, ABS_PRESSURE, 15000);
+                else
+                    input_report_abs(priv->input, ABS_PRESSURE, 0);
+                lastButton = button;
+            }
+
+            input_report_abs(priv->input, ABS_PRESSURE, 15000);
+            input_report_abs(priv->input, ABS_X, calX);
+            input_report_abs(priv->input, ABS_Y, calY);
+			input_sync(priv->input);
+
+			returnValue=1;
+			break;
+		default:
+			/* verify byte is valid for current index */
+			if (0x80 & data)
+			{
+				/* byte not valid */
+				// printk("AR1020 I2C: Touch byte not valid.  Value: 0x%02x Index: 0x%02x\n",data, *index);
+			}
+			break;
+
+	}
+
+	return returnValue;
+}
+
+/******************************************************************************
+Function:
+	ar1020_i2c_open()
+
+Description:
+	This function is called on every attempt to open the current device
+	and used for both debugging purposes fullfilling an I2C driver
+	function callback requirement.
+******************************************************************************/
+static int ar1020_i2c_open(struct input_dev *dev)
+{
+	return 0;
+}
+
+/******************************************************************************
+Function:
+	ar1020_i2c_close()
+
+Description:
+	This function is called on every attempt to close the current device
+	and used for both debugging purposes fullfilling an I2C driver
+	function callback requirement.
+******************************************************************************/
+static void ar1020_i2c_close(struct input_dev *dev)
+{
+}
+
+/******************************************************************************
+Function:
+	test_irq_handler_func()
+
+Description:
+	Testing to see if IRQ line of controller attached to an available
+	IO line on board.
+******************************************************************************/
+static irqreturn_t test_irq_handler_func(int irq, void *dev_id)
+{
+	struct ar1020_i2c_priv *priv = (struct ar1020_i2c_priv *)dev_id;
+	int err;
+
+	if (!priv) {
+        printk(KERN_ERR "AR1020 I2C:touch_irq_handler_funct: no private data\n");
+		err = -EINVAL;
+		return err;
+	}
+
+	priv->testCount++;
+
+	return IRQ_NONE;
+}
+
+/******************************************************************************
+Function:
+	ar1020_i2c_readdata()
+
+Description:
+	When the controller interrupt is asserted, this function is scheduled
+	to be called to read the controller data within the
+	touch_irq_handler_func() function.
+******************************************************************************/
+static void ar1020_i2c_readdata(struct work_struct *work)
+{
+	struct ar1020_i2c_priv *priv =
+		container_of(work, struct ar1020_i2c_priv, work);
+	int i;
+	char buff[9];
+
+	/* We want to ensure we only read packets when we are not in the middle of command communication. Disable command mode after receiving command response to resume receiving packets. */
+	if (commandMode)
+	{
+		commandDataPending=1;
+		/* process up to 9 bytes */
+		strcpy(receiveBuffer,"");
+
+		i2c_master_recv (priv->client,buff,9);
+		snprintf(receiveBuffer,sizeof(receiveBuffer),"0x%02x",0xff&buff[0]);
+
+		if (0x55 != buff[0])
+		{
+			// printk("AR1020 I2C: invalid header byte\n");
+		}
+
+		snprintf(receiveBuffer,sizeof(receiveBuffer),"%s 0x%02x",receiveBuffer,0xff&buff[1]);
+		if (buff[1] > 6)
+		{
+			// printk("AR1020 I2C: invalid byte count\n");
+		}
+
+		for (i=0;i<7;i++)
+		{
+			snprintf(receiveBuffer,sizeof(receiveBuffer),"%s 0x%02x",receiveBuffer,0xff&buff[i+2]);
+		}
+
+		if (buff[1]<7)
+		{
+			/* if command response has valid length, reformat the response */
+			strcpy(receiveBuffer,"");
+			for (i=0;i<buff[1]+2;i++)
+			{
+				snprintf(receiveBuffer,sizeof(receiveBuffer),"%s 0x%02x",receiveBuffer,0xff&buff[i]);
+			}
+
+		}
+
+		snprintf(receiveBuffer,sizeof(receiveBuffer),"%s\n",receiveBuffer);
+		// printk(KERN_DEBUG "AR1020 I2C: command response: %s",receiveBuffer);
+		return;
+	}
+
+
+
+	for (i=0;i<5;i++)
+	{
+	  buff[i]=0;
+	}
+
+	i2c_master_recv (priv->client,buff,5);
+	for (i=0;i<5;i++)
+	{
+	  decodeAR1020Packet(priv,buff, &i, buff[i]);
+	}
+
+}
+
+
+
+
+/******************************************************************************
+Function:
+	ar1020_i2c_probe()
+
+Description:
+	After the kernel's platform specific source files have been modified to
+	reference the "ar1020_i2c" driver, this function will then be called.
+	This function needs to be called to finish registering the driver.
+******************************************************************************/
+//static int __devinit ar1020_i2c_probe(struct i2c_client *client,
+//				      const struct i2c_device_id *id)
+static int  ar1020_i2c_probe(struct i2c_client *client,
+				      const struct i2c_device_id *id)
+{
+	struct ar1020_i2c_priv *priv=NULL;
+	struct input_dev *input_dev=NULL;
+	int err=0;
+	int i;
+	char buff[5];
+	int ret;
+
+        // printk("AR1020 I2C: ar1020_i2c_probe: begin\n");
+
+	for (i=0;i<5;i++)
+	{
+		buff[i]=0;
+	}
+
+	if (!client) {
+        printk(KERN_ERR "AR1020 I2C: client pointer is NULL\n");
+		err = -EINVAL;
+		goto error;
+	}
+
+    if (gpio_request(GPIO_ANY_GPIO, GPIO_ANY_GPIO_DESC)) {
+       // printk("GPIO request faiure: %s\n", GPIO_ANY_GPIO_DESC);
+       goto error;
+    }
+
+    gpio_direction_input(GPIO_ANY_GPIO);
+
+    ret = gpio_to_irq(GPIO_ANY_GPIO);
+    if(ret > 0) {
+        client->irq = ret;
+    }
+    else {
+        printk(KERN_ERR "AR1020 I2C: can not get IRQ for interrupt GPIO set for touch controller\n");
+        err = -EINVAL;
+        goto error;
+    }
+
+	if ((!client->irq) && (touchIRQ == -1) && (!testI2Cdata) && (!probeForIRQ)) {
+        printk(KERN_ERR "AR1020 I2C: no IRQ set for touch controller\n");
+		err = -EINVAL;
+		goto error;
+	}
+
+    swapAxes = (lcdpi_touchparams & 0x04) >> 2;
+    invertX = (lcdpi_touchparams & 0x02) >> 1;
+    invertY = (lcdpi_touchparams & 0x01);
+
+
+	priv = kzalloc(sizeof(struct ar1020_i2c_priv), GFP_KERNEL);
+	input_dev = input_allocate_device();
+	if (!priv) {
+		// printk(KERN_ERR "AR1020 I2C: kzalloc error\n");
+		err = -ENOMEM;
+		goto error;
+	}
+
+	/* Backup pointer so sysfs helper functions may also have access to private data */
+	privRef=priv;
+
+	if (!input_dev)
+	{
+		// printk(KERN_ERR "AR1020 I2C: input allocate error\n");
+		err = -ENOMEM;
+		goto error;
+	}
+
+	priv->client = client;
+	priv->irq = client->irq;
+	priv->input = input_dev;
+
+	/* Verify raw I2C data stream to ensure bus is setup correctly in the platform settings. */
+	if (testI2Cdata)
+	{
+		// printk("AR1020 I2C: In testing mode to verify packet data.  To inhibit this mode,\n");
+		// printk("unset the \"testI2Cdata\" kernel parameter.\n");
+		while (1)
+		{
+			i2c_master_recv (priv->client,buff,5);
+
+			/* A zero byte for first byte usually means there */
+			/* is no data available in controller buffer. */
+			if (0==buff[0])
+			{
+				continue;
+			}
+
+			for (i=0;i<5;i++)
+			{
+				// printk("0x%x ",buff[i]);
+
+			}
+			// printk("\n");
+
+			if (!(0x80 & buff[0]) && (0x00 != buff[1]))
+			{
+				// printk("AR1020 I2C: Missing sync bit.\n");
+			}
+		}
+
+	}
+
+	/* Detect IRQ id that controller IRQ line is attached to.  This detection only works
+	   if the controller's IRQ line is attached to a GPIO line configured as an input.
+	   These lines are often marked as EINT (external interrupt) on the board schematic.
+	   This probe assumes that I2C read communication with the controller is working
+	   correctly.
+	*/
+	if (probeForIRQ)
+	{
+		// printk("AR1020 I2C: Probing for interrupt id.\n");
+		// printk("AR1020 I2C: Please touch screen before IRQ probe for successful detection.\n");
+		// printk("AR1020 I2C: Probing will commence in five seconds.\n\n");
+		// printk("AR1020 I2C: Kernel exception messages may appear during the\n");
+		// printk("AR1020 I2C: probing process.\n");
+
+		msleep(5000);
+
+		for (i=probeMin;i<probeMax;i++)
+		{
+			// printk("AR1020 I2C: Testing IRQ %d\n",i);
+			priv->irq=i;
+
+			/* set type on new handler and register gpio pin as our interrupt */
+			irq_set_irq_type(i, IRQ_TYPE_EDGE_RISING);
+			if (0 >= (ret=request_irq(i, test_irq_handler_func, 0, "AR1020 IRQ", priv)))
+			{
+				priv->testCount=0;
+
+				/* read I2C data to ensure IRQ lines is not asserted */
+				i2c_master_recv (priv->client,buff,5);
+
+				msleep(1000);
+				if (ret>=0)
+				{
+					free_irq(i, priv);
+				}
+
+				/* successful detection if count within this range */
+				if ((priv->testCount > 0) && (priv->testCount < 3))
+				{
+					// printk("AR1020 I2C: Touch IRQ detected at ID: %d.\n",i);
+					priv->irq=i;
+					break;
+				}
+			}
+			else
+			{
+				// printk("AR1020 I2C: IRQ %d not available.\n", i);
+			}
+		}
+		if (i==probeMax)
+		{
+			// printk("AR1020 I2C: Touch IRQ not detected. Using IRQ %d.\n",priv->irq);
+        }
+
+	}
+	/* Use default settings */
+	else if (touchIRQ == -1)
+	{
+		// printk("AR1020 I2C: Using IRQ %d set via board's platform setting.\n", priv->irq);
+	}
+	else
+	{
+		// printk("AR1020 I2C: Using IRQ %d set via kernel parameter.\n", touchIRQ);
+		priv->irq=touchIRQ;
+	}
+
+	INIT_WORK(&priv->work, ar1020_i2c_readdata);
+
+	input_dev->name = "AR1020 Touchscreen";
+	input_dev->id.bustype = BUS_I2C;
+
+	input_dev->open = ar1020_i2c_open;
+	input_dev->close = ar1020_i2c_close;
+
+	input_dev->evbit[0] = BIT_MASK(EV_KEY) | BIT_MASK(EV_ABS);
+	input_dev->keybit[BIT_WORD(BTN_TOUCH)] = BIT_MASK(BTN_TOUCH);
+
+	input_set_abs_params(input_dev, ABS_X, 0, 4095, 0, 0);
+	input_set_abs_params(input_dev, ABS_Y, 0, 4095, 0, 0);
+    input_set_abs_params(input_dev, ABS_PRESSURE, 0, 15000, 0, 0);
+	err = input_register_device(input_dev);
+	if (err)
+	{
+		// printk(KERN_ERR "AR1020 I2C: error registering input device\n");
+		goto error;
+	}
+
+	/* set type and register gpio pin as our interrupt */
+	irq_set_irq_type(priv->irq, IRQ_TYPE_EDGE_RISING);
+	err = request_irq(priv->irq, touch_irq_handler_func, 0, "AR1020 I2C IRQ", priv);
+
+	i2c_set_clientdata(client, priv);
+
+	return 0;
+
+ error:
+
+	if (input_dev)
+		input_free_device(input_dev);
+
+	if (priv)
+		kfree(priv);
+
+	return err;
+
+}
+
+/******************************************************************************
+Function:
+	ar1020_i2c_remove()
+
+Description:
+	Unregister/remove the kernel driver from memory.
+******************************************************************************/
+static int ar1020_i2c_remove(struct i2c_client *client)
+{
+	struct ar1020_i2c_priv *priv = (struct ar1020_i2c_priv *)i2c_get_clientdata(client);
+
+    gpio_free(GPIO_ANY_GPIO);
+    free_irq(priv->irq, priv);
+	input_unregister_device(priv->input);
+	kfree(priv);
+
+	return 0;
+}
+
+/* This structure describe a list of supported slave chips */
+static const struct i2c_device_id ar1020_i2c_id[] = {
+	{ "ar1020_i2c", 0 },
+	{ }
+};
+
+/******************************************************************************
+Function:
+	touch_irq_handler_func()
+
+Description:
+	After the interrupt is asserted for the controller, this
+	is the first function that is called.  Since this is a time sensitive
+	function, we need to immediately schedule work so the integrity of
+	properly system operation
+
+	This function needs to be called to finish registering the driver.
+******************************************************************************/
+static irqreturn_t touch_irq_handler_func(int irq, void *dev_id)
+{
+	struct ar1020_i2c_priv *priv = (struct ar1020_i2c_priv *)dev_id;
+	char buff[5];
+	int i;
+	int err;
+	for (i=0;i<5;i++)
+	{
+		buff[i]=0;
+	}
+
+	// printk(KERN_NOTICE "AR1020 I2C: Interrupt Service rutine\n");
+
+	if (!priv) {
+        printk(KERN_ERR "AR1020 I2C: touch_irq_handler_funct: no private data\n");
+		err = -EINVAL;
+		return err;
+	}
+
+	 /* delegate I2C transactions since hardware interupts need to be handled very fast */
+	schedule_work(&priv->work);
+
+	return IRQ_HANDLED;
+}
+
+static const struct of_device_id ar1020_dt_ids[] = {
+    { .compatible = "microchip,ar10204d" },
+    {},
+};
+
+MODULE_DEVICE_TABLE(of, ar1020_dt_ids);
+
+
+/* This is the initial set of information information the kernel has
+   before probing drivers on the system, */
+static struct i2c_driver ar1020_i2c_driver = {
+	.driver = {
+		.name	= "ar1020_i2c",
+        .of_match_table = of_match_ptr(ar1020_dt_ids),
+	},
+	.probe		= ar1020_i2c_probe,
+	.remove		= ar1020_i2c_remove,
+	/* suspend/resume functions not needed since controller automatically
+	   put's itself to sleep mode after configurable short period of time */
+    //.suspend	= NULL,
+    //.resume		= NULL,
+	.id_table	= ar1020_i2c_id,
+};
+
+
+
+/****************************************************************************/
+/* This function configures interrupts.                                     */
+/****************************************************************************/
+void r_int_config(void) {
+
+   if (gpio_request(GPIO_ANY_GPIO, GPIO_ANY_GPIO_DESC)) {
+      // printk("GPIO request faiure: %s\n", GPIO_ANY_GPIO_DESC);
+      return;
+   }
+
+   gpio_direction_input(GPIO_ANY_GPIO);
+
+//   if ( (irq_any_gpio = gpio_to_irq(GPIO_ANY_GPIO)) < 0 ) {
+   if ( (touchIRQ = gpio_to_irq(GPIO_ANY_GPIO)) < 0 ) {
+      // printk("GPIO to IRQ mapping faiure %s\n", GPIO_ANY_GPIO_DESC);
+      return;
+   }
+
+   //// printk(KERN_NOTICE "Mapped int %d\n", irq_any_gpio);
+   // printk(KERN_NOTICE "Mapped int %d\n", touchIRQ);
+#if 0
+   if (request_irq(touchIRQ,
+                   (irq_handler_t ) touch_irq_handler_func,
+                   IRQF_TRIGGER_RISING,
+                   GPIO_ANY_GPIO_DESC,
+                   GPIO_ANY_GPIO_DEVICE_DESC)) {
+      // printk("Irq Request failure\n");
+      return;
+   }
+#endif
+   return;
+}
+
+
+/****************************************************************************/
+/* This function releases interrupts.                                       */
+/****************************************************************************/
+void r_int_release(void) {
+
+   //free_irq(irq_any_gpio, GPIO_ANY_GPIO_DEVICE_DESC);
+   //free_irq(touchIRQ, GPIO_ANY_GPIO_DEVICE_DESC);
+   gpio_free(GPIO_ANY_GPIO);
+
+   return;
+}
+
+/******************************************************************************
+Function:
+	ar1020_i2c_init()
+
+Description:
+	This function is called during startup even if the platform specific
+	files have not been setup yet.
+******************************************************************************/
+static int __init ar1020_i2c_init(void)
+{
+	int retval;
+        // printk("AR1020 I2C: ar1020_i2c_init: begin\n");
+	strcpy(receiveBuffer,"");
+	strcpy(sendBuffer,"");
+
+	/*
+	 * Creates a kobject "ar1020" that appears as a sub-directory
+	 * under "/sys/kernel".
+	 */
+	ar1020_kobj = kobject_create_and_add("ar1020", kernel_kobj);
+	if (!ar1020_kobj)
+	{
+		// printk(KERN_ERR "AR1020 I2C: cannot create kobject\n");
+		return -ENOMEM;
+	}
+
+	/* Create the files associated with this kobject */
+	retval = sysfs_create_group(ar1020_kobj, &attr_group);
+	if (retval)
+	{
+		// printk(KERN_ERR "AR1020 I2C: error registering ar1020-i2c driver's sysfs interface\n");
+		kobject_put(ar1020_kobj);
+	}
+
+	retval = i2c_add_driver(&ar1020_i2c_driver);
+
+    //r_int_config();
+
+	return retval;
+}
+
+/******************************************************************************
+Function:
+	ar1020_i2c_exit()
+
+Description:
+	This function is called after ar1020_i2c_remove() immediately before
+	being removed from the kernel.
+******************************************************************************/
+static void __exit ar1020_i2c_exit(void)
+{
+
+    //r_int_release();
+	// printk("AR1020 I2C: ar1020_i2c_exit begin\n");
+	kobject_put(ar1020_kobj);
+	i2c_del_driver(&ar1020_i2c_driver);
+}
+
+MODULE_AUTHOR("Steve Grahovac <steve.grahovac@microchip.com>");
+MODULE_DESCRIPTION("AR1020 touchscreen I2C bus driver");
+MODULE_LICENSE("GPL");
+
+/* Enable the ar1020_i2c_init() to be run by the kernel during initialization */
+module_init(ar1020_i2c_init);
+
+/* Enables the ar1020_i2c_exit() to be called during cleanup.  This only
+has an effect if the driver is compiled as a kernel module. */
+module_exit(ar1020_i2c_exit);
+
diff --git a/drivers/video/4d-hats/config_patch.txt b/drivers/video/4d-hats/config_patch.txt
new file mode 100644
index 000000000000..a321be7c57b3
--- /dev/null
+++ b/drivers/video/4d-hats/config_patch.txt
@@ -0,0 +1,31 @@
+--- .config.old	2016-12-29 08:53:46.255170803 +0000
++++ .config	2016-12-29 09:44:36.571044705 +0000
+@@ -3420,11 +3420,11 @@
+ CONFIG_FB_CFB_COPYAREA=y
+ CONFIG_FB_CFB_IMAGEBLIT=y
+ # CONFIG_FB_CFB_REV_PIXELS_IN_BYTE is not set
+-CONFIG_FB_SYS_FILLRECT=m
+-CONFIG_FB_SYS_COPYAREA=m
+-CONFIG_FB_SYS_IMAGEBLIT=m
++CONFIG_FB_SYS_FILLRECT=y
++CONFIG_FB_SYS_COPYAREA=y
++CONFIG_FB_SYS_IMAGEBLIT=y
+ # CONFIG_FB_FOREIGN_ENDIAN is not set
+-CONFIG_FB_SYS_FOPS=m
++CONFIG_FB_SYS_FOPS=y
+ CONFIG_FB_DEFERRED_IO=y
+ # CONFIG_FB_SVGALIB is not set
+ # CONFIG_FB_MACMODES is not set
+@@ -3481,6 +3481,12 @@
+ # CONFIG_VGASTATE is not set
+ CONFIG_VIDEOMODE_HELPERS=y
+ CONFIG_HDMI=y
++CONFIG_4DHATS=y
++CONFIG_FB_HATS=y
++CONFIG_4DPI_SPI_DMA=y
++CONFIG_4DPI_ADS7846=m
++CONFIG_4DPI_AR1020I2C=m
++CONFIG_4DPI_PWMBL=m
+
+ #
+ # Console display driver support
diff --git a/drivers/video/4d-hats/dtc.sh b/drivers/video/4d-hats/dtc.sh
new file mode 100755
index 000000000000..3f72cba7277f
--- /dev/null
+++ b/drivers/video/4d-hats/dtc.sh
@@ -0,0 +1,2 @@
+dtc -@ -I dts -O dtb -o $1.dtb $1.dts
+ls -l $1.dts $1.dtb
diff --git a/drivers/video/4d-hats/pwmbl.c b/drivers/video/4d-hats/pwmbl.c
new file mode 100644
index 000000000000..36567235089f
--- /dev/null
+++ b/drivers/video/4d-hats/pwmbl.c
@@ -0,0 +1,605 @@
+/*
+ * Raspberry Pi speciffic PWM backlight driver for 4D Systems 4DPi display modules
+ * PWM an be controlled by a timer or a chain of DMA transfers
+ * (c) Andrej Strancar 2015
+ *
+ * based gpio_backlight.c driver by Laurent Pinchart
+ *  - added high resolution timer PWM
+ *  - added two versions of DMA-PWM based on pi-blaster driver by Thomas Sarlandie
+ *
+ * gpio_backlight.c - Simple GPIO-controlled backlight
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/version.h>
+#include <linux/backlight.h>
+#include <linux/err.h>
+#include <linux/fb.h>
+#include <linux/gpio.h>
+#include <linux/interrupt.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_data/gpio_backlight.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/dmaengine.h>
+
+#include <linux/hrtimer.h>
+#include <linux/ktime.h>
+
+#include <mach/platform.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+#include <mach/dma.h>
+#else
+#include <linux/platform_data/dma-bcm2708.h>
+#endif
+
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+
+/* macro for bcm2835 peripherals DMA access*/
+#define DMA_PERIPHERAL_ADDRESS(x) ((x) & 0x00ffffff) | 0x7e000000;
+
+#define DMA_DELAY_PWM 0
+#define DMA_DELAY_PCM 1
+
+#define GPIO_LEN		0xb4
+#define DMA_LEN			(0x100 * 15) //0x24
+#define DMA_CHAN_SIZE 0x100
+//#define DMA_LEN			0x24
+#define PWM_BASE		(BCM2708_PERI_BASE + 0x20C000)
+#define PWM_LEN			0x28
+#define CLK_BASE		(BCM2708_PERI_BASE + 0x101000)
+#define CLK_LEN			0xA8
+#define PCM_BASE 		(BCM2708_PERI_BASE + 0x203000)
+#define PCM_LEN			0x24
+
+#define GPFSEL0			(0x00/4)
+#define GPFSEL1			(0x04/4)
+#define GPSET0			(0x1c/4)
+#define GPCLR0			(0x28/4)
+#define GPSET1			(0x20/4)
+#define GPCLR1			(0x2c/4)
+
+#define PWM_CTL			(0x00/4)
+#define PWM_STA			(0x04/4)
+#define PWM_DMAC		(0x08/4)
+#define PWM_RNG1		(0x10/4)
+#define PWM_FIFO		(0x18/4)
+
+#define PWMCLK_CNTL		40
+#define PWMCLK_DIV		41
+
+#define PWMCTL_MODE1	(1<<1)
+#define PWMCTL_PWEN1	(1<<0)
+#define PWMCTL_CLRF		(1<<6)
+#define PWMCTL_USEF1	(1<<5)
+
+#define PWMDMAC_ENAB	(1<<31)
+// I think this means it requests as soon as there is one free slot in the FIFO
+// which is what we want as burst DMA would mess up our timing..
+#define PWMDMAC_THRSHLD	((15<<8)|(15<<0))
+
+#define PCM_CS_A		(0x00/4)
+#define PCM_FIFO_A		(0x04/4)
+#define PCM_MODE_A		(0x08/4)
+#define PCM_RXC_A		(0x0c/4)
+#define PCM_TXC_A		(0x10/4)
+#define PCM_DREQ_A		(0x14/4)
+#define PCM_INTEN_A		(0x18/4)
+#define PCM_INT_STC_A		(0x1c/4)
+#define PCM_GRAY		(0x20/4)
+
+#define PCMCLK_CNTL		38
+#define PCMCLK_DIV		39
+
+#define DMA_CS			(BCM2708_DMA_CS/4)
+#define DMA_CONBLK_AD	(BCM2708_DMA_ADDR/4)
+#define DMA_DEBUG		(BCM2708_DMA_DEBUG/4)
+
+#define BCM2708_DMA_END				(1<<1)	// Why is this not in mach/dma.h ?
+#define BCM2708_DMA_NO_WIDE_BURSTS	(1<<26)
+
+#define BLANK		1
+#define UNBLANK		0
+
+struct gpio_backlight {
+    struct device *dev;
+    struct device *fbdev;
+
+    int gpio;
+    int active;
+};
+
+struct bl_trig_notifier {
+    int brightness;
+    int old_status;
+    struct notifier_block notifier;
+    unsigned invert;
+};
+
+struct ctldata_s {
+    struct bcm2708_dma_cb cb[4];	// gpio-hi, delay, gpio-lo, delay, for each servo output
+    uint32_t gpiodata;				// set-pin, clear-pin values, per servo output
+    uint32_t pwmdata;				// the word we write to the pwm fifo
+};
+
+struct {
+    void *buf;
+    dma_addr_t dma;
+} ctl_page;
+
+static volatile uint32_t *gpio_reg;
+static volatile uint32_t *dma_reg;
+void __iomem *dma_chan_base;
+int dma_chan;
+int dma_irq;
+static volatile uint32_t *clk_reg;
+static volatile uint32_t *pwm_reg;
+static volatile uint32_t *pcm_reg;
+
+struct backlight_device *bl;
+u8 cnt;
+
+u8 gpios_set_regs[] = {GPSET0, GPSET1};
+u8 gpios_clr_regs[] = {GPCLR0, GPCLR1};
+
+static struct ctldata_s *ctl, *ctl_dma;
+static int cycle_ticks = 2000;
+static int tick_scale = 6;
+
+unsigned long timer_interval_ns = 100000;
+static struct hrtimer hr_timer;
+
+static ushort pwmbl_brightness = 100;
+static const char *pwmbl_title;
+
+static int pwm_stopped = 0;
+
+/* module parameters */
+static ushort pwm = 2;
+module_param(pwm, ushort, 0444);
+MODULE_PARM_DESC(pwm, "backlight PWM type: 0-soft_PWM, 1-DMA_PWM, 2-DMA_PCM");
+
+static ushort gpio = 22;
+module_param(gpio, ushort, 0444);
+MODULE_PARM_DESC(gpio, "GPIO used for PWM: 0-63");
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0))
+static ushort dma_channel = 14;
+module_param(dma_channel, ushort, 0444);
+MODULE_PARM_DESC(dma_channel, "DMA channel for DMA based pwm (0-14)");
+#endif
+static int gpio_backlight_update_status(struct backlight_device *bl) {
+    struct gpio_backlight *gbl = bl_get_data(bl);
+    int brightness = bl->props.brightness;
+    ktime_t ktime;
+
+//	printk("blank=%d\n", bl->props.fb_blank);
+//	if (bl->props.power != FB_BLANK_UNBLANK
+//			|| bl->props.fb_blank != FB_BLANK_UNBLANK
+//			|| bl->props.state & (BL_CORE_SUSPENDED | BL_CORE_FBBLANK))
+    if(bl->props.fb_blank != 0)
+        brightness = 0;
+
+    if (!pwm) {  // software PWM
+        switch(brightness) {
+        case 100:
+        case 0:
+            mdelay(20); // wait for the timer to stop
+            gpio_set_value(gbl->gpio, brightness ? gbl->active : !gbl->active);
+            pwm_stopped = 1;
+            break;
+
+        default:
+            if(pwm_stopped) {
+                pwm_stopped = 0;
+                ktime = ktime_set( 0, timer_interval_ns );
+                hrtimer_start( &hr_timer, ktime, HRTIMER_MODE_REL );
+            }
+            break;
+        }
+    } else { 		// HW PWM
+        switch(brightness) {
+        case 100:
+            gpio_set_value(gbl->gpio, brightness ? gbl->active : !gbl->active);
+            ctl->cb[0].next = 0;
+            pwm_stopped = 1;
+            break;
+
+        case 0:
+            gpio_set_value(gbl->gpio, brightness ? gbl->active : !gbl->active);
+            ctl->cb[3].next = 0;
+            pwm_stopped = 1;
+            break;
+
+        default:
+            if(pwm_stopped) {
+                pwm_stopped = 0;
+                ctl->cb[0].next = (uint32_t)(ctl_dma->cb + 1);
+                ctl->cb[3].next = (uint32_t)(ctl_dma->cb);
+                dma_reg[DMA_CS] = BCM2708_DMA_RESET;
+                udelay(10);
+                dma_reg[DMA_CS] = BCM2708_DMA_INT | BCM2708_DMA_END;
+                dma_reg[DMA_CONBLK_AD] = (uint32_t)(ctl_dma->cb);
+                dma_reg[DMA_DEBUG] = 7; // clear debug error flags
+                udelay(10);
+                dma_reg[DMA_CS] = 0x10880001;	// go, mid priority, wait for outstanding writes
+            }
+        }
+
+        if((brightness !=0) && (brightness != 100)) {
+            switch(pwm) {
+            case 1:	// DMA-PWM
+                // on delay;
+                ctl->cb[1].length = (brightness) * 3;
+                // off delay;
+                ctl->cb[3].length = (100 - brightness ) * 3;
+                break;
+
+            case 2: // DMA-PCM
+                // on delay;
+                ctl->cb[1].length = (brightness) * 5;
+                // off delay;
+                ctl->cb[3].length = (100 - brightness ) * 5;
+                break;
+            }
+        }
+        //printk("%d/%d", ctl->cb[1].length, ctl->cb[3].length)
+    }
+
+    return 0;
+}
+
+static int gpio_backlight_get_brightness(struct backlight_device *bl) {
+    return bl->props.brightness;
+}
+
+static int gpio_backlight_check_fb(struct backlight_device *bl,
+        struct fb_info *info) {
+    struct gpio_backlight *gbl = bl_get_data(bl);
+
+    return gbl->fbdev == NULL || gbl->fbdev == info->dev;
+}
+
+static int fb_notifier_callback(struct notifier_block *p,
+                unsigned long event, void *data)
+{
+    struct fb_event *fb_event = data;
+    int *blank;
+
+//	printk("event= %ld\n", event);¸
+
+    /* If we aren't interested in this event, skip it immediately ... */
+    //if (event != FB_EVENT_BLANK)
+    if((event != FB_EVENT_CONBLANK) && (event != FB_EARLY_EVENT_BLANK) && (event != FB_R_EARLY_EVENT_BLANK))
+        return 0;
+
+    blank = fb_event->data;
+    bl->props.fb_blank = *blank;
+    gpio_backlight_update_status(bl);
+
+    return notifier_from_errno(0);
+}
+
+static struct notifier_block nb = { &fb_notifier_callback, NULL, 0 };
+
+#define SAMPLE_US 10
+
+int init_dma_pwm(struct platform_device *pdev, u8 delay_hw)
+{
+    int ret;
+
+    ctl_page.buf = dma_alloc_coherent(&pdev->dev, 4096, &ctl_page.dma, GFP_DMA);
+
+    ctl = (struct ctldata_s *)ctl_page.buf;
+    ctl_dma = (struct ctldata_s *)ctl_page.dma;
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0))
+    /* register DMA channel */
+    ret = bcm_dma_chan_alloc(BCM_DMA_FEATURE_NORMAL_ORD, &dma_chan_base, &dma_irq);
+    if (ret < 0) {
+        printk("couldn't allocate a DMA channel\n");
+        //return ret;
+    }
+    dma_chan = ret;
+    printk("DMA channel %d at address 0x%08lx with irq %d\n",
+                          dma_chan, (unsigned long)dma_chan_base, dma_irq);
+#else
+    dma_chan = dma_channel;
+    dev_info(&pdev->dev, "Using DMA channel %d\n",
+         dma_chan);
+#endif
+
+    gpio_reg = (uint32_t *)ioremap(GPIO_BASE, GPIO_LEN);
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0))
+    dma_reg = (uint32_t *)dma_chan_base;
+#else
+    dma_reg  = (uint32_t *)ioremap(DMA_BASE,  DMA_LEN) + dma_chan * (DMA_CHAN_SIZE / sizeof(dma_reg));
+#endif
+
+    clk_reg  = (uint32_t *)ioremap(CLK_BASE,  CLK_LEN);
+    pwm_reg  = (uint32_t *)ioremap(PWM_BASE,  PWM_LEN);
+    pcm_reg  = (uint32_t *)ioremap(PCM_BASE, PCM_LEN);
+
+    memset(ctl, 0, sizeof(*ctl));
+
+    // Build the DMA CB chain
+    // Set gpio high
+    ctl->gpiodata = 1 << (gpio % 32);
+
+    ctl->cb[0].info   = BCM2708_DMA_NO_WIDE_BURSTS | BCM2708_DMA_WAIT_RESP;
+    ctl->cb[0].src    = (uint32_t)(&ctl_dma->gpiodata);
+    ctl->cb[0].dst    = DMA_PERIPHERAL_ADDRESS(GPIO_BASE + gpios_set_regs[gpio / 32]*4);
+    ctl->cb[0].length = sizeof(uint32_t);
+    ctl->cb[0].stride = 0;
+    ctl->cb[0].next = (uint32_t)(ctl_dma->cb + 1);
+
+    // delay
+    ctl->cb[1].src    = (uint32_t)(&ctl_dma->pwmdata);
+    if(delay_hw == DMA_DELAY_PCM) {	// PCM DELAY
+        ctl->cb[1].info   = BCM2708_DMA_NO_WIDE_BURSTS | BCM2708_DMA_WAIT_RESP | BCM2708_DMA_D_DREQ | BCM2708_DMA_PER_MAP(2);
+         ctl->cb[1].dst    = DMA_PERIPHERAL_ADDRESS(PCM_BASE + PCM_FIFO_A*4);
+    } else { 			// PWM DELAY
+        ctl->cb[1].info   = BCM2708_DMA_NO_WIDE_BURSTS | BCM2708_DMA_WAIT_RESP | BCM2708_DMA_D_DREQ | BCM2708_DMA_PER_MAP(5);
+        ctl->cb[1].dst    = DMA_PERIPHERAL_ADDRESS(PWM_BASE + PWM_FIFO*4);
+    }
+    ctl->cb[1].length = sizeof(uint32_t) * (cycle_ticks / 8 - 1);
+    ctl->cb[1].stride = 0;
+    ctl->cb[1].next = (uint32_t)(ctl_dma->cb + 2);
+
+    // Set gpio lo
+    ctl->cb[2].info   = BCM2708_DMA_NO_WIDE_BURSTS | BCM2708_DMA_WAIT_RESP;
+    ctl->cb[2].src    = (uint32_t)(&ctl->gpiodata) & 0x7fffffff;
+    ctl->cb[2].dst    = DMA_PERIPHERAL_ADDRESS(GPIO_BASE + gpios_clr_regs[gpio / 32]*4);
+    ctl->cb[2].length = sizeof(uint32_t);
+    ctl->cb[2].stride = 0;
+    ctl->cb[2].next = (uint32_t)(ctl_dma->cb + 3);
+
+    // delay
+    ctl->cb[3].src    = (uint32_t)(&ctl_dma->pwmdata);
+    if(delay_hw == DMA_DELAY_PCM) {	// PCM DELAY
+        ctl->cb[3].info   = BCM2708_DMA_NO_WIDE_BURSTS | BCM2708_DMA_WAIT_RESP | BCM2708_DMA_D_DREQ | BCM2708_DMA_PER_MAP(2);
+        ctl->cb[3].dst    = DMA_PERIPHERAL_ADDRESS(PCM_BASE + PCM_FIFO_A*4);
+    } else { 			// PWM DELAY
+        ctl->cb[3].info   = BCM2708_DMA_NO_WIDE_BURSTS | BCM2708_DMA_WAIT_RESP | BCM2708_DMA_D_DREQ | BCM2708_DMA_PER_MAP(5);
+        ctl->cb[3].dst    = DMA_PERIPHERAL_ADDRESS(PWM_BASE + PWM_FIFO*4);
+    }
+    ctl->cb[3].length = sizeof(uint32_t) * (cycle_ticks / 8 - 1);
+    ctl->cb[3].stride = 0;
+    // Point last cb back to first one so it loops continuously
+    ctl->cb[3].next = (uint32_t)(ctl_dma->cb);
+
+
+    if(delay_hw == DMA_DELAY_PWM ) {	// Initialise PWM
+        pwm_reg[PWM_CTL] = 0;
+        udelay(10);
+        clk_reg[PWMCLK_CNTL] = 0x5A000006;		// Source=PLLD (500MHz)
+        udelay(100);
+        clk_reg[PWMCLK_DIV] = 0x5A000000 | (500<<12);	// set pwm div to 500, giving 1MHz
+        udelay(100);
+        clk_reg[PWMCLK_CNTL] = 0x5A000016;		// Source=PLLD and enable
+        udelay(100);
+        pwm_reg[PWM_RNG1] = SAMPLE_US * 10;
+        udelay(10);
+        pwm_reg[PWM_DMAC] = PWMDMAC_ENAB | PWMDMAC_THRSHLD;
+        udelay(10);
+        pwm_reg[PWM_CTL] = PWMCTL_CLRF;
+        udelay(10);
+        pwm_reg[PWM_CTL] = PWMCTL_USEF1 | PWMCTL_PWEN1;
+    } else { // Initialise PCM
+        pcm_reg[PCM_CS_A] = 1;				// Disable Rx+Tx, Enable PCM block
+        udelay(100);
+        clk_reg[PCMCLK_CNTL] = 0x5A000006;		// Source=PLLD (500MHz)
+        udelay(100);
+        clk_reg[PCMCLK_DIV] = 0x5A000000 | (500<<12);	// Set pcm div to 500, giving 1MHz
+        udelay(100);
+        clk_reg[PCMCLK_CNTL] = 0x5A000016;		// Source=PLLD and enable
+        udelay(100);
+
+        pcm_reg[PCM_TXC_A] = 0<<31 | 1<<30 | 0<<20 | 0<<16; // 1 channel, 8 bits
+        udelay(100);
+        pcm_reg[PCM_MODE_A] = (tick_scale * 10 - 1) << 10;
+        udelay(100);
+        pcm_reg[PCM_CS_A] |= 1<<4 | 1<<3;		// Clear FIFOs
+        udelay(100);
+        pcm_reg[PCM_DREQ_A] = 64<<24 | 64<<8;		// DMA Req when one slot is free?
+        udelay(100);
+        pcm_reg[PCM_CS_A] |= 1<<9;			// Enable DMA
+        udelay(100);
+        pcm_reg[PCM_CS_A] |= 1 << 2;
+    }
+
+    // Initialise the DMA
+    dma_reg[DMA_CS] = BCM2708_DMA_RESET;
+    udelay(10);
+    dma_reg[DMA_CS] = BCM2708_DMA_INT | BCM2708_DMA_END;
+    //dma_reg[DMA_CONBLK_AD] = (uint32_t)(ctl_dma->cb);
+    dma_reg[DMA_DEBUG] = 7; // clear debug error flags
+    udelay(10);
+    dma_reg[DMA_CS] = 0x10880001;	// go, mid priority, wait for outstanding writes
+
+    return 0;
+}
+
+enum hrtimer_restart timer_callback( struct hrtimer *timer_for_restart )
+{
+    ktime_t currtime , interval;
+    int brightness = bl->props.brightness;
+
+    if(bl->props.fb_blank != 0)
+        brightness = 0;
+
+    currtime  = ktime_get();
+    interval = ktime_set(0,timer_interval_ns);
+    gpio_set_value(40,(cnt++ & 1));
+    if(cnt & 1)
+        interval = ktime_set(0, (100 - brightness) * timer_interval_ns);
+    else
+        interval = ktime_set(0, brightness * timer_interval_ns);
+
+    hrtimer_forward(timer_for_restart, currtime, interval);
+
+    if((brightness != 0) && (brightness != 100))
+        return HRTIMER_RESTART;
+
+    return HRTIMER_NORESTART;
+}
+
+static int timer_init(void) {
+    ktime_t ktime;
+    ktime = ktime_set( 0, timer_interval_ns );
+    hrtimer_init( &hr_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL );
+    hr_timer.function = &timer_callback;
+    hrtimer_start( &hr_timer, ktime, HRTIMER_MODE_REL );
+    return 0;
+}
+
+static const struct backlight_ops gpio_backlight_ops = { .options =
+        BL_CORE_SUSPENDRESUME, .update_status = gpio_backlight_update_status,
+        .get_brightness = gpio_backlight_get_brightness, .check_fb =
+                gpio_backlight_check_fb, };
+
+static int gpio_backlight_parse_dt(struct device *dev)
+{
+    struct device_node *node = dev->of_node;
+
+    if(!node)
+        return -1;
+
+    of_property_read_u16(node, "4d,pwmbl-gpio", (u16*)&gpio);
+    of_property_read_u16(node, "4d,pwmbl-type", (u16*)&pwm);
+    of_property_read_u16(node, "4d,pwmbl-brightness", (u16*)&pwmbl_brightness);
+    of_property_read_string(node, "4d,pwmbl-title", &pwmbl_title);
+
+    return 0;
+}
+
+static int gpio_backlight_probe(struct platform_device *pdev) {
+        struct backlight_properties props = { 100, 100, };
+        struct gpio_backlight *gbl;
+        int ret;
+
+        gpio_backlight_parse_dt(&pdev->dev);
+
+        gbl = devm_kzalloc(&pdev->dev, sizeof(*gbl), GFP_KERNEL);
+        if (gbl == NULL)
+            return -ENOMEM;
+
+        gbl->dev = &pdev->dev;
+        gbl->fbdev = NULL;
+        gbl->gpio = gpio;
+        gbl->active = 1;
+
+        ret = devm_gpio_request_one(gbl->dev, gbl->gpio,
+                GPIOF_DIR_OUT | (gbl->active ? GPIOF_INIT_HIGH : GPIOF_INIT_LOW),
+                "gpio-backlight");
+        if (ret < 0) {
+            dev_err(&pdev->dev, "unable to request GPIO\n");
+            return ret;
+        }
+
+        props.type = BACKLIGHT_RAW;
+        props.power = FB_BLANK_POWERDOWN;
+        props.brightness = 10;
+
+        if(pwmbl_title)
+            bl = backlight_device_register(pwmbl_title, &pdev->dev, gbl, &gpio_backlight_ops, &props);
+        else
+            bl = backlight_device_register(dev_name(&pdev->dev), &pdev->dev, gbl, &gpio_backlight_ops, &props);
+
+        if (IS_ERR(bl)) {
+            dev_err(&pdev->dev, "failed to register backlight\n");
+            return PTR_ERR(bl);
+        }
+
+    switch(pwm) {
+    case 0:
+        timer_init();
+        break;
+
+    case 1:
+        init_dma_pwm(pdev, DMA_DELAY_PWM);
+        gpio_set_value(gbl->gpio, gbl->active);
+        ctl->cb[0].next = 0;
+        pwm_stopped = 1;
+        break;
+
+    case 2:
+        init_dma_pwm(pdev, DMA_DELAY_PCM);
+        gpio_set_value(gbl->gpio, gbl->active);
+        ctl->cb[0].next = 0;
+        pwm_stopped = 1;
+        break;
+
+    }
+
+    ret = fb_register_client(&nb);
+    if (ret)
+        dev_err(&pdev->dev, "unable to register backlight trigger\n");
+
+    bl->props.brightness = pwmbl_brightness;
+    backlight_update_status(bl);
+
+    platform_set_drvdata(pdev, bl);
+    return 0;
+}
+
+static int gpio_backlight_remove(struct platform_device *pdev) {
+    struct backlight_device *bl = platform_get_drvdata(pdev);
+    int ret;
+
+    backlight_device_unregister(bl);
+
+    if (pwm) {
+        ctl->cb[0].next = 0;
+        mdelay(200);
+        dma_reg[DMA_CS] = BCM2708_DMA_RESET;
+        pwm_reg[PWM_CTL] = 0;
+        udelay(10);
+        free_pages((unsigned long)ctl, 0);
+
+        if(ctl_page.buf)
+            dma_free_coherent(&pdev->dev, 4096, ctl_page.buf, ctl_page.dma);
+
+        iounmap(gpio_reg);
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,1,0))
+        bcm_dma_chan_free(dma_chan);
+#endif
+        iounmap(clk_reg);
+        iounmap(pwm_reg);
+    } else {
+        hrtimer_cancel( &hr_timer );
+    }
+
+    ret = fb_unregister_client(&nb);
+        if (ret)
+            dev_err(&pdev->dev, "unable to unregister backlight trigger\n");
+
+    return 0;
+}
+
+static const struct of_device_id pwmbl_dt_ids[] = {
+    { .compatible = "4dsystems,dma-pwm" },
+    {},
+};
+
+MODULE_DEVICE_TABLE(of, pwmbl_dt_ids);
+
+static struct platform_driver gpio_backlight_driver = { .driver = { .name =
+        "pwm-backlight", .owner = THIS_MODULE, .of_match_table = of_match_ptr(pwmbl_dt_ids),},
+        .probe = gpio_backlight_probe, .remove = gpio_backlight_remove, };
+
+module_platform_driver( gpio_backlight_driver);
+
+//MODULE_AUTHOR("Laurent Pinchart <laurent.pinchart@ideasonboard.com>");
+MODULE_DESCRIPTION("GPIO-based PWM Backlight Driver");
+MODULE_LICENSE("GPL");
+MODULE_ALIAS("platform:gpio-backlight");
\ No newline at end of file
diff --git a/drivers/video/4d-hats/spi-bcm2708_dma.c b/drivers/video/4d-hats/spi-bcm2708_dma.c
new file mode 100644
index 000000000000..2b05de9cb8a8
--- /dev/null
+++ b/drivers/video/4d-hats/spi-bcm2708_dma.c
@@ -0,0 +1,1030 @@
+/*
+ * Driver for Broadcom BCM2708 SPI Controllers
+ *
+ * Copyright (C) 2012 Chris Boot, Martin Sperl
+ *
+ * This driver is inspired by:
+ * spi-ath79.c, Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
+ * spi-atmel.c, Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
+ */
+
+#include <linux/version.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/spinlock.h>
+#include <linux/clk.h>
+#include <linux/err.h>
+#include <linux/platform_device.h>
+#include <linux/io.h>
+#include <linux/spi/spi.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/log2.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/dma-mapping.h>
+
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0))
+#include <mach/dma.h>
+#else
+#include <linux/platform_data/dma-bcm2708.h>
+#endif
+
+#include <linux/moduleparam.h>
+
+static short mode = 2;
+module_param(mode, short, 0);
+MODULE_PARM_DESC(mode, "Processing mode: 0=polling, 1=interrupt driven, 2=dma (default)");
+
+static bool realtime;
+module_param(realtime, bool, 0);
+MODULE_PARM_DESC(realtime, "Run the driver with realtime priority");
+
+static unsigned debug;
+module_param(debug, uint, 0);
+MODULE_PARM_DESC(debug, "Turn on debug output");
+
+/* removed in 3.13 */
+#ifndef INIT_COMPLETION
+#define INIT_COMPLETION(c) reinit_completion(&c)
+#endif
+
+#undef dev_dbg
+#define dev_dbg(dev, fmt, args...)           \
+do {                                         \
+    if (unlikely(debug > 0))             \
+        dev_info(dev, fmt, ##args);  \
+} while (0)
+
+/* SPI register offsets */
+#define SPI_CS			0x00
+#define SPI_FIFO		0x04
+#define SPI_CLK			0x08
+#define SPI_DLEN		0x0c
+#define SPI_LTOH		0x10
+#define SPI_DC			0x14
+
+/* Bitfields in CS */
+#define SPI_CS_LEN_LONG		0x02000000
+#define SPI_CS_DMA_LEN		0x01000000
+#define SPI_CS_CSPOL2		0x00800000
+#define SPI_CS_CSPOL1		0x00400000
+#define SPI_CS_CSPOL0		0x00200000
+#define SPI_CS_RXF		0x00100000
+#define SPI_CS_RXR		0x00080000
+#define SPI_CS_TXD		0x00040000
+#define SPI_CS_RXD		0x00020000
+#define SPI_CS_DONE		0x00010000
+#define SPI_CS_LEN		0x00002000
+#define SPI_CS_REN		0x00001000
+#define SPI_CS_ADCS		0x00000800
+#define SPI_CS_INTR		0x00000400
+#define SPI_CS_INTD		0x00000200
+#define SPI_CS_DMAEN		0x00000100
+#define SPI_CS_TA		0x00000080
+#define SPI_CS_CSPOL		0x00000040
+#define SPI_CS_CLEAR_RX		0x00000020
+#define SPI_CS_CLEAR_TX		0x00000010
+#define SPI_CS_CPOL		0x00000008
+#define SPI_CS_CPHA		0x00000004
+#define SPI_CS_CS_10		0x00000002
+#define SPI_CS_CS_01		0x00000001
+
+#define SPI_TIMEOUT_MS	150
+
+#define DRV_NAME	"bcm2708_spi"
+
+#define FLAGS_FIRST_TRANSFER 0x01
+#define FLAGS_LAST_TRANSFER  0x02
+
+/* the defines that are missing in arch/arm/mach-bcm2708/include/mach/dma.h */
+/* the Base address for DMA on the (VideoCore) bus */
+#define DMA_SPI_BASE 0x7E204000
+
+/* some offset addresses */
+#ifndef BCM2708_DMA_SADDR
+#define BCM2708_DMA_SADDR 0x0C
+#endif
+#ifndef BCM2708_DMA_DADDR
+#define BCM2708_DMA_DADDR 0x10
+#endif
+#ifndef BCM2708_DMA_TLEN
+#define BCM2708_DMA_TLEN 0x14
+#endif
+/* some flags */
+#ifndef BCM2708_DMA_D_IGNORE
+#define BCM2708_DMA_D_IGNORE (1<<7)
+#endif
+#ifndef BCM2708_DMA_S_IGNORE
+#define BCM2708_DMA_S_IGNORE (1<<11)
+#endif
+
+struct bcm2708_spi_dma {
+    int chan;
+    int irq;
+    void __iomem *base;
+};
+
+struct bcm2708_spi {
+    spinlock_t lock;
+    void __iomem *base;
+    int irq;
+    struct clk *clk;
+    bool stopping;
+
+    struct completion done;
+
+    /* dma buffer structures */
+    struct bcm2708_dma_cb *dma_buffer;
+    dma_addr_t dma_buffer_handle;
+    struct bcm2708_spi_dma dma_tx;
+    struct bcm2708_spi_dma dma_rx;
+
+    /* structures from the transfer buffer needed during the transfer */
+    const char *tx_buf;
+    int tx_len;
+    char *rx_buf;
+    int rx_len;
+    int cs;
+    /* statistics counter */
+    u64 transfers_polling;
+    u64 transfers_irqdriven;
+    u64 transfers_dmadriven;
+};
+
+struct bcm2708_spi_state {
+    u32 cs;
+    u16 cdiv;
+};
+
+/*
+ * This function sets the ALT mode on the SPI pins so that we can use them with
+ * the SPI hardware.
+ *
+ * FIXME: This is a hack. Use pinmux / pinctrl.
+ */
+static void bcm2708_init_pinmode(void)
+{
+#define INP_GPIO(g) *(gpio+((g)/10)) &= ~(7<<(((g)%10)*3))
+#define SET_GPIO_ALT(g, a) *(gpio+(((g)/10))) |= (((a) <= 3 ? (a)+4 : (a) == 4 ? 3 : 2)<<(((g)%10)*3))
+
+#define GPPUD 0x94 /* Pin Pull-up/down Enable */
+#define GPPUDCLK0 0x98 /* Pin Pull-up/down Enable Clock */
+
+    int pin;
+    u32 *gpio = ioremap(GPIO_BASE, SZ_16K);
+
+    /* SPI is on GPIO 7..11 */
+    for (pin = 7; pin <= 11; pin++) {
+        INP_GPIO(pin);		/* set mode to GPIO input first */
+        SET_GPIO_ALT(pin, 0);	/* set mode to ALT 0 */
+    }
+
+    iounmap(gpio);
+
+#undef INP_GPIO
+#undef SET_GPIO_ALT
+}
+
+static inline u32 bcm2708_rd(struct bcm2708_spi *bs, unsigned reg)
+{
+    return readl(bs->base + reg);
+}
+
+static inline void bcm2708_wr(struct bcm2708_spi *bs, unsigned reg, u32 val)
+{
+    writel(val, bs->base + reg);
+}
+
+static int bcm2708_setup_state(struct spi_master *master,
+            struct device *dev, struct bcm2708_spi_state *state,
+            u32 hz, u8 csel, u8 mode, u8 bpw)
+{
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+    int cdiv;
+    unsigned long bus_hz;
+    u32 cs = 0;
+
+    bus_hz = clk_get_rate(bs->clk);
+
+    if (hz >= bus_hz) {
+        cdiv = 2; /* bus_hz / 2 is as fast as we can go */
+    } else if (hz) {
+        cdiv = DIV_ROUND_UP(bus_hz, hz);
+
+        if (cdiv > 65536) {
+            dev_info(dev,
+                "setup: %d Hz too slow, cdiv %u; min %ld Hz\n",
+                hz, cdiv, bus_hz / 65536);
+            return -EINVAL;
+        } else if (cdiv == 65536) {
+            cdiv = 0;
+        } else if (cdiv == 1) {
+            cdiv = 2; /* 1 gets rounded down to 0; == 65536 */
+        }
+    } else {
+        cdiv = 0;
+    }
+
+    switch (bpw) {
+    case 8:
+        break;
+    default:
+        dev_info(dev, "setup: invalid bits_per_word %u (must be 8)\n",
+            bpw);
+        return -EINVAL;
+    }
+
+    if (mode & SPI_CPOL)
+        cs |= SPI_CS_CPOL;
+    if (mode & SPI_CPHA)
+        cs |= SPI_CS_CPHA;
+
+    if (!(mode & SPI_NO_CS)) {
+        if (mode & SPI_CS_HIGH) {
+            cs |= SPI_CS_CSPOL;
+            cs |= SPI_CS_CSPOL0 << csel;
+        }
+        cs |= csel;
+    } else {
+        cs |= SPI_CS_CS_10 | SPI_CS_CS_01;
+    }
+
+    if (state) {
+        state->cs = cs;
+        state->cdiv = cdiv;
+    }
+
+    dev_dbg(dev, "%s(hz=%d, csel=%d, mode=0x%02X, bpw=%d) => "
+        "bus_hz=%lu / cdiv=%u == %lu Hz; cs 0x%08X\n",
+        __func__, hz, csel, mode, bpw, bus_hz, cdiv, bus_hz/cdiv, cs);
+
+    return 0;
+}
+
+static int bcm2708_register_dma(struct platform_device *pdev,
+                struct bcm2708_spi_dma *d,
+                struct bcm2708_dma_cb *dmabuffer,
+                const char *name)
+{
+    int ret;
+
+    /* register DMA channel */
+    ret = bcm_dma_chan_alloc(BCM_DMA_FEATURE_FAST, &d->base, &d->irq);
+    if (ret < 0) {
+        dev_err(&pdev->dev, "couldn't allocate a DMA channel\n");
+        return ret;
+    }
+    d->chan = ret;
+    dev_info(&pdev->dev, "DMA channel %d at address 0x%08lx with irq %d\n",
+        d->chan, (unsigned long)d->base, d->irq);
+    return 0;
+}
+
+static int bcm2708_release_dma(struct platform_device *pdev,
+            struct bcm2708_spi_dma *d)
+{
+    if (!d->base)
+        return 0;
+    bcm_dma_chan_free(d->chan);
+    d->base = NULL;
+    d->chan = 0;
+    d->irq = 0;
+    return 0;
+}
+
+static int bcm2708_register_dmabuffer(struct platform_device *pdev,
+                struct bcm2708_spi *bs)
+{
+    /* for this to work you need to have set the following:
+       in the bcm2708_spi_device definition:
+       .dev = {
+       .coherent_dma_mask = DMA_BIT_MASK(DMA_MASK_BITS_COMMON),
+       },
+       otherwise you get the message:
+       coherent DMA mask is unset
+       and the allocation fails...
+       learned the hard way, so as a hint for all
+       who take this as a base...
+    */
+    bs->dma_buffer = dma_alloc_writecombine(&pdev->dev,
+                    SZ_4K,
+                    &bs->dma_buffer_handle,
+                    GFP_KERNEL);
+    if (!bs->dma_buffer) {
+        dev_err(&pdev->dev, "cannot allocate DMA CBs\n");
+        return -ENOMEM;
+    }
+    return 0;
+}
+
+static int bcm2708_release_dmabuffer(struct platform_device *pdev,
+                struct bcm2708_spi *bs)
+{
+    if (!bs->dma_buffer)
+        return 0;
+    dma_free_writecombine(&pdev->dev, SZ_4K,
+            bs->dma_buffer,
+            bs->dma_buffer_handle);
+    bs->dma_buffer = NULL;
+    bs->dma_buffer_handle = 0;
+    return 0;
+}
+
+irqreturn_t bcm2708_transfer_one_message_dma_irqhandler(int irq, void *dev)
+{
+    struct spi_master *master = dev;
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+
+    /* mark the rx DMA-interrupt as handled
+       - it will (level) trigger otherwise again */
+    writel(BCM2708_DMA_INT, bs->dma_rx.base+BCM2708_DMA_CS);
+
+    /* and wake up the thread to continue its work - returning ...*/
+    complete(&bs->done);
+    /* return IRQ handled */
+    return IRQ_HANDLED;
+}
+
+/* We could improve on DMA options, by chaining individual xfer messages
+   into a more complex CB chain that takes care of all the transfers in
+   one "go" resulting in only one interrupt getting delivered at the end of
+   the sequence. This would reduce the "gap" between transfers to virtually 0
+   (maybe one SPI clock lost) at the cost of possibly saturating the AXI bus.
+   Theoretically it would be possible to chain 63 requests together using
+   a single page that way we could run say 62 4KB DMA requests and by this
+   transfer 248 KB without a single CPU cycle needed - except for the final
+   notification IRQ (assuming that the driver requesting this is doing async
+   transfers). Assuming this, we could at a SPI bus speed of 15.625MHz
+   (core frequency of 250MHz with divider of 16) we could transfer about
+   1.953MB/s with just 7.8 interrupts (and Engine wakeups)
+   (250MHz/16(divider)/8(bit/byte)/(62(CBs we can chain)*4(kb/CB transfer))
+   But before adding this extra complexity to make this possible
+   the driver needing this needs to get written first...
+   Note: that this would also mean that the SPI bus is really dedicated
+   to this one device!!!
+
+   The other thing that could also help was (assuming that DMA in VideoCORE
+   does not have any errata - like on other arm platforms) if there was an
+   API that could map kernel addresses directly to BUS addresses independently
+   from if the xfer block has been allocated in the DMA region (the allocation
+   call of which returning also returns the bus address), then we could also
+   enable DMA by default on all transfers  and not only on selected ones.
+   This could help doing DMA transfers directly to user space without copying
+   - if there is an API allowing that...
+*/
+
+static int bcm2708_transfer_one_message_dma(struct spi_master *master,
+                    struct bcm2708_spi_state *stp,
+                    struct spi_transfer *xfer,
+                    int flags)
+{
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+    struct bcm2708_dma_cb *cbs = bs->dma_buffer;
+    u32 cs = 0;
+    /* calculate dma transfer sizes - words */
+    int dmaleninitial = 4;
+    int dmalen = xfer->len;
+
+    /* if size <=0 then return immediately and OK - nothing to do*/
+    if (xfer->len <= 0)
+        return 0;
+
+    /* increment type counter */
+    bs->transfers_dmadriven++;
+
+    if (xfer->len > 65536) {
+        dev_err(&master->dev, "Max allowed package size 64k exceeded");
+        return -EINVAL;
+    }
+    /* on first transfer reset the RX/TX */
+    cs = stp->cs | SPI_CS_DMAEN;
+    if (flags & FLAGS_FIRST_TRANSFER)
+        bcm2708_wr(bs, SPI_CS, cs | SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX);
+    /* auto deselect CS if it is the last */
+    if (flags & FLAGS_LAST_TRANSFER)
+        cs |= SPI_CS_ADCS;
+
+    /* store data for interrupts and more */
+    bs->rx_buf = xfer->rx_buf;
+    bs->tx_buf = xfer->tx_buf;
+    bs->rx_len = xfer->len;
+    bs->tx_len = xfer->len;
+    bs->cs = cs;
+
+    /* now set up the Registers */
+    bcm2708_wr(bs, SPI_CLK, stp->cdiv);
+    bcm2708_wr(bs, SPI_CS, cs);
+
+    /* start filling in the CBs */
+    /* first set up the flags for the fifo
+       - needs to be set 256 bit alligned, so abusing the first cb */
+    cbs[0].info = (xfer->len << 16) /* the length in bytes to transfer */
+        | (cs & 0xff) /* the bottom 8 bit flags for the SPI interface */
+        | SPI_CS_TA; /* and enable transfer */
+
+    /* tx info - set len/flags in the first CB */
+    cbs[1].info = BCM2708_DMA_PER_MAP(6) /* DREQ 6 = SPI TX in PERMAP */
+        | BCM2708_DMA_D_DREQ; /* destination DREQ trigger */
+    cbs[1].src = bs->dma_buffer_handle + 0*sizeof(struct bcm2708_dma_cb);
+    cbs[1].dst = (unsigned long)(DMA_SPI_BASE + SPI_FIFO);
+    cbs[1].length = dmaleninitial;
+    cbs[1].stride = 0;
+    cbs[1].next = bs->dma_buffer_handle + 2*sizeof(struct bcm2708_dma_cb);
+    /* and the tx-data in the second CB */
+    cbs[2].info = cbs[1].info | BCM2708_DMA_WAIT_RESP;
+    if (xfer->tx_buf) {
+        cbs[2].info |= BCM2708_DMA_S_INC; /* source increment by 4 */
+        cbs[2].src = (unsigned long)xfer->tx_dma;
+    } else {
+        cbs[3].info |= BCM2708_DMA_S_IGNORE; /* ignore source */
+        cbs[2].src = bs->dma_buffer_handle + 127*sizeof(struct bcm2708_dma_cb);
+    }
+    cbs[2].dst = cbs[1].dst;
+    cbs[2].length = dmalen;
+    cbs[2].stride = 0;
+    cbs[2].next = (unsigned long)0;
+    /* and here the RX Data */
+    /* rx info - set bytes/clock */
+    cbs[3].info = BCM2708_DMA_PER_MAP(7) /* DREQ 7 = SPI RX in PERMAP */
+        | BCM2708_DMA_S_DREQ /* source DREQ trigger */
+        | BCM2708_DMA_INT_EN; /* enable interrupt */
+    if (xfer->rx_buf) {
+        cbs[3].info |= BCM2708_DMA_D_INC; /* destination inc by 4 */
+        cbs[3].dst = (unsigned long)xfer->rx_dma;
+    } else {
+        cbs[3].info |= BCM2708_DMA_D_IGNORE; /* ignore destination */
+    }
+    cbs[3].src = cbs[1].dst;
+    cbs[3].length = xfer->len;
+    cbs[3].stride = 0;
+    cbs[3].next = (unsigned long)0;
+    /* initialize done */
+    INIT_COMPLETION(bs->done);
+    /* write CB to process */
+    writel(
+        bs->dma_buffer_handle + 3*sizeof(struct bcm2708_dma_cb),
+        bs->dma_rx.base + BCM2708_DMA_ADDR
+        );
+    writel(
+        bs->dma_buffer_handle + 1*sizeof(struct bcm2708_dma_cb),
+        bs->dma_tx.base + BCM2708_DMA_ADDR
+        );
+    dsb();
+    /* start DMA - this should also enable the DMA */
+    writel(BCM2708_DMA_ACTIVE, bs->dma_tx.base + BCM2708_DMA_CS);
+    writel(BCM2708_DMA_ACTIVE, bs->dma_rx.base + BCM2708_DMA_CS);
+
+    /* now we are running - waiting to get woken by interrupt */
+    /* the timeout may be too short - depend on amount of data and freq. */
+    if (wait_for_completion_timeout(
+            &bs->done,
+            msecs_to_jiffies(SPI_TIMEOUT_MS*10)) == 0) {
+        /* clear cs */
+
+        /* inform of event and return with error */
+        dev_err(&master->dev, "DMA transfer timed out");
+        /* need to abort Interrupts */
+        bcm_dma_abort(bs->dma_tx.base);
+        bcm_dma_abort(bs->dma_rx.base);
+        return -ETIMEDOUT;
+    }
+    /* and return */
+    return 0;
+}
+
+static irqreturn_t
+bcm2708_transfer_one_message_irqdriven_irqhandler(int irq, void *dev_id)
+{
+
+    struct spi_master *master = dev_id;
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+    char b;
+
+    spin_lock(&bs->lock);
+    /* if we got more data then write */
+    while ((bs->tx_len > 0) && (bcm2708_rd(bs, SPI_CS) & SPI_CS_TXD)) {
+        if (bs->tx_buf)
+            b = *bs->tx_buf++;
+        else
+            b = 0;
+        bcm2708_wr(bs, SPI_FIFO, b);
+        bs->tx_len--;
+    }
+    /* check for reads */
+    while (bcm2708_rd(bs, SPI_CS) & SPI_CS_RXD) {
+        /* getting byte from fifo */
+        b = bcm2708_rd(bs, SPI_FIFO);
+        /* store it if requested */
+        if (bs->rx_buf)
+            *bs->rx_buf++ = b;
+        bs->rx_len--;
+    }
+    spin_unlock(&bs->lock);
+
+    /* and if we have rx_len as 0 then wakeup the process */
+    if (bs->rx_len == 0) {
+        /* clean the transfers including all interrupts */
+        bcm2708_wr(bs, SPI_CS, bs->cs);
+        /* and wake up the thread to continue its work */
+        complete(&bs->done);
+    }
+
+    /* return IRQ handled */
+    return IRQ_HANDLED;
+}
+
+static int bcm2708_transfer_one_message_irqdriven(struct spi_master *master,
+                        struct bcm2708_spi_state *stp,
+                        struct spi_transfer *xfer,
+                        int flags)
+{
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+    u32 cs;
+    char b;
+    unsigned long iflags;
+
+    /* increment type counter */
+    bs->transfers_irqdriven++;
+
+    /* store the data somewhere where the interrupt handler can see it */
+    bs->tx_buf = xfer->tx_buf;
+    bs->tx_len = xfer->len;
+    bs->rx_buf = xfer->rx_buf;
+    bs->rx_len = xfer->len;
+    bs->cs = stp->cs;
+
+    /* if we are not the last xfer - keep flags when done */
+    if (!(flags | FLAGS_LAST_TRANSFER))
+        bs->cs |= SPI_CS_TA | SPI_CS_INTR | SPI_CS_INTD;
+
+    spin_lock_irqsave(&bs->lock, iflags);
+
+    /* start by setting up the SPI controller */
+    cs = stp->cs | SPI_CS_TA | SPI_CS_INTR | SPI_CS_INTD;
+    bcm2708_wr(bs, SPI_CLK, stp->cdiv);
+    bcm2708_wr(bs, SPI_CS, cs);
+
+    /* fill as much of a buffer as possible */
+    while ((bcm2708_rd(bs, SPI_CS) & SPI_CS_TXD) && (bs->tx_len > 0)) {
+        if (bs->tx_buf)
+            b = *bs->tx_buf++;
+        else
+            b = 0;
+        bcm2708_wr(bs, SPI_FIFO, b);
+        bs->tx_len--;
+    }
+
+    /* now enable the interrupts after we have initialized completion */
+    INIT_COMPLETION(bs->done);
+    spin_unlock_irqrestore(&bs->lock, iflags);
+
+    /* and wait for last interrupt to wake us up */
+    if (wait_for_completion_timeout(&bs->done,
+                msecs_to_jiffies(SPI_TIMEOUT_MS)) == 0) {
+        dev_err(&master->dev, "transfer timed out\n");
+        return -ETIMEDOUT;
+    }
+
+    /* and return */
+    return 0;
+}
+
+static int bcm2708_transfer_one_message_poll(struct spi_master *master,
+                    struct bcm2708_spi_state *stp,
+                    struct spi_transfer *xfer,
+                    int flags)
+{
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+    u32 cs;
+    char b;
+    const char *tx_buf = xfer->tx_buf;
+    int tx_len = xfer->len;
+    char *rx_buf = xfer->rx_buf;
+    int rx_len = xfer->len;
+
+    /* increment type counter */
+    bs->transfers_polling++;
+
+    /* start by setting up the SPI controller */
+    cs = stp->cs | SPI_CS_TA;
+    bcm2708_wr(bs, SPI_CLK, stp->cdiv);
+    bcm2708_wr(bs, SPI_CS, cs);
+    while ((rx_len > 0)) {
+        cs = bcm2708_rd(bs, SPI_CS);
+        if (cs & SPI_CS_TXD) {
+            if (tx_len > 0) {
+                if (tx_buf)
+                    b = *tx_buf++;
+                else
+                    b = 0;
+                bcm2708_wr(bs, SPI_FIFO, b);
+                tx_len--;
+            }
+        }
+        if (cs & SPI_CS_RXD) {
+            b = bcm2708_rd(bs, SPI_FIFO);
+            if (rx_buf)
+                *rx_buf++ = b;
+            rx_len--;
+        }
+    }
+    /* release cs */
+    bcm2708_wr(bs, SPI_CS, stp->cs);
+
+    return 0;
+}
+
+static int bcm2708_transfer_one_message(struct spi_master *master,
+                    struct spi_message *msg)
+{
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+    struct spi_transfer *xfer;
+    struct spi_device *spi = msg->spi;
+    struct bcm2708_spi_state state;
+    int status = 0;
+    int count = 0;
+    int transfers = 0;
+
+    list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+        transfers++;
+    }
+
+    /* loop all the transfer entries to check for transfer issues first */
+    list_for_each_entry(xfer, &msg->transfers, transfer_list) {
+        int can_dma = 1;
+        int flags = 0;
+        count++;
+        /* calculate flags */
+        if (count == 1) {
+            /* clear the queues */
+            bcm2708_wr(bs, SPI_CS, bcm2708_rd(bs, SPI_CS) |
+                    SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX);
+            flags |= FLAGS_FIRST_TRANSFER;
+        }
+        if (count == transfers)
+            flags |= FLAGS_LAST_TRANSFER;
+        /* check if elegable for DMA */
+        if ((xfer->tx_buf) && (!xfer->tx_dma))
+            can_dma = 0;
+        if ((xfer->rx_buf) && (!xfer->rx_dma))
+            can_dma = 0;
+
+        /* configure SPI - use global settings if not explicitly set */
+        if (xfer->bits_per_word || xfer->speed_hz) {
+            status = bcm2708_setup_state(spi->master, &spi->dev,
+                &state,
+                xfer->speed_hz ? xfer->speed_hz :
+                            spi->max_speed_hz,
+                spi->chip_select, spi->mode,
+                xfer->bits_per_word ? xfer->bits_per_word :
+                            spi->bits_per_word);
+        } else {
+            state.cs = ((struct bcm2708_spi_state *)spi->controller_state)->cs;
+            state.cdiv = ((struct bcm2708_spi_state *)spi->controller_state)->cdiv;
+        }
+        if (status)
+            goto exit;
+        /* keep Transfer active until we are triggering the last one */
+        if (!(flags & FLAGS_LAST_TRANSFER))
+            state.cs |= SPI_CS_TA;
+        /* now send the message over SPI */
+        switch (mode) {
+        case 0: /* polling */
+            status = bcm2708_transfer_one_message_poll(
+                master, &state, xfer, flags);
+            break;
+        case 1: /* interrupt driven */
+            status = bcm2708_transfer_one_message_irqdriven(
+                master, &state, xfer, flags);
+            break;
+        case 2: /* dma driven */
+        default:
+            if (can_dma) {
+                status = bcm2708_transfer_one_message_dma(
+                    master, &state, xfer, flags
+                    );
+                break;
+            } else {
+                status = bcm2708_transfer_one_message_irqdriven(
+                    master, &state, xfer, flags
+                    );
+                break;
+            }
+        }
+        if (status)
+            goto exit;
+        /* delay if given */
+        if (xfer->delay_usecs)
+            udelay(xfer->delay_usecs);
+        /* and add up the result */
+        msg->actual_length += xfer->len;
+    }
+exit:
+    msg->status = status;
+    spi_finalize_current_message(master);
+    return status;
+}
+
+static int bcm2708_prepare_transfer(struct spi_master *master)
+{
+    return 0;
+}
+
+static int bcm2708_unprepare_transfer(struct spi_master *master)
+{
+    return 0;
+}
+
+static int bcm2708_spi_setup(struct spi_device *spi)
+{
+    struct bcm2708_spi *bs = spi_master_get_devdata(spi->master);
+    struct bcm2708_spi_state *state;
+    int ret;
+
+    /* configure master */
+
+    if (bs->stopping)
+        return -ESHUTDOWN;
+
+    if (!(spi->mode & SPI_NO_CS) &&
+        (spi->chip_select > spi->master->num_chipselect)) {
+        dev_info(&spi->dev,
+            "setup: invalid chipselect %u (%u defined)\n",
+            spi->chip_select, spi->master->num_chipselect);
+        return -EINVAL;
+    }
+
+    state = spi->controller_state;
+    if (!state) {
+        state = kzalloc(sizeof(*state), GFP_KERNEL);
+        if (!state)
+            return -ENOMEM;
+
+        spi->controller_state = state;
+    }
+
+    ret = bcm2708_setup_state(spi->master, &spi->dev, state,
+                spi->max_speed_hz, spi->chip_select, spi->mode,
+                spi->bits_per_word);
+    if (ret < 0) {
+        kfree(state);
+        spi->controller_state = NULL;
+        return ret;
+    }
+
+    return 0;
+}
+
+static void bcm2708_spi_cleanup(struct spi_device *spi)
+{
+    kfree(spi->controller_state);
+    spi->controller_state = NULL;
+}
+
+static int bcm2708_spi_probe(struct platform_device *pdev)
+{
+    struct resource *regs;
+    int irq, err = -ENOMEM;
+    struct clk *clk;
+    struct spi_master *master;
+    struct bcm2708_spi *bs;
+    const char *modestr;
+
+    regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!regs) {
+        dev_err(&pdev->dev, "could not get IO memory\n");
+        return -ENXIO;
+    }
+
+    irq = platform_get_irq(pdev, 0);
+    if (irq < 0) {
+        dev_err(&pdev->dev, "could not get IRQ\n");
+        return irq;
+    }
+
+    clk = clk_get(&pdev->dev, NULL);
+    if (IS_ERR(clk)) {
+        dev_err(&pdev->dev, "could not find clk: %ld\n", PTR_ERR(clk));
+        return PTR_ERR(clk);
+    }
+
+    bcm2708_init_pinmode();
+
+    master = spi_alloc_master(&pdev->dev, sizeof(*bs));
+    if (!master) {
+        dev_err(&pdev->dev, "spi_alloc_master() failed\n");
+        goto out_clk_put;
+    }
+
+    /* the spi->mode bits understood by this driver: */
+    master->mode_bits = SPI_CPOL | SPI_CPHA | SPI_CS_HIGH | SPI_NO_CS;
+
+    master->bus_num = pdev->id;
+    master->num_chipselect = 3;
+    master->setup = bcm2708_spi_setup;
+    master->cleanup = bcm2708_spi_cleanup;
+    master->dev.of_node = pdev->dev.of_node;
+    master->rt = realtime;
+
+    master->prepare_transfer_hardware       = bcm2708_prepare_transfer;
+    master->transfer_one_message            = bcm2708_transfer_one_message;
+    master->unprepare_transfer_hardware     = bcm2708_unprepare_transfer;
+
+    platform_set_drvdata(pdev, master);
+
+
+    bs = spi_master_get_devdata(master);
+    spin_lock_init(&bs->lock);
+    init_completion(&bs->done);
+
+    /* set counters */
+    bs->transfers_polling = 0;
+    bs->transfers_irqdriven = 0;
+    bs->transfers_dmadriven = 0;
+
+    /* get Register Map */
+    bs->base = ioremap(regs->start, resource_size(regs));
+    if (!bs->base) {
+        dev_err(&pdev->dev, "could not remap memory\n");
+        goto out_master_put;
+    }
+
+    bs->irq = irq;
+    bs->clk = clk;
+    bs->stopping = false;
+
+    err = request_irq(irq,
+            bcm2708_transfer_one_message_irqdriven_irqhandler,
+            0,
+            dev_name(&pdev->dev),
+            master);
+    if (err) {
+        dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
+        goto out_iounmap;
+    }
+
+    /* enable DMA */
+    /* register memory buffer for DMA */
+    err = bcm2708_register_dmabuffer(pdev, bs);
+    if (err)
+        goto out_free_irq;
+    /* register channels and irq */
+    err = bcm2708_register_dma(pdev,
+                        &bs->dma_rx,
+                        bs->dma_buffer,
+                        DRV_NAME "(rxDMA)"
+                );
+    if (err)
+        goto out_free_dma_buffer;
+    err = bcm2708_register_dma(pdev,
+                        &bs->dma_tx,
+                        bs->dma_buffer,
+                        DRV_NAME "(txDMA)"
+                );
+    if (err)
+        goto out_free_dma_rx;
+    /* register IRQ for RX dma channel  */
+    err = request_irq(bs->dma_rx.irq,
+            bcm2708_transfer_one_message_dma_irqhandler,
+            0,
+            dev_name(&pdev->dev),
+            master);
+    if (err) {
+        dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
+        goto out_free_dma_tx;
+    }
+
+    /* initialise the hardware */
+    clk_prepare_enable(clk);
+    bcm2708_wr(bs, SPI_CS, SPI_CS_REN | SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX);
+
+    err = spi_register_master(master);
+    if (err) {
+        dev_err(&pdev->dev, "could not register SPI master: %d\n", err);
+        goto out_free_dma_irq;
+    }
+
+    dev_info(&pdev->dev, "SPI Controller at 0x%08lx (irq %d)\n",
+        (unsigned long)regs->start, irq);
+
+    /* now send the message over SPI */
+    switch (mode) {
+    case 0:
+        modestr = "polling";
+        break;
+    case 1:
+        modestr = "interrupt-driven";
+        break;
+    case 2:
+    default:
+        mode = 2;
+        modestr = "dma";
+        break;
+    }
+    dev_info(&pdev->dev, "SPI Controller running in %s mode\n", modestr);
+    return 0;
+out_free_dma_irq:
+    free_irq(bs->dma_rx.irq, master);
+out_free_dma_tx:
+    bcm2708_release_dma(pdev, &bs->dma_tx);
+out_free_dma_rx:
+    bcm2708_release_dma(pdev, &bs->dma_rx);
+out_free_dma_buffer:
+    bcm2708_release_dmabuffer(pdev, bs);
+out_free_irq:
+    clk_disable_unprepare(bs->clk);
+    free_irq(bs->irq, master);
+out_iounmap:
+    iounmap(bs->base);
+out_master_put:
+    spi_master_put(master);
+out_clk_put:
+    clk_put(clk);
+    return err;
+}
+
+static int bcm2708_spi_remove(struct platform_device *pdev)
+{
+    struct spi_master *master = platform_get_drvdata(pdev);
+    struct bcm2708_spi *bs = spi_master_get_devdata(master);
+
+    /* first report on usage */
+    dev_info(&pdev->dev, "SPI Bus statistics: %llu poll %llu interrupt and %llu dma driven messages\n",
+        bs->transfers_polling,
+        bs->transfers_irqdriven,
+        bs->transfers_dmadriven
+        );
+
+    /* reset the hardware and block queue progress */
+    bs->stopping = true;
+    bcm2708_wr(bs, SPI_CS, SPI_CS_CLEAR_RX | SPI_CS_CLEAR_TX);
+
+    clk_disable_unprepare(bs->clk);
+    clk_put(bs->clk);
+    free_irq(bs->irq, master);
+    iounmap(bs->base);
+
+    /* release DMA */
+    free_irq(bs->dma_rx.irq, master);
+    bcm2708_release_dma(pdev, &bs->dma_tx);
+    bcm2708_release_dma(pdev, &bs->dma_rx);
+    bcm2708_release_dmabuffer(pdev, bs);
+
+    /* and unregister device */
+    spi_unregister_master(master);
+
+    return 0;
+}
+
+static const struct of_device_id bcm2708_spi_match[] = {
+    { .compatible = "brcm,bcm2708-spi-dma", },
+    {}
+};
+MODULE_DEVICE_TABLE(of, bcm2708_spi_match);
+
+static struct platform_driver bcm2708_spi_driver = {
+    .driver		= {
+        .name	= DRV_NAME,
+        .owner	= THIS_MODULE,
+        .of_match_table	= bcm2708_spi_match,
+    },
+    .probe		= bcm2708_spi_probe,
+    .remove		= bcm2708_spi_remove,
+};
+
+
+static int __init bcm2708_spi_init(void)
+{
+    //return platform_driver_register(&bcm2708_spi_driver);
+    return platform_driver_probe(&bcm2708_spi_driver, bcm2708_spi_probe);
+}
+module_init(bcm2708_spi_init);
+
+static void __exit bcm2708_spi_exit(void)
+{
+    platform_driver_unregister(&bcm2708_spi_driver);
+}
+module_exit(bcm2708_spi_exit);
+
+
+/* module_platform_driver(bcm2708_spi_driver); */
+
+MODULE_DESCRIPTION("SPI controller driver for Broadcom BCM2708");
+MODULE_AUTHOR("Chris Boot <bootc@bootc.net>, Martin Sperl");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" DRV_NAME);
diff --git a/drivers/video/4d-hats/spi-bcm2835_dma.c b/drivers/video/4d-hats/spi-bcm2835_dma.c
new file mode 100644
index 000000000000..60fd7fcf011a
--- /dev/null
+++ b/drivers/video/4d-hats/spi-bcm2835_dma.c
@@ -0,0 +1,880 @@
+/*
+ * Driver for Broadcom BCM2835 SPI Controllers
+ *
+ * Copyright (C) 2012 Chris Boot
+ * Copyright (C) 2013 Stephen Warren
+ * Copyright (C) 2015 Martin Sperl
+ *
+ * This driver is inspired by:
+ * spi-ath79.c, Copyright (C) 2009-2011 Gabor Juhos <juhosg@openwrt.org>
+ * spi-atmel.c, Copyright (C) 2006 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/page.h>
+#include <linux/clk.h>
+#include <linux/completion.h>
+#include <linux/delay.h>
+#include <linux/dma-mapping.h>
+#include <linux/dmaengine.h>
+#include <linux/err.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/of_irq.h>
+#include <linux/spi/spi.h>
+
+/* SPI register offsets */
+#define BCM2835_SPI_CS			0x00
+#define BCM2835_SPI_FIFO		0x04
+#define BCM2835_SPI_CLK			0x08
+#define BCM2835_SPI_DLEN		0x0c
+#define BCM2835_SPI_LTOH		0x10
+#define BCM2835_SPI_DC			0x14
+
+/* Bitfields in CS */
+#define BCM2835_SPI_CS_LEN_LONG		0x02000000
+#define BCM2835_SPI_CS_DMA_LEN		0x01000000
+#define BCM2835_SPI_CS_CSPOL2		0x00800000
+#define BCM2835_SPI_CS_CSPOL1		0x00400000
+#define BCM2835_SPI_CS_CSPOL0		0x00200000
+#define BCM2835_SPI_CS_RXF		0x00100000
+#define BCM2835_SPI_CS_RXR		0x00080000
+#define BCM2835_SPI_CS_TXD		0x00040000
+#define BCM2835_SPI_CS_RXD		0x00020000
+#define BCM2835_SPI_CS_DONE		0x00010000
+#define BCM2835_SPI_CS_LEN		0x00002000
+#define BCM2835_SPI_CS_REN		0x00001000
+#define BCM2835_SPI_CS_ADCS		0x00000800
+#define BCM2835_SPI_CS_INTR		0x00000400
+#define BCM2835_SPI_CS_INTD		0x00000200
+#define BCM2835_SPI_CS_DMAEN		0x00000100
+#define BCM2835_SPI_CS_TA		0x00000080
+#define BCM2835_SPI_CS_CSPOL		0x00000040
+#define BCM2835_SPI_CS_CLEAR_RX		0x00000020
+#define BCM2835_SPI_CS_CLEAR_TX		0x00000010
+#define BCM2835_SPI_CS_CPOL		0x00000008
+#define BCM2835_SPI_CS_CPHA		0x00000004
+#define BCM2835_SPI_CS_CS_10		0x00000002
+#define BCM2835_SPI_CS_CS_01		0x00000001
+
+#define BCM2835_SPI_POLLING_LIMIT_US	30
+#define BCM2835_SPI_POLLING_JIFFIES	2
+#define BCM2835_SPI_DMA_MIN_LENGTH	96
+#define BCM2835_SPI_MODE_BITS	(SPI_CPOL | SPI_CPHA | SPI_CS_HIGH \
+				| SPI_NO_CS | SPI_3WIRE)
+
+#define DRV_NAME	"spi-bcm2835"
+
+struct bcm2835_spi {
+	void __iomem *regs;
+	struct clk *clk;
+	int irq;
+	const u8 *tx_buf;
+	u8 *rx_buf;
+	int tx_len;
+	int rx_len;
+	bool dma_pending;
+};
+
+static inline u32 bcm2835_rd(struct bcm2835_spi *bs, unsigned reg)
+{
+	return readl(bs->regs + reg);
+}
+
+static inline void bcm2835_wr(struct bcm2835_spi *bs, unsigned reg, u32 val)
+{
+	writel(val, bs->regs + reg);
+}
+
+static inline void bcm2835_rd_fifo(struct bcm2835_spi *bs)
+{
+	u8 byte;
+
+	while ((bs->rx_len) &&
+	       (bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_RXD)) {
+		byte = bcm2835_rd(bs, BCM2835_SPI_FIFO);
+		if (bs->rx_buf)
+			*bs->rx_buf++ = byte;
+		bs->rx_len--;
+	}
+}
+
+static inline void bcm2835_wr_fifo(struct bcm2835_spi *bs)
+{
+	u8 byte;
+
+	while ((bs->tx_len) &&
+	       (bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_TXD)) {
+		byte = bs->tx_buf ? *bs->tx_buf++ : 0;
+		bcm2835_wr(bs, BCM2835_SPI_FIFO, byte);
+		bs->tx_len--;
+	}
+}
+
+static void bcm2835_spi_reset_hw(struct spi_master *master)
+{
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
+
+	/* Disable SPI interrupts and transfer */
+	cs &= ~(BCM2835_SPI_CS_INTR |
+		BCM2835_SPI_CS_INTD |
+		BCM2835_SPI_CS_DMAEN |
+		BCM2835_SPI_CS_TA);
+	/* and reset RX/TX FIFOS */
+	cs |= BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX;
+
+	/* and reset the SPI_HW */
+	bcm2835_wr(bs, BCM2835_SPI_CS, cs);
+	/* as well as DLEN */
+	bcm2835_wr(bs, BCM2835_SPI_DLEN, 0);
+}
+
+static irqreturn_t bcm2835_spi_interrupt(int irq, void *dev_id)
+{
+	struct spi_master *master = dev_id;
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+
+	/* Read as many bytes as possible from FIFO */
+	bcm2835_rd_fifo(bs);
+	/* Write as many bytes as possible to FIFO */
+	bcm2835_wr_fifo(bs);
+
+	/* based on flags decide if we can finish the transfer */
+	if (bcm2835_rd(bs, BCM2835_SPI_CS) & BCM2835_SPI_CS_DONE) {
+		/* Transfer complete - reset SPI HW */
+		bcm2835_spi_reset_hw(master);
+		/* wake up the framework */
+		complete(&master->xfer_completion);
+	}
+
+	return IRQ_HANDLED;
+}
+
+static int bcm2835_spi_transfer_one_irq(struct spi_master *master,
+					struct spi_device *spi,
+					struct spi_transfer *tfr,
+					u32 cs)
+{
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+
+	/* fill in fifo if we have gpio-cs
+	 * note that there have been rare events where the native-CS
+	 * flapped for <1us which may change the behaviour
+	 * with gpio-cs this does not happen, so it is implemented
+	 * only for this case
+	 */
+	if (gpio_is_valid(spi->cs_gpio)) {
+		/* enable HW block, but without interrupts enabled
+		 * this would triggern an immediate interrupt
+		 */
+		bcm2835_wr(bs, BCM2835_SPI_CS,
+			   cs | BCM2835_SPI_CS_TA);
+		/* fill in tx fifo as much as possible */
+		bcm2835_wr_fifo(bs);
+	}
+
+	/*
+	 * Enable the HW block. This will immediately trigger a DONE (TX
+	 * empty) interrupt, upon which we will fill the TX FIFO with the
+	 * first TX bytes. Pre-filling the TX FIFO here to avoid the
+	 * interrupt doesn't work:-(
+	 */
+	cs |= BCM2835_SPI_CS_INTR | BCM2835_SPI_CS_INTD | BCM2835_SPI_CS_TA;
+	bcm2835_wr(bs, BCM2835_SPI_CS, cs);
+
+	/* signal that we need to wait for completion */
+	return 1;
+}
+
+/*
+ * DMA support
+ *
+ * this implementation has currently a few issues in so far as it does
+ * not work arrount limitations of the HW.
+ *
+ * the main one being that DMA transfers are limited to 16 bit
+ * (so 0 to 65535 bytes) by the SPI HW due to BCM2835_SPI_DLEN
+ *
+ * also we currently assume that the scatter-gather fragments are
+ * all multiple of 4 (except the last) - otherwise we would need
+ * to reset the FIFO before subsequent transfers...
+ * this also means that tx/rx transfers sg's need to be of equal size!
+ *
+ * there may be a few more border-cases we may need to address as well
+ * but unfortunately this would mean splitting up the scatter-gather
+ * list making it slightly unpractical...
+ */
+static void bcm2835_spi_dma_done(void *data)
+{
+	struct spi_master *master = data;
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+
+	/* reset fifo and HW */
+	bcm2835_spi_reset_hw(master);
+
+	/* and terminate tx-dma as we do not have an irq for it
+	 * because when the rx dma will terminate and this callback
+	 * is called the tx-dma must have finished - can't get to this
+	 * situation otherwise...
+	 */
+	dmaengine_terminate_all(master->dma_tx);
+
+	/* mark as no longer pending */
+	bs->dma_pending = 0;
+
+	/* and mark as completed */;
+	complete(&master->xfer_completion);
+}
+
+static int bcm2835_spi_prepare_sg(struct spi_master *master,
+				  struct spi_transfer *tfr,
+				  bool is_tx)
+{
+	struct dma_chan *chan;
+	struct scatterlist *sgl;
+	unsigned int nents;
+	enum dma_transfer_direction dir;
+	unsigned long flags;
+
+	struct dma_async_tx_descriptor *desc;
+	dma_cookie_t cookie;
+
+	if (is_tx) {
+		dir   = DMA_MEM_TO_DEV;
+		chan  = master->dma_tx;
+		nents = tfr->tx_sg.nents;
+		sgl   = tfr->tx_sg.sgl;
+		flags = 0 /* no  tx interrupt */;
+
+	} else {
+		dir   = DMA_DEV_TO_MEM;
+		chan  = master->dma_rx;
+		nents = tfr->rx_sg.nents;
+		sgl   = tfr->rx_sg.sgl;
+		flags = DMA_PREP_INTERRUPT;
+	}
+	/* prepare the channel */
+	desc = dmaengine_prep_slave_sg(chan, sgl, nents, dir, flags);
+	if (!desc)
+		return -EINVAL;
+
+	/* set callback for rx */
+	if (!is_tx) {
+		desc->callback = bcm2835_spi_dma_done;
+		desc->callback_param = master;
+	}
+
+	/* submit it to DMA-engine */
+	cookie = dmaengine_submit(desc);
+
+	return dma_submit_error(cookie);
+}
+
+static inline int bcm2835_check_sg_length(struct sg_table *sgt)
+{
+	int i;
+	struct scatterlist *sgl;
+
+	/* check that the sg entries are word-sized (except for last) */
+	for_each_sg(sgt->sgl, sgl, (int)sgt->nents - 1, i) {
+		if (sg_dma_len(sgl) % 4)
+			return -EFAULT;
+	}
+
+	return 0;
+}
+
+static int bcm2835_spi_transfer_one_dma(struct spi_master *master,
+					struct spi_device *spi,
+					struct spi_transfer *tfr,
+					u32 cs)
+{
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+	int ret;
+
+	/* check that the scatter gather segments are all a multiple of 4 */
+	if (bcm2835_check_sg_length(&tfr->tx_sg) ||
+	    bcm2835_check_sg_length(&tfr->rx_sg)) {
+		dev_warn_once(&spi->dev,
+			      "scatter gather segment length is not a multiple of 4 - falling back to interrupt mode\n");
+		return bcm2835_spi_transfer_one_irq(master, spi, tfr, cs);
+	}
+
+	/* setup tx-DMA */
+	ret = bcm2835_spi_prepare_sg(master, tfr, true);
+	if (ret)
+		return ret;
+
+	/* start TX early */
+	dma_async_issue_pending(master->dma_tx);
+
+	/* mark as dma pending */
+	bs->dma_pending = 1;
+
+	/* set the DMA length */
+	bcm2835_wr(bs, BCM2835_SPI_DLEN, tfr->len);
+
+	/* start the HW */
+	bcm2835_wr(bs, BCM2835_SPI_CS,
+		   cs | BCM2835_SPI_CS_TA | BCM2835_SPI_CS_DMAEN);
+
+	/* setup rx-DMA late - to run transfers while
+	 * mapping of the rx buffers still takes place
+	 * this saves 10us or more.
+	 */
+	ret = bcm2835_spi_prepare_sg(master, tfr, false);
+	if (ret) {
+		/* need to reset on errors */
+		dmaengine_terminate_all(master->dma_tx);
+		bcm2835_spi_reset_hw(master);
+		return ret;
+	}
+
+	/* start rx dma late */
+	dma_async_issue_pending(master->dma_rx);
+
+	/* wait for wakeup in framework */
+	return 1;
+}
+
+static bool bcm2835_spi_can_dma(struct spi_master *master,
+				struct spi_device *spi,
+				struct spi_transfer *tfr)
+{
+	/* only run for gpio_cs */
+	if (!gpio_is_valid(spi->cs_gpio))
+		return false;
+
+	/* we start DMA efforts only on bigger transfers */
+	if (tfr->len < BCM2835_SPI_DMA_MIN_LENGTH)
+		return false;
+
+	/* BCM2835_SPI_DLEN has defined a max transfer size as
+	 * 16 bit, so max is 65535
+	 * we can revisit this by using an alternative transfer
+	 * method - ideally this would get done without any more
+	 * interaction...
+	 */
+	if (tfr->len > 65535) {
+		dev_warn_once(&spi->dev,
+			      "transfer size of %d too big for dma-transfer\n",
+			      tfr->len);
+		return false;
+	}
+
+	/* if we run rx/tx_buf with word aligned addresses then we are OK */
+	if ((((size_t)tfr->rx_buf & 3) == 0) &&
+	    (((size_t)tfr->tx_buf & 3) == 0))
+		return true;
+
+	/* otherwise we only allow transfers within the same page
+	 * to avoid wasting time on dma_mapping when it is not practical
+	 */
+	if (((size_t)tfr->tx_buf & (PAGE_SIZE - 1)) + tfr->len > PAGE_SIZE) {
+		dev_warn_once(&spi->dev,
+			      "Unaligned spi tx-transfer bridging page\n");
+		return false;
+	}
+	if (((size_t)tfr->rx_buf & (PAGE_SIZE - 1)) + tfr->len > PAGE_SIZE) {
+		dev_warn_once(&spi->dev,
+			      "Unaligned spi rx-transfer bridging page\n");
+		return false;
+	}
+
+	/* return OK */
+	return true;
+}
+
+static void bcm2835_dma_release(struct spi_master *master)
+{
+	if (master->dma_tx) {
+		dmaengine_terminate_all(master->dma_tx);
+		dma_release_channel(master->dma_tx);
+		master->dma_tx = NULL;
+	}
+	if (master->dma_rx) {
+		dmaengine_terminate_all(master->dma_rx);
+		dma_release_channel(master->dma_rx);
+		master->dma_rx = NULL;
+	}
+}
+
+static void bcm2835_dma_init(struct spi_master *master, struct device *dev)
+{
+	struct dma_slave_config slave_config;
+	const __be32 *addr;
+	dma_addr_t dma_reg_base;
+	int ret;
+
+	/* base address in dma-space */
+	addr = of_get_address(master->dev.of_node, 0, NULL, NULL);
+	if (!addr) {
+		dev_err(dev, "could not get DMA-register address - not using dma mode\n");
+		goto err;
+	}
+	dma_reg_base = be32_to_cpup(addr);
+
+	/* get tx/rx dma */
+	master->dma_tx = dma_request_slave_channel(dev, "tx");
+	if (!master->dma_tx) {
+		dev_err(dev, "no tx-dma configuration found - not using dma mode\n");
+		goto err;
+	}
+	master->dma_rx = dma_request_slave_channel(dev, "rx");
+	if (!master->dma_rx) {
+		dev_err(dev, "no rx-dma configuration found - not using dma mode\n");
+		goto err_release;
+	}
+
+	/* configure DMAs */
+	slave_config.direction = DMA_MEM_TO_DEV;
+	slave_config.dst_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);
+	slave_config.dst_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	ret = dmaengine_slave_config(master->dma_tx, &slave_config);
+	if (ret)
+		goto err_config;
+
+	slave_config.direction = DMA_DEV_TO_MEM;
+	slave_config.src_addr = (u32)(dma_reg_base + BCM2835_SPI_FIFO);
+	slave_config.src_addr_width = DMA_SLAVE_BUSWIDTH_4_BYTES;
+
+	ret = dmaengine_slave_config(master->dma_rx, &slave_config);
+	if (ret)
+		goto err_config;
+
+	/* all went well, so set can_dma */
+	master->can_dma = bcm2835_spi_can_dma;
+	master->max_dma_len = 65535; /* limitation by BCM2835_SPI_DLEN */
+	/* need to do TX AND RX DMA, so we need dummy buffers */
+	master->flags = SPI_MASTER_MUST_RX | SPI_MASTER_MUST_TX;
+
+	return;
+
+err_config:
+	dev_err(dev, "issue configuring dma: %d - not using DMA mode\n",
+		ret);
+err_release:
+	bcm2835_dma_release(master);
+err:
+	return;
+}
+
+static int bcm2835_spi_transfer_one_poll(struct spi_master *master,
+					 struct spi_device *spi,
+					 struct spi_transfer *tfr,
+					 u32 cs,
+					 unsigned long long xfer_time_us)
+{
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+	unsigned long timeout;
+
+	/* enable HW block without interrupts */
+	bcm2835_wr(bs, BCM2835_SPI_CS, cs | BCM2835_SPI_CS_TA);
+
+	/* fill in the fifo before timeout calculations
+	 * if we are interrupted here, then the data is
+	 * getting transferred by the HW while we are interrupted
+	 */
+	bcm2835_wr_fifo(bs);
+
+	/* set the timeout */
+	timeout = jiffies + BCM2835_SPI_POLLING_JIFFIES;
+
+	/* loop until finished the transfer */
+	while (bs->rx_len) {
+		/* fill in tx fifo with remaining data */
+		bcm2835_wr_fifo(bs);
+
+		/* read from fifo as much as possible */
+		bcm2835_rd_fifo(bs);
+
+		/* if there is still data pending to read
+		 * then check the timeout
+		 */
+		if (bs->rx_len && time_after(jiffies, timeout)) {
+			dev_dbg_ratelimited(&spi->dev,
+					    "timeout period reached: jiffies: %lu remaining tx/rx: %d/%d - falling back to interrupt mode\n",
+					    jiffies - timeout,
+					    bs->tx_len, bs->rx_len);
+			/* fall back to interrupt mode */
+			return bcm2835_spi_transfer_one_irq(master, spi,
+							    tfr, cs);
+		}
+	}
+
+	/* Transfer complete - reset SPI HW */
+	bcm2835_spi_reset_hw(master);
+	/* and return without waiting for completion */
+	return 0;
+}
+
+static int bcm2835_spi_transfer_one(struct spi_master *master,
+				    struct spi_device *spi,
+				    struct spi_transfer *tfr)
+{
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+	unsigned long spi_hz, clk_hz, cdiv;
+	unsigned long spi_used_hz;
+	unsigned long long xfer_time_us;
+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
+
+	/* set clock */
+	spi_hz = tfr->speed_hz;
+	clk_hz = clk_get_rate(bs->clk);
+
+	if (spi_hz >= clk_hz / 2) {
+		cdiv = 2; /* clk_hz/2 is the fastest we can go */
+	} else if (spi_hz) {
+		/* CDIV must be a multiple of two */
+		cdiv = DIV_ROUND_UP(clk_hz, spi_hz);
+		cdiv += (cdiv % 2);
+
+		if (cdiv >= 65536)
+			cdiv = 0; /* 0 is the slowest we can go */
+	} else {
+		cdiv = 0; /* 0 is the slowest we can go */
+	}
+	spi_used_hz = cdiv ? (clk_hz / cdiv) : (clk_hz / 65536);
+	bcm2835_wr(bs, BCM2835_SPI_CLK, cdiv);
+
+	/* handle all the 3-wire mode */
+	if ((spi->mode & SPI_3WIRE) && (tfr->rx_buf))
+		cs |= BCM2835_SPI_CS_REN;
+	else
+		cs &= ~BCM2835_SPI_CS_REN;
+
+	/* for gpio_cs set dummy CS so that no HW-CS get changed
+	 * we can not run this in bcm2835_spi_set_cs, as it does
+	 * not get called for cs_gpio cases, so we need to do it here
+	 */
+	if (gpio_is_valid(spi->cs_gpio) || (spi->mode & SPI_NO_CS))
+		cs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;
+
+	/* set transmit buffers and length */
+	bs->tx_buf = tfr->tx_buf;
+	bs->rx_buf = tfr->rx_buf;
+	bs->tx_len = tfr->len;
+	bs->rx_len = tfr->len;
+
+	/* calculate the estimated time in us the transfer runs */
+	xfer_time_us = (unsigned long long)tfr->len
+		* 9 /* clocks/byte - SPI-HW waits 1 clock after each byte */
+		* 1000000;
+	do_div(xfer_time_us, spi_used_hz);
+
+	/* for short requests run polling*/
+	if (xfer_time_us <= BCM2835_SPI_POLLING_LIMIT_US)
+		return bcm2835_spi_transfer_one_poll(master, spi, tfr,
+						     cs, xfer_time_us);
+	/* run in dma mode if conditions are right */
+	if (master->can_dma && bcm2835_spi_can_dma(master, spi, tfr))
+		return bcm2835_spi_transfer_one_dma(master, spi, tfr, cs);
+
+	/* run in interrupt-mode */
+	return bcm2835_spi_transfer_one_irq(master, spi, tfr, cs);
+}
+
+static int bcm2835_spi_prepare_message(struct spi_master *master,
+				       struct spi_message *msg)
+{
+	struct spi_device *spi = msg->spi;
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
+
+	cs &= ~(BCM2835_SPI_CS_CPOL | BCM2835_SPI_CS_CPHA);
+
+	if (spi->mode & SPI_CPOL)
+		cs |= BCM2835_SPI_CS_CPOL;
+	if (spi->mode & SPI_CPHA)
+		cs |= BCM2835_SPI_CS_CPHA;
+
+	bcm2835_wr(bs, BCM2835_SPI_CS, cs);
+
+	return 0;
+}
+
+static void bcm2835_spi_handle_err(struct spi_master *master,
+				   struct spi_message *msg)
+{
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+
+	/* if an error occurred and we have an active dma, then terminate */
+	if (bs->dma_pending) {
+		dmaengine_terminate_all(master->dma_tx);
+		dmaengine_terminate_all(master->dma_rx);
+		bs->dma_pending = 0;
+	}
+	/* and reset */
+	bcm2835_spi_reset_hw(master);
+}
+
+static void bcm2835_spi_set_cs(struct spi_device *spi, bool gpio_level)
+{
+	/*
+	 * we can assume that we are "native" as per spi_set_cs
+	 *   calling us ONLY when cs_gpio is not set
+	 * we can also assume that we are CS < 3 as per bcm2835_spi_setup
+	 *   we would not get called because of error handling there.
+	 * the level passed is the electrical level not enabled/disabled
+	 *   so it has to get translated back to enable/disable
+	 *   see spi_set_cs in spi.c for the implementation
+	 */
+
+	struct spi_master *master = spi->master;
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+	u32 cs = bcm2835_rd(bs, BCM2835_SPI_CS);
+	bool enable;
+
+	/* calculate the enable flag from the passed gpio_level */
+	enable = (spi->mode & SPI_CS_HIGH) ? gpio_level : !gpio_level;
+
+	/* set flags for "reverse" polarity in the registers */
+	if (spi->mode & SPI_CS_HIGH) {
+		/* set the correct CS-bits */
+		cs |= BCM2835_SPI_CS_CSPOL;
+		cs |= BCM2835_SPI_CS_CSPOL0 << spi->chip_select;
+	} else {
+		/* clean the CS-bits */
+		cs &= ~BCM2835_SPI_CS_CSPOL;
+		cs &= ~(BCM2835_SPI_CS_CSPOL0 << spi->chip_select);
+	}
+
+	/* select the correct chip_select depending on disabled/enabled */
+	if (enable) {
+		/* set cs correctly */
+		if (spi->mode & SPI_NO_CS) {
+			/* use the "undefined" chip-select */
+			cs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;
+		} else {
+			/* set the chip select */
+			cs &= ~(BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01);
+			cs |= spi->chip_select;
+		}
+	} else {
+		/* disable CSPOL which puts HW-CS into deselected state */
+		cs &= ~BCM2835_SPI_CS_CSPOL;
+		/* use the "undefined" chip-select as precaution */
+		cs |= BCM2835_SPI_CS_CS_10 | BCM2835_SPI_CS_CS_01;
+	}
+
+	/* finally set the calculated flags in SPI_CS */
+	bcm2835_wr(bs, BCM2835_SPI_CS, cs);
+}
+
+static int chip_match_name(struct gpio_chip *chip, void *data)
+{
+	return !strcmp(chip->label, data);
+}
+
+static int bcm2835_spi_setup(struct spi_device *spi)
+{
+	int err;
+	struct gpio_chip *chip;
+	struct device_node *pins;
+	u32 pingroup_index;
+	/*
+	 * sanity checking the native-chipselects
+	 */
+	if (spi->mode & SPI_NO_CS)
+		return 0;
+	if (gpio_is_valid(spi->cs_gpio))
+		return 0;
+	if (spi->chip_select > 1) {
+		/* error in the case of native CS requested with CS > 1
+		 * officially there is a CS2, but it is not documented
+		 * which GPIO is connected with that...
+		 */
+		dev_err(&spi->dev,
+			"setup: only two native chip-selects are supported\n");
+		return -EINVAL;
+	}
+
+	/* now translate native cs to GPIO */
+	/* first look for chip select pins in the devices pin groups */
+	for (pingroup_index = 0;
+	     (pins = of_parse_phandle(spi->master->dev.of_node,
+				     "pinctrl-0",
+				      pingroup_index)) != 0;
+	     pingroup_index++) {
+		u32 pin;
+		u32 pin_index;
+		for (pin_index = 0;
+		     of_property_read_u32_index(pins,
+						"brcm,pins",
+						pin_index,
+						&pin) == 0;
+		     pin_index++) {
+			if (((spi->chip_select == 0) &&
+			     ((pin == 8) || (pin == 36) || (pin == 46))) ||
+			    ((spi->chip_select == 1) &&
+			     ((pin == 7) || (pin == 35)))) {
+				spi->cs_gpio = pin;
+				break;
+			}
+		}
+		of_node_put(pins);
+	}
+	/* if that fails, assume GPIOs 7-11 are used */
+	if (!gpio_is_valid(spi->cs_gpio) ) {
+		/* get the gpio chip for the base */
+		chip = gpiochip_find("pinctrl-bcm2835", chip_match_name);
+		if (!chip)
+			return 0;
+
+		/* and calculate the real CS */
+		spi->cs_gpio = chip->base + 8 - spi->chip_select;
+	}
+
+	/* and set up the "mode" and level */
+	dev_info(&spi->dev, "setting up native-CS%i as GPIO %i\n",
+		 spi->chip_select, spi->cs_gpio);
+
+	/* set up GPIO as output and pull to the correct level */
+	err = gpio_direction_output(spi->cs_gpio,
+				    (spi->mode & SPI_CS_HIGH) ? 0 : 1);
+	if (err) {
+		dev_err(&spi->dev,
+			"could not set CS%i gpio %i as output: %i",
+			spi->chip_select, spi->cs_gpio, err);
+		return err;
+	}
+	/* the implementation of pinctrl-bcm2835 currently does not
+	 * set the GPIO value when using gpio_direction_output
+	 * so we are setting it here explicitly
+	 */
+	gpio_set_value(spi->cs_gpio, (spi->mode & SPI_CS_HIGH) ? 0 : 1);
+
+	return 0;
+}
+
+static int bcm2835_spi_probe(struct platform_device *pdev)
+{
+	struct spi_master *master;
+	struct bcm2835_spi *bs;
+	struct resource *res;
+	int err;
+
+	master = spi_alloc_master(&pdev->dev, sizeof(*bs));
+	if (!master) {
+		dev_err(&pdev->dev, "spi_alloc_master() failed\n");
+		return -ENOMEM;
+	}
+
+	platform_set_drvdata(pdev, master);
+
+	master->mode_bits = BCM2835_SPI_MODE_BITS;
+	master->bits_per_word_mask = SPI_BPW_MASK(8);
+	master->num_chipselect = 3;
+	master->setup = bcm2835_spi_setup;
+	master->set_cs = bcm2835_spi_set_cs;
+	master->transfer_one = bcm2835_spi_transfer_one;
+	master->handle_err = bcm2835_spi_handle_err;
+	master->prepare_message = bcm2835_spi_prepare_message;
+	master->dev.of_node = pdev->dev.of_node;
+
+	bs = spi_master_get_devdata(master);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	bs->regs = devm_ioremap_resource(&pdev->dev, res);
+	if (IS_ERR(bs->regs)) {
+		err = PTR_ERR(bs->regs);
+		goto out_master_put;
+	}
+
+	bs->clk = devm_clk_get(&pdev->dev, NULL);
+	if (IS_ERR(bs->clk)) {
+		err = PTR_ERR(bs->clk);
+		dev_err(&pdev->dev, "could not get clk: %d\n", err);
+		goto out_master_put;
+	}
+
+	bs->irq = irq_of_parse_and_map(pdev->dev.of_node, 0);
+	if (bs->irq <= 0) {
+		dev_err(&pdev->dev, "could not get IRQ: %d\n", bs->irq);
+		err = bs->irq ? bs->irq : -ENODEV;
+		goto out_master_put;
+	}
+
+	clk_prepare_enable(bs->clk);
+
+	err = devm_request_irq(&pdev->dev, bs->irq, bcm2835_spi_interrupt, 0,
+			       dev_name(&pdev->dev), master);
+	if (err) {
+		dev_err(&pdev->dev, "could not request IRQ: %d\n", err);
+		goto out_clk_disable;
+	}
+
+	bcm2835_dma_init(master, &pdev->dev);
+
+	/* initialise the hardware with the default polarities */
+	bcm2835_wr(bs, BCM2835_SPI_CS,
+		   BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);
+
+	err = devm_spi_register_master(&pdev->dev, master);
+	if (err) {
+		dev_err(&pdev->dev, "could not register SPI master: %d\n", err);
+		goto out_clk_disable;
+	}
+
+	return 0;
+
+out_clk_disable:
+	clk_disable_unprepare(bs->clk);
+out_master_put:
+	spi_master_put(master);
+	return err;
+}
+
+static int bcm2835_spi_remove(struct platform_device *pdev)
+{
+	struct spi_master *master = platform_get_drvdata(pdev);
+	struct bcm2835_spi *bs = spi_master_get_devdata(master);
+
+	/* Clear FIFOs, and disable the HW block */
+	bcm2835_wr(bs, BCM2835_SPI_CS,
+		   BCM2835_SPI_CS_CLEAR_RX | BCM2835_SPI_CS_CLEAR_TX);
+
+	clk_disable_unprepare(bs->clk);
+
+	bcm2835_dma_release(master);
+
+	return 0;
+}
+
+static const struct of_device_id bcm2835_spi_match[] = {
+	{ .compatible = "brcm,bcm2835-spi",
+	  .compatible = "brcm,bcm2708-spi-dma", },
+	{}
+};
+MODULE_DEVICE_TABLE(of, bcm2835_spi_match);
+
+static struct platform_driver bcm2835_spi_driver = {
+	.driver		= {
+		.name		= DRV_NAME,
+		.of_match_table	= bcm2835_spi_match,
+	},
+	.probe		= bcm2835_spi_probe,
+	.remove		= bcm2835_spi_remove,
+};
+module_platform_driver(bcm2835_spi_driver);
+
+MODULE_DESCRIPTION("SPI controller driver for Broadcom BCM2835");
+MODULE_AUTHOR("Chris Boot <bootc@bootc.net>");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/video/Kconfig b/drivers/video/Kconfig
index e0606c01e8ac..1493ac7ec3ec 100644
--- a/drivers/video/Kconfig
+++ b/drivers/video/Kconfig
@@ -40,6 +40,8 @@ config VIDEOMODE_HELPERS
 config HDMI
 	bool
 
+source "drivers/video/4d-hats/Kconfig"
+
 if VT
 	source "drivers/video/console/Kconfig"
 endif
diff --git a/drivers/video/Makefile b/drivers/video/Makefile
index 9ad3c17d6456..86b3d4f71ea1 100644
--- a/drivers/video/Makefile
+++ b/drivers/video/Makefile
@@ -6,6 +6,7 @@ obj-$(CONFIG_LOGO)		  += logo/
 obj-y				  += backlight/
 
 obj-y				  += fbdev/
+obj-y                             += 4d-hats/
 
 obj-$(CONFIG_VIDEOMODE_HELPERS) += display_timing.o videomode.o
 ifeq ($(CONFIG_OF),y)
diff --git a/include/linux/input/ft6x06_ts.h b/include/linux/input/ft6x06_ts.h
new file mode 100644
index 000000000000..2233051427cf
--- /dev/null
+++ b/include/linux/input/ft6x06_ts.h
@@ -0,0 +1,31 @@
+#ifndef __LINUX_FT6X06_TS_H__
+#define __LINUX_FT6X06_TS_H__
+
+/* -- dirver configure -- */
+#define CFG_MAX_TOUCH_POINTS	2
+
+#define PRESS_MAX	0xFF
+#define FT_PRESS		0x7F
+
+#define FT6X06_NAME 	"ft6x06_ts"
+
+#define FT_MAX_ID	0x0F
+#define FT_TOUCH_STEP	6
+#define FT_TOUCH_X_H_POS		3
+#define FT_TOUCH_X_L_POS		4
+#define FT_TOUCH_Y_H_POS		5
+#define FT_TOUCH_Y_L_POS		6
+#define FT_TOUCH_EVENT_POS		3
+#define FT_TOUCH_ID_POS			5
+
+/*register address*/
+#define FT6x06_REG_FW_VER		0xA6
+#define FT6x06_REG_POINT_RATE	0x88
+#define FT6x06_REG_THGROUP	0x80
+
+struct ft6x06_platform_data {
+	unsigned int irq_gpio;
+	unsigned int reset_gpio;
+};
+
+#endif
